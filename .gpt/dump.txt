&&& FILE: ./Magnetizing_FPG/MagnetizingRooms_ES.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class MagnetizingRooms_ES : GH_Component
    {

        Random random = new Random();

        List<RoomCells> roomCellsList = new List<RoomCells>();
        List<GridSolution> gridSolutionsCollection;

        // MaxRatio stated for maximum allowed proportions of every room. 
        const double MaxRatio = 1.9f;
        
        double boundaryOffset = 2.3f;

        // That's needed for AppendAdditionalMenuItems functions.
        bool oneSideCorridorsChecked = false;
        bool twoSidesCorridorsChecked = true;
        bool allSidesCorridorsChecked = false;

        bool corridorsAsAdditionalSpacesChecked = true;

        bool shouldOnlyRecomputeDeadEnds = false;

        bool removeDeadEndsChecked = true;
        bool removeAllCorridorsChecked = false;

        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public MagnetizingRooms_ES()
          : base("MagnetizingRooms_ES", "Magnetizing_FPG",
              "MagnetizingRooms_ES",
              "Magnetizing_FPG", "Magnetizing_FPG")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("House Instance", "HI", "One or more House Instances. It already contains the information about " +
                "boundary, areas of rooms, starting point and so on.", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Iterations", "I", "Iterations counter. Generally value between 300-900 works best.", GH_ParamAccess.item, 3);
            pManager.AddNumberParameter("MaxAdjDistance", "MAD", "Max distance between 2 connected rooms. Generally 2-3 works best.", GH_ParamAccess.item, 2);
            pManager.AddNumberParameter("CellSize(m)", "CS(m)", "Resolution of grid in meters, 1m is used by default", GH_ParamAccess.item, 1);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddBrepParameter("Corridors", "C", "Corridors as Breps", GH_ParamAccess.item);
            pManager.AddBrepParameter("Room Breps", "Rs", "Rooms as Breps list", GH_ParamAccess.list);
            pManager.AddTextParameter("Room Names", "Ns", "Room Names", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacencies", "A", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.item);
            pManager.AddIntegerParameter("MissingAdjacences", "!A", "Missing Adjacences for every room of the list", GH_ParamAccess.list);
            pManager.AddCurveParameter("Boundary", "B", "Boundary output", GH_ParamAccess.item);
            pManager.AddCurveParameter("Boundary+Offset", "Bo", "Boundary offset output", GH_ParamAccess.item);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<Curve> rooms = new List<Curve>();
            List<int> dims = new List<int>();
            int iterations = 0;
            List<int> roomAreas = new List<int>();
            List<string> adjStrList = new List<string>();
            double maxAdjDistance = 0;
            int entranceIndexInRoomAreas = -1;
            HouseInstance houseInstance = new HouseInstance();
            double oneCellSize = 1;

            GH_ObjectWrapper houseInstanceWrapper = new GH_ObjectWrapper();
            DA.GetData("House Instance", ref houseInstanceWrapper);
            houseInstance = houseInstanceWrapper.Value as HouseInstance;

            DA.GetData("CellSize(m)", ref oneCellSize);

            // initialRoomsList contains all (RoomInstance) objects with their attributes.
            List<RoomInstance> initialRoomsList = houseInstance.RoomInstances;
            Curve boundaryCrv = houseInstance.boundary;
            int[,] adjArray = houseInstance.adjArray;
            adjStrList = houseInstance.adjStrList;

            DA.SetData("Boundary", boundaryCrv);
            boundaryCrv = boundaryCrv.Offset(Plane.WorldXY, boundaryOffset, 0.001f, CurveOffsetCornerStyle.Sharp)[0];
            DA.SetData("Boundary+Offset", boundaryCrv);

            
            boundaryCrv.Scale(1 / oneCellSize);
            houseInstance.startingPoint.Transform(Transform.Scale(new Point3d(0, 0, 0), 1 / oneCellSize));

            // startingPoints contains a list of Points which were provided as points for placing the first (entrance) room.
            // IMPORTANT: currently the algorithm can't work with a list of points, it uses only the first one from the list.
            List<Point3d> startingPoints = new List<Point3d>();
            startingPoints.Add(houseInstance.startingPoint);

            // Let's go through all the rooms from the input and try to find the entrance room. It must be placed first.
            // RoomInstance.entranceIds is a static field, it contains a list of all entrance rooms which are on grasshopper workingGrid.
            // For example, if we have 3 room structures on the workingGrid (3 houses), then the list will contain 3 rooms: one for every house.
            for (int i = 0; i < initialRoomsList.Count; i++)
                if (RoomInstance.entranceIds.Contains(initialRoomsList[i].RoomId))
                {
                    entranceIndexInRoomAreas = i + 1;
                    break;
                }

            int x = 0;
            int y = 0;

            DA.GetData("Iterations", ref iterations);
            DA.GetData("MaxAdjDistance", ref maxAdjDistance);

            // Let's deal with setting boundary curve. The curve is rotated so it fits best into rectangle. 
            // Then a workingGrid of cells (Breps) should be generated so it covers the whole boundary.
            // As we generated a workingGrid of cells on top of the rotated boundary, they should be rotated back again,
            // together with the boundary itself.
            // Moreover, we should rotate the starting point also.

            double boundaryCurveRotationRad = 0;
            double minBoundaryArea = double.MaxValue;
            if (houseInstance.tryRotateBoundary)

                for (double i = 0; i <= Math.PI / 2f; i += Math.PI / 360f)
                {
                    Curve rotatedBoundaryCurve = boundaryCrv.Duplicate() as Curve;
                    rotatedBoundaryCurve.Rotate(i, Vector3d.ZAxis, rotatedBoundaryCurve.GetBoundingBox(false).Center);
                    double newArea = AreaMassProperties.Compute(new Rectangle3d(new Plane(rotatedBoundaryCurve.GetBoundingBox(false).Center, Vector3d.ZAxis)
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.X
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.Y).ToNurbsCurve()).Area;

                    if (newArea < minBoundaryArea)
                    {
                        minBoundaryArea = newArea;
                        boundaryCurveRotationRad = i;
                    }
                }
            Point3d rotationCenter = boundaryCrv.GetBoundingBox(false).Center;
            Point3d tempP = startingPoints[0];
            tempP.Transform(Transform.Rotation(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter));
            startingPoints[0] = tempP;
            boundaryCrv.Rotate(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);

            x = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.X);
            y = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.Y);

            Point3d originPoint = boundaryCrv.GetBoundingBox(false).Corner(true, true, true);
            Vector3d diagonal = boundaryCrv.GetBoundingBox(false).Diagonal;

            // gridSurfaceArray will contain all cell Breps for our workingGrid. They will be used to form
            // rooms and corridors in the very end of the algorithm.
            Surface[] gridSurfaceArray = new Surface[x * y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    gridSurfaceArray[j + y * i] = new PlaneSurface(new Plane(
                        Point3d.Origin, Vector3d.ZAxis)
                        , new Interval(originPoint.X + (i) * diagonal.X / x, originPoint.X + (i + 1) * diagonal.X / x)
                        , new Interval(originPoint.Y + (j) * diagonal.Y / y, originPoint.Y + (j + 1) * diagonal.Y / y));



            if (houseInstance.tryRotateBoundary)
                for (int i = 0; i < x; i++)
                    for (int j = 0; j < y; j++)
                        gridSurfaceArray[i + x * j].Rotate(-boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);

            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    gridSurfaceArray[i + x * j].Scale(oneCellSize);


            // So the cells are rotated back again, they can be used now.

            // workingGrid is an array[int, int], containing the current state of a room structure.
            //
            // If the cell = -1         -> it is a corridor
            //             =  0         -> it is free
            //             =  N (1-...) -> it is a room 
            //             =  9999      -> it is outside initial curve boundary, therefore it cannot be used
            //                             (sorry for that, was too lazy to write smth more complicated)

            // If the initial curve boundary was not rectangular, we should make sure that the algorithm
            // will not place rooms outside it. Let's fill all cells with 9999 (sorry for that, was too lazy to write smth more complicated)
            int[,] workingGrid = new int[x, y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    if (boundaryCrv.Contains(new Point3d(boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X + i + 0.5f
                    , boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y + j + 0.5f, 0)) == PointContainment.Inside)
                        workingGrid[i, j] = 0;
                    else
                        workingGrid[i, j] = 9999;


            // If there is no startingPoint provided, let's assume that the center of 
            // the grid is a starting point.
            if (startingPoints == null)
                workingGrid[x / 2, y / 2] = -1;
            else
                foreach (Point3d point in startingPoints)
                {
                    if (boundaryCrv.Contains(point) == PointContainment.Inside)
                    {
                        int xIndex = (int)Math.Floor(point.X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X);
                        int yIndex = (int)Math.Floor(point.Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y);
                        workingGrid[xIndex, yIndex] = -1;
                    }
                }


            // Actual algorithm starts.

            // Let's save the initial state of workingGrid, so we can restore it in each iteration beginning
            int[,] initialWorkingGrid = workingGrid.Clone() as int[,];

            // placedRoomsOrderedList contains the current order of rooms based on their priority. Rooms which
            // have more adjacences with already placed rooms have higher priority. For example if
            // room_1, room_2, room_3 are already placed and room_4 (adj. to 1, 2), room_5 (adj. to 4, 6),
            // room_6 (adj. to 1, 2, 3) are not placed yet,
            // the placedRoomsOrderedList list will look like {room_6, room_4, room_5}.
            List<int> placedRoomsOrderedList = new List<int>();
            bool placedEntranceRoom;

            // If there is no need to execute the whole sequence, for example when user only 
            // checkes shouldOnlyRecomputeDeadEnds variable and does not change initial input,
            // then let's set iterations to 0 and do not execute the main part.
            // Otherwise, let's initialize gridSolutionsCollection list. It will
            // contain the whole number of best solutions (explained in details further).
            if (shouldOnlyRecomputeDeadEnds && gridSolutionsCollection != null && gridSolutionsCollection.Count > 0)
            {
                shouldOnlyRecomputeDeadEnds = false;
                iterations = 0;
            }
            else
                gridSolutionsCollection = new List<GridSolution>();

            // This is the main part of the algorithm.
            for (int currentIteration = 0; currentIteration < iterations; currentIteration++)
            {
                // gridSolutionCurrentIndex indicates current solution from gridSolution that we are working with.
                // So, each THIRD (explained below) iteration we try to alter a number of best solutions that we get from previous
                // iteration, and if these new solutions are better, we exchange them with initial ones.

                // gridSolutionCapacity is number of solutions that we keep after each iteration.
                // After every iteration the gridSolution list is sorted and then shortened to its capacity.
                int gridSolutionCapacity = 5;
                for (int gridSolutionCurrentIndex = 0; gridSolutionCurrentIndex < gridSolutionCapacity; gridSolutionCurrentIndex++)
                {
                    // If (iteration % newSolutionsFrequency != 0) -> some new solutions are generated, so we don't get stuck with local maximum.
                    int newSolutionsFrequency = 3;

                    // If it is time to alter one of previous solutions...
                    if (gridSolutionsCollection.Count > gridSolutionCurrentIndex && currentIteration != 0 && currentIteration % newSolutionsFrequency == 0)
                    {
                        // ... then let's fill all variables used in algorithm with already precomputed data
                        // from previous iteration.
                        placedEntranceRoom = true;

                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].grid.GetLength(0); q++)
                            for (int w = 0; w < gridSolutionsCollection[gridSolutionCurrentIndex].grid.GetLength(1); w++)
                                workingGrid[q, w] = gridSolutionsCollection[gridSolutionCurrentIndex].grid[q, w];

                        placedRoomsOrderedList.Clear();
                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList.Count; q++)
                            placedRoomsOrderedList.Add(gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList[q]);

                        roomCellsList.Clear();
                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].roomCellsList.Count; q++)
                            roomCellsList.Add(new RoomCells(gridSolutionsCollection[gridSolutionCurrentIndex].roomCellsList[q]));

                        // Then let's remove last placed 1-5 rooms from the solution. So we can try to place
                        // them differently and maybe a new and better way of placement would appear.
                        int roomRemovalCount = 1 + random.Next(5);
                        for (int j = 0; j < roomRemovalCount; j++)
                            if (placedRoomsOrderedList.Count > 1)
                            {
                                RemoveRoomFromGrid(ref workingGrid, roomCellsList[placedRoomsOrderedList[placedRoomsOrderedList.Count - 1]]);
                                placedRoomsOrderedList.RemoveAt(placedRoomsOrderedList.Count - 1);
                            }
                    }
                    // If it is time to generate a new solution, let's initialize all
                    // required variables and proceed.
                    else
                    {
                        workingGrid = initialWorkingGrid.Clone() as int[,];
                        placedRoomsOrderedList = new List<int>();
                        placedEntranceRoom = false;

                        roomCellsList.Clear();
                        foreach (RoomInstance room in initialRoomsList)
                            roomCellsList.Add(new RoomCells());
                    }

                    // Let's try to place each room in case it is not placed yet
                    for (int j = 0; j < initialRoomsList.Count; j++)
                    {
                        // In the very beginning of the algorithm's execution we have set a value 
                        // in a starting point of a workingGrid from 0 to -1. When the first room is already
                        // placed, we can remove that first starting point. Otherwise, it can affect the
                        // structure of rooms and cause some empty spaces in between them to appear.
                        if (j == 1 && workingGrid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] == -1 && placedRoomsOrderedList.Count == 1)
                        {
                            workingGrid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] = 0;
                        }

                        // This list contains all rooms that are to be placed, together with their 
                        // priority.
                        // IntPair contains {(room number in the initialRoomsList) + 1, room priority}
                        List<IntPair> roomsOrderList = new List<IntPair>();

                        for (int w = 1; w <= initialRoomsList.Count; w++)
                            if (!GridContains(workingGrid, w))
                                roomsOrderList.Add(new IntPair(w, 0));
                            else
                                roomsOrderList.Add(new IntPair(w, -1));

                        // Let's fill the priority of every room and then sort the list
                        for (int q = 0; q < adjArray.GetLength(0); q++)
                        {
                            if (GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber) && !GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber))
                                roomsOrderList[adjArray[q, 0] - 1] = new IntPair(roomsOrderList[adjArray[q, 0] - 1].roomNumber
                                    , roomsOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                            if (GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber) && !GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber))
                                roomsOrderList[adjArray[q, 1] - 1] = new IntPair(roomsOrderList[adjArray[q, 1] - 1].roomNumber
                                    , roomsOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);
                        }
                        roomsOrderList = roomsOrderList.OrderBy(key => -key.AdjNum).ToList();

                        // roomToBePlacedNum contains the number of next room which should be placed on the workingGrid.
                        int roomToBePlacedNum;

                        // So if the entrance room is not place yet, let's place it first!
                        if (RoomInstance.entranceIds.Count > 0 && entranceIndexInRoomAreas >= 0 && placedEntranceRoom == false)
                        {
                            roomToBePlacedNum = entranceIndexInRoomAreas;
                            placedEntranceRoom = true;
                        }
                        // If at least one unplaced room is adjacent to at least one placed room, then place it
                        else if (roomsOrderList[0].AdjNum > 0)
                            roomToBePlacedNum = roomsOrderList[0].roomNumber;
                        // If no, then place the most adjacent room overall
                        else
                        {
                            roomsOrderList = new List<IntPair>();

                            for (int w = 1; w <= initialRoomsList.Count; w++)
                                if (!GridContains(workingGrid, w))
                                    roomsOrderList.Add(new IntPair(w, 0));
                                else
                                    roomsOrderList.Add(new IntPair(w, -1));

                            for (int q = 0; q < adjArray.GetLength(0); q++)
                            {
                                if (!GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber))
                                    roomsOrderList[adjArray[q, 0] - 1] = new IntPair(roomsOrderList[adjArray[q, 0] - 1].roomNumber
                                        , roomsOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                                if (!GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber))
                                    roomsOrderList[adjArray[q, 1] - 1] = new IntPair(roomsOrderList[adjArray[q, 1] - 1].roomNumber
                                        , roomsOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                            }
                            roomsOrderList = roomsOrderList.OrderBy(key => -key.AdjNum).ToList();
                            roomToBePlacedNum = roomsOrderList[0].roomNumber;
                        }

                        // Check again that workingGrid does not contain roomToBePlacedNum. 
                        // It should not happen, but whatever ¯\_(ツ)_/¯
                        if (!GridContains(workingGrid, roomToBePlacedNum))
                        {
                            // This is the function which determines the position of a room and which 
                            // tries to place it. However, if the room can't be placed anywhere,
                            // the iteration stops. Then results are evaluated and the next iteration starts.
                            if (TryPlaceNewRoomToTheGrid(ref workingGrid, initialRoomsList[roomToBePlacedNum - 1].RoomArea / oneCellSize / oneCellSize 
                                , roomToBePlacedNum, adjArray, maxAdjDistance, initialRoomsList[roomToBePlacedNum - 1].isHall))
                                placedRoomsOrderedList.Add(roomToBePlacedNum - 1);
                            else
                                break;
                        }
                    }

                    // If the new solution is one of altered previous solutions and it is better
                    // than its predecessor, then let's exchange them. 
                    // Other decision could be just to add a new solution to the list and do not
                    // remove the predecessor, however, it is not made like this intentionally.
                    // This decision badly affects the variety of results.
                    if (gridSolutionsCollection.Count > gridSolutionCurrentIndex && currentIteration % gridSolutionCapacity == 0)
                    {
                        if (placedRoomsOrderedList.Count > gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList.Count)
                        {
                            gridSolutionsCollection.Add(new GridSolution(workingGrid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), placedRoomsOrderedList));
                            gridSolutionsCollection.RemoveAt(gridSolutionCurrentIndex);
                        }
                    }
                    else
                        gridSolutionsCollection.Add(new GridSolution(workingGrid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), placedRoomsOrderedList));

                }

                // Let's shorten the gridSolutionsCollection a bit, so it won't
                // get too big.
                gridSolutionsCollection = gridSolutionsCollection.OrderBy(solution => -solution.placedRoomsOrderedList.Count).ToList();
                if (gridSolutionsCollection.Count > gridSolutionCapacity + 2)
                    gridSolutionsCollection.RemoveRange(gridSolutionCapacity + 2, Math.Max(0, gridSolutionsCollection.Count - gridSolutionCapacity - 2));
            }

            // Not it's time to sort gridSolutionsCollection! It is sorted according to the number of placed rooms
            // in every solution.
            gridSolutionsCollection = gridSolutionsCollection.OrderBy(solution => -solution.placedRoomsOrderedList.Count).ToList() as List<GridSolution>;


            // bestGrid contains the best solution after all iterations. Only this
            // solution is used further for generating output data.
            int[,] bestGrid = gridSolutionsCollection[0].grid.Clone() as int[,];

            if (removeDeadEndsChecked)
                RemoveDeadEnds(ref bestGrid, gridSolutionsCollection[0].roomCellsList);

            if (removeAllCorridorsChecked)
                RemoveAllCorridors(ref bestGrid, gridSolutionsCollection[0].roomCellsList);

            // the list that contains all values from bestGrid, but in linear array.
            List<int> bestGridLinear = new List<int>();

            HashSet<int> placedRoomsNums = new HashSet<int>();

            // Remove all '9999' cells, they stand for cells that are outside the curve boundary of the building
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                {
                    // Again sorry for that lazy solution ¯\_(ツ)_/¯
                    if (bestGrid[i, j] != 9999)
                        bestGridLinear.Add(bestGrid[i, j]);
                    else
                        bestGridLinear.Add(0);

                    if (!placedRoomsNums.Contains(bestGrid[i, j]) && bestGrid[i, j] != 0 && bestGrid[i, j] != -1 && bestGrid[i, j] != 9999)
                        placedRoomsNums.Add(bestGrid[i, j]);
                }
            //placedRoomsNums.Sort();

            // Indicate all RoomInstances that are not placed in the workingGrid on the graph in grasshopper window
            List<int> missingRoomAdj = MissingRoomAdjacences(bestGrid, adjArray);
            for (int i = 0; i < initialRoomsList.Count; i++)
                if (!placedRoomsNums.Contains(Convert.ToInt32(i + 1)))
                {
                    if (initialRoomsList[i].hasMissingAdj != true)
                        initialRoomsList[i].hasMissingAdj = true;
                }
                else
                {
                    if (initialRoomsList[i].hasMissingAdj != false)
                        initialRoomsList[i].hasMissingAdj = false;
                }

            List<int> placedRoomsNumsList = placedRoomsNums.ToList();


            // missingRoomAdj is not the list that we're looking for. It considers wrong list of rooms (all of them, instead of only placed ones)
            // So we have to fix it a bit
            List<int> missingRoomAdjSortedList = new List<int>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
                missingRoomAdjSortedList.Add(missingRoomAdj[placedRoomsNumsList[i] - 1]);


            List<string> roomNames = new List<string>();
            for (int i = 0; i < placedRoomsNumsList.Count; i++)
            {
                if (!initialRoomsList[placedRoomsNumsList[i] - 1].isHall)
                    roomNames.Add(initialRoomsList[placedRoomsNumsList[i] - 1].RoomName);
                else
                    roomNames.Add("&&HALL&&" + initialRoomsList[placedRoomsNumsList[i] - 1].RoomName);
            }


            // That should not be there I guess

            /*            // At the end let's convert all needed rooms to halls   
            for (int i = 0; i < bestGrid.GetLength(0); i++)
                for (int j = 0; j < bestGrid.GetLength(1); j++)
                    if (bestGrid[i, j] > 0 && bestGrid[i, j] <= initialRoomsList.Count)
                        if (initialRoomsList[bestGrid[i, j] - 1].isHall)
                            bestGrid[i, j] = -1;
            */


            // Now let's convert all cells to corresponding rooms
            List<Brep> roomBrepsList = new List<Brep>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < bestGridLinear.Count; q++)
                    if (bestGridLinear[q] == placedRoomsNumsList[i])
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    roomBrepsList.Add(Brep.JoinBreps(cellsCollection, 0.01f)[0]);

            }

            // Now let's convert all cells to united corridors structure
            Brep corridorsBrep = new Brep();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < bestGridLinear.Count; q++)
                    if (bestGridLinear[q] == -1)
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    corridorsBrep = Brep.JoinBreps(cellsCollection, 0.01f)[0];

            }

            string adjacenciesOutputString = "";
            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (placedRoomsNumsList.Contains(adjArray[i, 0]) && placedRoomsNumsList.Contains(adjArray[i, 1]))
                    adjacenciesOutputString += placedRoomsNumsList.IndexOf(adjArray[i, 0]) + "-" + placedRoomsNumsList.IndexOf(adjArray[i, 1]) + "\n";

            DA.SetDataList("Room Breps", roomBrepsList);
            DA.SetData("Corridors", corridorsBrep);
            DA.SetDataList("MissingAdjacences", missingRoomAdjSortedList);
            DA.SetData("Adjacencies", adjacenciesOutputString);
            DA.SetDataList("Room Names", roomNames);

            this.Message = gridSolutionsCollection[0].placedRoomsOrderedList.Count + " of " + initialRoomsList.Count + " placed";
        }

        /// <summary>
        /// This function serves for removing dead ends from the corridor structure 
        /// after the main part of generation is executed already.
        /// The 'dead end' is a corridor, which is not actually required for the 
        /// corridor system to be coherent.
        /// </summary>
        /// <param name="grid"> workingGrid</param>
        /// <param name="roomCellsList"> List of all dimensions and positions of all rooms which are placed on a grid</param>
        private void RemoveDeadEnds(ref int[,] grid, List<RoomCells> roomCellsList)
        {
            List<int[]> toRemove = new List<int[]>();
            List<int> newValues = new List<int>();

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {
                        List<int[]> neighbours = new List<int[]>();
                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (j >= 0 && j < grid.GetLength(1))
                        {
                            if (i > 0)
                                if (grid[i - 1, j] == -1)
                                    neighbours.Add(new int[] { i - 1, j });
                            if (i < grid.GetLength(0) - 1)
                                if (grid[i + 1, j] == -1)
                                    neighbours.Add(new int[] { i + 1, j });
                        }
                        if (i >= 0 && i < grid.GetLength(0))
                        {
                            if (j > 0)
                                if (grid[i, j - 1] == -1)
                                    neighbours.Add(new int[] { i, j - 1 });
                            if (j < grid.GetLength(1) - 1)
                                if (grid[i, j + 1] == -1)
                                    neighbours.Add(new int[] { i, j + 1 });
                        }

                        if (neighbours.Count == 1)
                        {
                            //toRemove.Add(new int[] { i, j });
                            int iT = i;
                            int jT = j;

                            int iDelta = neighbours[0][0] - i;
                            int jDelta = neighbours[0][1] - j;


                            if (indexInRoomCellsList >= 0)
                                while (jT >= 0 && jT < grid.GetLength(1) && iT >= 0 && iT < grid.GetLength(0)
                                    && grid[iT, jT] == -1 && neighbours.Count <= 2
                                    && iT >= roomCellsList[indexInRoomCellsList].x && iT < roomCellsList[indexInRoomCellsList].x + roomCellsList[indexInRoomCellsList].w
                                && jT >= roomCellsList[indexInRoomCellsList].y && jT < roomCellsList[indexInRoomCellsList].y + roomCellsList[indexInRoomCellsList].h)
                                {
                                    toRemove.Add(new int[] { iT, jT });
                                    newValues.Add(indexInRoomCellsList + 1);
                                    iT += iDelta;
                                    jT += jDelta;

                                    neighbours = new List<int[]>();

                                    if (jT >= 0 && jT < grid.GetLength(1))
                                    {
                                        if (iT > 0)
                                            if (grid[iT - 1, jT] == -1)
                                                neighbours.Add(new int[] { iT - 1, jT });
                                        if (iT < grid.GetLength(0) - 1)
                                            if (grid[iT + 1, jT] == -1)
                                                neighbours.Add(new int[] { iT + 1, jT });
                                    }
                                    if (iT >= 0 && iT < grid.GetLength(0))
                                    {
                                        if (jT > 0)
                                            if (grid[iT, jT - 1] == -1)
                                                neighbours.Add(new int[] { iT, jT - 1 });
                                        if (jT < grid.GetLength(1) - 1)
                                            if (grid[iT, jT + 1] == -1)
                                                neighbours.Add(new int[] { iT, jT + 1 });
                                    }
                                }
                        }
                    }
                }

            for (int i = 0; i < toRemove.Count; i++)
                grid[toRemove[i][0], toRemove[i][1]] = newValues[i];
        }

        /// <summary>
        /// This function serves for removing all corridors from the corridor structure 
        /// after the main part of generation is executed already.
        /// Corridors are added to the area of corresponding rooms.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="roomCellsList"></param>
        private void RemoveAllCorridors(ref int[,] grid, List<RoomCells> roomCellsList)
        {

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {

                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (indexInRoomCellsList > -1)
                            grid[i, j] = indexInRoomCellsList + 1;
                    }
                }
        }

        /// <summary>
        /// Contains the whole solution that was once computed. It is used to
        /// store solutions which were generated during previous iterations.
        /// </summary>
        private class GridSolution
        {
            public int[,] grid;
            public List<RoomCells> roomCellsList = new List<RoomCells>();
            public List<int> placedRoomsOrderedList = new List<int>();

            public GridSolution(int[,] Grid, List<RoomCells> RoomCellsList, List<int> RoomOrder)
            {
                grid = Grid;
                roomCellsList = RoomCellsList.ConvertAll(roomCells => new RoomCells(roomCells));
                placedRoomsOrderedList = RoomOrder.ConvertAll(i => i);
            }
        }

        /// <summary>
        /// Returns a list of room numbers, which have missing adjacences.
        /// Later this information is used for indicating rooms which miss connections.
        /// It is indicated with red dots in Rhino environment.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="adjArray"></param>
        /// <returns></returns>
        public List<int> MissingRoomAdjacences(int[,] grid, int[,] adjArray)
        {
            List<int> missingAdj = new List<int>();// (adjArray.GetLength(0));
            int maxRoomNum = 0;
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                 if (grid[i,j] < 999)
                        maxRoomNum = Math.Max(maxRoomNum, grid[i, j]);

            //for (int i = 0; i < adjArray.GetLength(0); i++)
              //  maxRoomNum = 
                //maxRoomNum = Math.Max(Math.Max(maxRoomNum, adjArray[i, 0]), adjArray[i, 1]);

            for (int i = 0; i < maxRoomNum; i++)
                missingAdj.Add(0);

            for (int l = 0; l < adjArray.GetLength(0); l++)
            {
                bool exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 0])
                            exists = true;
                if (!exists) 
                    if (adjArray[l, 1] - 1 < missingAdj.Count)
                    missingAdj[adjArray[l, 1] - 1]++;


                exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 1])
                            exists = true;
                if (!exists)
                    if (adjArray[l, 0] - 1 < missingAdj.Count)
                        missingAdj[adjArray[l, 0] - 1]++;
            }

            return missingAdj;
        }

        /// <summary>
        /// This is the function which determines the position of a room and which 
        /// tries to place it. 
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="area"></param>
        /// <param name="roomNumber"></param>
        /// <param name="adjArray"></param>
        /// <param name="maxAdjDistance"></param>
        /// <param name="isHall"></param>
        /// <returns></returns>
        public bool TryPlaceNewRoomToTheGrid(ref int[,] grid, double area, int roomNumber, int[,] adjArray, double maxAdjDistance, bool isHall = false)
        {
            int[,] availableCellsGrid = new int[grid.GetLength(0), grid.GetLength(1)];  //= workingGrid;
            int[,] room = new int[50, 50];

            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == roomNumber && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == roomNumber && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);

            // Let's try to define proportions for the room considering its area and 
            // the requested ratio 
            double ratio = 1 + random.NextDouble() * (MaxRatio - 1);
            double xDim_d = Math.Sqrt((area / ratio));
            double yDim_d = ratio * Math.Sqrt((area / ratio));

            xDim = (int)Math.Round(xDim_d);
            //yDim = (int)Math.Floor(area / (int)xDim);
            yDim = (int)Math.Round(yDim_d);

            if (xDim == 0)
                xDim++;
            if (yDim == 0)
                yDim++;

            if (random.Next(2) == 0)
            {
                int temp = xDim;
                xDim = yDim;
                yDim = temp;
            }


            // Choose the corridor generation mode according to MenuItemDropDown selection
            if (oneSideCorridorsChecked && !isHall)
            {
                if (random.Next(2) == 0)
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        xDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim + 1, yDim];
                    for (int i = 0; i < xDim + 1; i++)
                        for (int j = 0; j < yDim; j++)
                            if (i == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNumber;
                }
                else
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        yDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim, yDim + 1];
                    for (int i = 0; i < xDim; i++)
                        for (int j = 0; j < yDim + 1; j++)
                            if (j == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNumber;
                }

            }
            else if (twoSidesCorridorsChecked && !isHall)
            {
                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim--;
                    yDim--;
                }

                if (xDim == 0)
                    xDim++;
                if (yDim == 0)
                    yDim++;


                room = new int[xDim + 1, yDim + 1];
                for (int i = 0; i < xDim + 1; i++)
                    for (int j = 0; j < yDim + 1; j++)
                        if (i == 0 || j == 0)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNumber;
            }
            else if (allSidesCorridorsChecked || isHall)
            {
                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim -= 2;
                    yDim -= 2;
                }

                if (xDim <= 0)
                    xDim = 1;
                if (yDim <= 0)
                    yDim = 1;


                room = new int[xDim + 2, yDim + 2];
                for (int i = 0; i <= xDim + 1; i++)
                    for (int j = 0; j <= yDim + 1; j++)
                        if (i == 0 || j == 0 || i == xDim + 1 || j == yDim + 1)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNumber;
            }

            // availableCellsGrid contains 0 or 1 and indicated if the cell is available 
            // for placing a room there.

            // Start filling availableCellsGrid: 0 = not available, 1 = available
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    availableCellsGrid[i, j] = 0;

                    // So, if we find a free cell in a grid, let's check that it one
                    // of its neighbours is a corridor cell (so the placed room will 
                    // be attached to the corridor structure). 
                    if (grid[i, j] == 0)
                        for (int l = -1; l <= 1; l++)
                            for (int k = -1; k <= 1; k++)
                                if ((l == 0 || k == 0) && l != k)
                                    if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))
                                        if (grid[i + l, j + k] == -1)
                                        {
                                            // If we found that kind of a cell, let's check that it is 
                                            // close enough to rooms (only those which are placed already)
                                            // that must be connected to the room that is to be placed.
                                            if (CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                                            {
                                                // If so, let's check this cell as suitable for placing a new room
                                                availableCellsGrid[i, j] = 1;
                                                // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "availableCell! " + roomNum + ": " + i + "_" + j);
                                            }
                                        }
                }

            // This list contains all possible solutions for a room placement. It means,
            // that for every suitable cell from availableCellsGrid the algorithm
            // tries to place the room in all different ways (RoomPosition contains 
            // these different orientations that a room can take). Then, solutions
            // that are successful are placed into this list.
            //
            // It is also important to mention, that each of these solutions gets its 
            // rating. It is calculated according to number of rooms that share a border with
            // this newly placed room. So we can be sure that there will be as few empty
            // spaces between rooms as possible.
            // For instance, if there are 2 options for a room position: one in which a room is
            // sharing one border with another room (so 3 other sides are naked), and the other one
            // in which a room is placed in a way that it shares 3 sides with other rooms (and only
            // one side is naked) -> the rating of the second solutions will obviously be higher.
            // This is how we ensure that the final solution will be as compact as possible.
            List<RoomPlacementSolution> placementSolutions = new List<RoomPlacementSolution>();

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {

                    if (availableCellsGrid[i, j] == 1)
                    {
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.BottomLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomLeft, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.BottomLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.BottomRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomRight, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.BottomRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.TopLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopLeft, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.TopLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.TopRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopRight, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.TopRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                    }
                }

            // Let's order a list by rating
            placementSolutions = placementSolutions.OrderBy(t => -t.rating).ToList();

            if (placementSolutions.Count > 0)
            {
                int x = placementSolutions[0].x;
                int y = placementSolutions[0].y;
                int w = placementSolutions[0].room.GetLength(0);
                int h = placementSolutions[0].room.GetLength(1);

                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.TopLeft)
                    x -= w - 1;
                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.BottomRight)
                    y -= h - 1;

                roomCellsList[roomNumber - 1] = new RoomCells(x, y, w, h);


                // Finally, let's place a room where it should be placed! This line will do all work for us
                PlaceRoomSolution(placementSolutions[0], placementSolutions[0].room, ref grid, isHall);
                return true;
            }
            else
                return false;
        }
        
        /// <summary>
        /// Contains the dimensions and the origin of a room on a grid.
        /// </summary>
        private class RoomCells
        {
            public int x;
            public int y;
            public int w;
            public int h;

            public RoomCells() { }

            public RoomCells(int X, int Y, int W, int H)
            {
                x = X;
                y = Y;
                w = W;
                h = H;
            }

            public RoomCells(RoomCells roomCells)
            {
                x = roomCells.x;
                y = roomCells.y;
                w = roomCells.w;
                h = roomCells.h;
            }
        }

        private void RemoveRoomFromGrid(ref int[,] grid, RoomCells roomCells)
        {
            for (int i = roomCells.x; i < roomCells.x + roomCells.w; i++)
                for (int j = roomCells.y; j < roomCells.y + roomCells.h; j++)
                    grid[i, j] = 0;
        }

        /// <summary>
        /// Basically this function takes the RoomPlacementSolution and places it.
        /// It fills the corresponding cells of grid with the given room number.
        /// </summary>
        /// <param name="solution"></param>
        /// <param name="room"></param>
        /// <param name="grid"></param>
        /// <param name="isHall"></param>
        private void PlaceRoomSolution(RoomPlacementSolution solution, int[,] room, ref int[,] grid, bool isHall = false)
        {
            switch (solution.roomPosition)
            {
                case RoomPosition.TopRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[i - solution.x, j - solution.y];
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[i - solution.x, -(j - solution.y)];
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[-(i - solution.x), -(j - solution.y)];
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[-(i - solution.x), j - solution.y];
                    }
                    break;
            }
        }

        /// <summary>
        /// This function is fairly important.
        /// The rating is calculated according to number of rooms that share a border with
        /// this newly placed room. So we can be sure that there will be as few empty
        /// spaces between rooms as possible.
        /// 
        /// For instance, if there are 2 options for a room position: one in which a room is
        /// sharing one border with another room (so 3 other sides are naked), and the other one
        /// in which a room is placed in a way that it shares 3 sides with other rooms (and only
        /// one side is naked) -> the rating of the second solutions will obviously be higher.
        /// This is how we ensure that the final solution will be as compact as possible.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="room"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="roomPosition"></param>
        /// <returns></returns>
        private int GetRoomPlacementRating(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            int rating = 0;

            List<int> cellsToCheck = new List<int>();



            if (roomPosition == RoomPosition.BottomLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + 1]);

                    if (x - i >= 0 && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y - j >= 0)
                        cellsToCheck.Add(grid[x + 1, y - j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.BottomRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + 1]);

                    if (x + i < grid.GetLength(0) && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - 1, y - j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y - j > 0)
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.TopLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - 1]);

                    if (x - i >= 0 && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + 1, y + j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y + j]);
                }
            }

            if (roomPosition == RoomPosition.TopRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - 1]);

                    if (x + i < grid.GetLength(0) && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - 1, y + j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y + j]);
                }
            }

            foreach (int a in cellsToCheck)
                if (a != 0 && a != 9999)
                    rating++;

            return rating;
        }

        /// <summary>
        /// This one is simple, it contains the room placement solution as well as 
        /// rating of the room.
        /// </summary>
        private class RoomPlacementSolution
        {
            public RoomPlacementSolution(int roomX, int roomY, RoomPosition position, int[,] mRoom, int mScore)
            {
                x = roomX;
                y = roomY;
                roomPosition = position;
                this.rating = mScore;
                this.room = mRoom.Clone() as int[,];
            }

            public RoomPlacementSolution(RoomPlacementSolution a)
            {
                x = a.x;
                y = a.y;
                roomPosition = a.roomPosition;
                this.rating = a.rating;
                this.room = a.room.Clone() as int[,];
            }

            public int GetRoomNum()
            {
                int max = -1;
                for (int i = 0; i < room.GetLength(0); i++)
                    for (int j = 0; j < room.GetLength(1); j++)
                        max = Math.Max(max, room[i, j]);
                return max;
            }

            public RoomPosition roomPosition;
            public int rating = 0;
            public int x;
            public int y;
            public int[,] room;
        }

        private enum RoomPosition { TopRight, BottomRight, BottomLeft, TopLeft, Undefined }

        /// <summary>
        /// This function checks that the given room with the given RoomPosition
        /// can be successfully placed on the grid. So if all cells that this room
        /// will want to occupy are free (0), it will return true.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="room"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="roomPosition"></param>
        /// <returns></returns>
        private bool RoomIsPlaceableHere(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            switch (roomPosition)
            {
                case RoomPosition.TopRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (x - room.GetLength(0) >= 0 && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (x - room.GetLength(0) >= 0 && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

            }
            return false;
        }


        /// <summary>
        /// IntPair generally is used for saving {(room number in the initialRoomsList) + 1, room priority}
        /// </summary>
        public struct IntPair
        {
            public IntPair(int a1, int b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }

            public IntPair(int a1, double b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }
            public int roomNumber;
            public double AdjNum;
        }


        public bool CellsAreNearerThan(int x, int y, List<int> targetCellsList, int[,] grid, double maxDistance = 2)
        {
            foreach (int targetCell in targetCellsList)
            {
                if (!CellIsNearerThan(x, y, targetCell, grid, maxDistance))
                    return false;
            }
            return true;
        }

        public bool CellIsNearerThan(int x, int y, int targetCellNumber, int[,] grid, double maxDistance = 2)
        {
            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;
                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;
            availabilityGrid[x, y] = true;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);


            int minX = -1;
            int minY = -1;
            double minTargetDist = -1;

            for (int i = 0; i < availabilityGrid.GetLength(0); i++)
                for (int j = 0; j < availabilityGrid.GetLength(1); j++)
                {
                    if (grid[i, j] == targetCellNumber)
                        if ((distanceGrid[i, j] < minTargetDist || minTargetDist == -1) && distanceGrid[i, j] > 0)
                        {
                            minTargetDist = distanceGrid[i, j];
                            minX = i;
                            minY = j;
                        }
                }

            if (minTargetDist != -1 && minTargetDist <= maxDistance)
                return true;
            else
                return false;
        }

        public void SetCellDistancesAround(int x, int y, ref double[,] distanceGrid, ref bool[,] availabilityGrid, double maxDist)
        {
            List<List<int>> recursionList = new List<List<int>>();


            for (int i = -1; i <= 1; i++)
                for (int j = -1; j <= 1; j++)
                {
                    if (x + i >= 0 && x + i < distanceGrid.GetLength(0) &&
                        y + j >= 0 && y + j < distanceGrid.GetLength(1))
                        if (!(i == 0 && j == 0))
                        {
                            double addValue;
                            if (i * j != 0) //if the cell is corner cell
                                addValue = 1.414f; //sqrt(2)
                            else
                                addValue = 1;

                            if (availabilityGrid[x, y])
                                if (distanceGrid[x + i, y + j] > distanceGrid[x, y] + addValue || distanceGrid[x + i, y + j] == -1)
                                {
                                    distanceGrid[x + i, y + j] = distanceGrid[x, y] + addValue;
                                    if (distanceGrid[x + i, y + j] <= maxDist)
                                        recursionList.Add(new List<int>() { x + i, y + j });
                                }
                        }
                }
            // doesnt really affect performance
            foreach (List<int> item in recursionList)
                SetCellDistancesAround(item[0], item[1], ref distanceGrid, ref availabilityGrid, maxDist);

            return;
        }
        
        public bool GridContains(int[,] grid, int val)
        {
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                    if (grid[i, j] == val)
                        return true;
            return false;
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        
        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                return Properties.Resources.MagnetizingRoomsIcon;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{78fe6801-611b-453f-946a-2fda951393eb}"); }
        }


        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "One-side corridors", Menu_OneSideCorClick, true, oneSideCorridorsChecked);
            Menu_AppendItem(menu, "Two-sides corridors", Menu_TwoSidesCorClick, true, twoSidesCorridorsChecked);
            Menu_AppendItem(menu, "All-sides corridors", Menu_AllSidesCorClick, true, allSidesCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Remove Dead Ends", Menu_RemoveDeadEndsClick, true, removeDeadEndsChecked);
            Menu_AppendItem(menu, "Remove All Corridors", Menu_RemoveAllCorridorsClick, true, removeAllCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Corridors as additional spaces", Menu_CorridorsAsAdditionalSpacesChecked, true, corridorsAsAdditionalSpacesChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Boundary offset:", (obj, e) => { }, false);
            Menu_AppendTextItem(menu, boundaryOffset.ToString()
               , (obj, e) => { }, Menu_ChangeBoundaryOffsetNumberChanged, false);

            base.AppendAdditionalComponentMenuItems(menu);
        }


        public void Menu_ChangeBoundaryOffsetNumberChanged(object sender, string text)
        {
            try
            {
                this.boundaryOffset = Double.Parse(text);
            }
            catch (Exception) { }

            //this.ExpireSolution(false);
        }

        public void Menu_ChangeBoundaryOffsetNumberPressed(object sender, EventArgs e)
        {
            this.ExpireSolution(false);
        }

        public void Menu_CorridorsAsAdditionalSpacesChecked(object sender, EventArgs e)
        {
            corridorsAsAdditionalSpacesChecked = !corridorsAsAdditionalSpacesChecked;
            this.ExpireSolution(false);
        }

       

        public void Menu_RemoveDeadEndsClick(object sender, EventArgs e)
        {
            removeDeadEndsChecked = !removeDeadEndsChecked;

            if (removeDeadEndsChecked)
                removeAllCorridorsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(false);
        }

        public void Menu_RemoveAllCorridorsClick(object sender, EventArgs e)
        {
            removeAllCorridorsChecked = !removeAllCorridorsChecked;
            if (removeAllCorridorsChecked)
                removeDeadEndsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(false);
        }

        public void Menu_OneSideCorClick(object sender, EventArgs e)
        {
            if (!oneSideCorridorsChecked)
            {
                oneSideCorridorsChecked = !oneSideCorridorsChecked;

                twoSidesCorridorsChecked = !oneSideCorridorsChecked;
                allSidesCorridorsChecked = !oneSideCorridorsChecked;

                ExpireSolution(false);
            }
        }

        public void Menu_TwoSidesCorClick(object sender, EventArgs e)
        {
            if (!twoSidesCorridorsChecked)
            {
                twoSidesCorridorsChecked = !twoSidesCorridorsChecked;

                oneSideCorridorsChecked = !twoSidesCorridorsChecked;
                allSidesCorridorsChecked = !twoSidesCorridorsChecked;

                ExpireSolution(false);
            }
        }

        public void Menu_AllSidesCorClick(object sender, EventArgs e)
        {
            if (!allSidesCorridorsChecked)
            {
                allSidesCorridorsChecked = !allSidesCorridorsChecked;

                oneSideCorridorsChecked = !allSidesCorridorsChecked;
                twoSidesCorridorsChecked = !allSidesCorridorsChecked;

                ExpireSolution(false);
            }
        }
    }
}

&&& FILE: ./Magnetizing_FPG/SpringSystem_ES.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System.Linq;
using Rhino;
using ClipperLib;

using Path = System.Collections.Generic.List<ClipperLib.IntPoint>;
using Paths = System.Collections.Generic.List<System.Collections.Generic.List<ClipperLib.IntPoint>>;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;

namespace Magnetizing_FPG
{
    public class SpringSystem_ES : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public SpringSystem_ES()
          : base("SpringSystem_ES", "SpringSystem_ES",
              "Evolutionary Strategy + SpringSystem",
              "Magnetizing_FPG", "Magnetizing_FPG")
        {
        }

        private List<Curve> rooms = new List<Curve>();
        private List<Curve> originalInputRooms = new List<Curve>();
        private List<Curve> currentInputRooms = new List<Curve>();
        List<string> adjStrList;
        private Random random = new Random();
        double proportionThreshold = 0;
        GeneCollection geneCollection;
        double boundaryArea = 0;
        bool Menu_ShuffleRoomsAtFirst = false;


        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms as curves", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacencies", "Adjacencies", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, " - ");
            pManager.AddNumberParameter("ProportionThreshold", "ProportionThreshold", "ProportionThreshold, >= 1", GH_ParamAccess.item, 2);
            pManager.AddNumberParameter("FF Balance", "FF Balance", "FF Balance\n[0,1]", GH_ParamAccess.item, 0);
            pManager.AddBooleanParameter("SpringCollAllGenes", "SpringCollAllGenes", "Spring collisions in all genes, not only in the best one. " +
                "It makes execution slower, but provides much better results, because every gene is getting better faster and they compete" +
                "with each other more honestly", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("AdjustArea", "AdjustArea", "Adjust sum of rooms areas to the area of the boundary.", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Reset", "Reset", "Reset", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddLineParameter("Adjacencies", "Adjacences", "Adjacence lines", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            Curve boundary = new PolylineCurve();
            bool shouldInstantiateRooms = false;
            adjStrList = new List<string>();
            List<Line> adjLines = new List<Line>();
            bool shouldClearGenes = false;
            bool springCollAllGenes = false;
            bool adjustArea = false;
            
            DA.GetData("Reset", ref shouldInstantiateRooms);
            DA.GetData("Boundary", ref boundary);

            currentInputRooms.Clear();
            DA.GetDataList(1, currentInputRooms);

            if (shouldInstantiateRooms || rooms.Count == 0 || boundaryArea != AreaMassProperties.Compute(boundary).Area
                || originalInputRooms == null || !RoomListsAreEqual(originalInputRooms, currentInputRooms))
            {
                shouldClearGenes = true;
                boundaryArea = AreaMassProperties.Compute(boundary).Area;
                rooms.Clear();
                originalInputRooms.Clear();
                DA.GetDataList(1, rooms);
                DA.GetDataList(1, originalInputRooms);
            }

            DA.GetData("ProportionThreshold", ref proportionThreshold);
            DA.GetData("FF Balance", ref Gene.fitnessFunctionBalance);
            DA.GetDataList("Adjacencies", adjStrList);
            DA.GetData("SpringCollAllGenes", ref springCollAllGenes);
            DA.GetData("AdjustArea", ref adjustArea);
            
            int[,] adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            Gene.proportionThreshold = proportionThreshold;
            Gene.adjacencyList = adjArray;

            if (shouldClearGenes)
            {
                // Adapt the summarized rooms area to the boundary area if it is needed
                if (adjustArea)
                {
                    double roomSumArea = 0;
                    foreach (Curve room in rooms)
                        roomSumArea += AreaMassProperties.Compute(room).Area;

                    foreach (Curve room in rooms)
                        room.Transform(Transform.Scale(room.GetBoundingBox(false).Center, Math.Sqrt(boundaryArea / roomSumArea)));// AreaMassProperties.Compute(room).Area;

                }

                shouldClearGenes = false;
                geneCollection = new GeneCollection(15, boundary);

                // Let's create some starting genes
                foreach (Gene gene in geneCollection.genes)
                    if (Menu_ShuffleRoomsAtFirst)
                        gene.InstantiateRandomly(rooms);
                    else
                        gene.Instantiate(rooms);
            }

            
            geneCollection.Iterate();

            if (springCollAllGenes)
                for (int l = 0; l < geneCollection.genes.Count; l++)
                {
                    Gene gene = geneCollection.genes[l];
                    rooms = gene.GetCurves();

                    rooms = CollisionDetectionMain(rooms, boundary);

                    gene.collection.Clear();
                    gene.Instantiate(rooms);
                }


            rooms = geneCollection.GetBest();
            AdjacentContraction(rooms, adjStrList, boundary, out adjLines);

            List<GH_Curve> GH_rooms = new List<GH_Curve>();
            foreach (Curve c in rooms)
                GH_rooms.Add(new GH_Curve(c));

            DA.SetDataList(0, GH_rooms);
            DA.SetDataList(1, adjLines);
        }

        protected bool RoomListsAreEqual(List<Curve> a, List<Curve> b)
        {
            if (a == null || b == null)
                return false;
            if (a.Count != b.Count)
                return false;
            for (int i = 0; i < a.Count; i++)
            {
                Vector3d differenceV = a[i].GetBoundingBox(false).Center - b[i].GetBoundingBox(false).Center;
                if (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y) > 0.001f)
                {
                    //AddRuntimeMessage(GH_RuntimeMessageLevel.Error, (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y).ToString()));
                    return false;
                }
            }

            return true;
        }

        protected List<Curve> CopyCurveList(List<Curve> a)
        {
            List<Curve> output = new List<Curve>();
            foreach (Curve curve in a)
                output.Add(curve.DuplicateCurve());

            return output;
        }

        private List<Curve> CollisionDetectionMain(List<Curve> roomCurves, Curve boundary)
        {
            List<int> indexes = new List<int>();
            for (int i = 0; i < roomCurves.Count; i++)
                indexes.Add(i);


            // Check roomCurves[i] and roomCurves[j] intersection
            // Then let's move both rooms by 1/2 of the rebounding vector
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];

                for (int j = i + 1; j < roomCurves.Count; j++)

                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], roomCurves[j]);

                    if (intersectResult.intersect)
                    {
                        if (intersectResult.reboundingVector.X != 0)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[j].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));
                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(intersectResult.reboundingVector.X / 2, 0, 0));
                                roomCurves[j].Translate(new Vector3d(-intersectResult.reboundingVector.X / 2, 0, 0));

                            }
                        }
                        else
                        {
                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2]
                            // Else - change the position of the rooms
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(0, intersectResult.reboundingVector.Y / 2, 0));
                                roomCurves[j].Translate(new Vector3d(0, -intersectResult.reboundingVector.Y / 2, 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], roomCurves[j], Plane.WorldXY, 0.0001f) != RegionContainment.Disjoint)
                        {
                            BoundingBox aRoomBB = roomCurves[j].GetBoundingBox(false);
                            BoundingBox bRoomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).X) - (aRoomBB.Diagonal.X / 2 - bRoomBB.Diagonal.X / 2);
                            double yDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).Y) - (aRoomBB.Diagonal.Y / 2 - bRoomBB.Diagonal.Y / 2);
                            if (xDist > yDist)
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist - bRoomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist + bRoomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist - bRoomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist + bRoomBB.Diagonal.Y, 0));
                            }
                        }
                    }

                }
            }


            // Check roomCurves[i] and boundary intersection
            // Let's do it twice to be sure that X and Y positions are both defined perfectly
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];
                for (int t = 0; t < 1; t++)
                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], boundary);

                    if (intersectResult.intersect)
                    {
                        double boundaryProportionThreshold = 1;// proportionThreshold;

                        if (Math.Abs(intersectResult.reboundingVector.X) > 0.01f)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d((intersectResult.reboundingVector.X > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.X - Math.Abs(intersectResult.reboundingVector.X)), 0, 0));
                            }
                        }
                        else if (Math.Abs(intersectResult.reboundingVector.Y) > 0.01f)
                        { // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d(0, (intersectResult.reboundingVector.Y > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.Y - Math.Abs(intersectResult.reboundingVector.Y)), 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], boundary, Plane.WorldXY, 0.0001f) != RegionContainment.AInsideB)
                        {
                            BoundingBox boundaryBB = boundary.GetBoundingBox(false);
                            BoundingBox roomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((boundaryBB.Center - roomBB.Center).X) - boundaryBB.Diagonal.X / 2 - roomBB.Diagonal.X / 2;
                            double yDist = Math.Abs((boundaryBB.Center - roomBB.Center).Y) - boundaryBB.Diagonal.Y / 2 - roomBB.Diagonal.Y / 2;
                            if (xDist > yDist)
                            {
                                if ((boundaryBB.Center - roomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist + roomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist - roomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((boundaryBB.Center - roomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist + roomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist - roomBB.Diagonal.Y, 0));
                            }
                        }
                    }
                }
            }
            return roomCurves;
        }

        public PolylineCurve PathToPolyline(Path path, int clipperPrecision = 100)
        {
            List<Point3d> points = new List<Point3d>();
            foreach (IntPoint intPoint in path)
                points.Add(new Point3d(intPoint.X / (double)clipperPrecision, intPoint.Y / (double)clipperPrecision, 0));
            PolylineCurve polyline = new PolylineCurve(points);

            return polyline;
        }

        public Path CurveToPath(Curve curve, int clipperPrecision = 100)
        {
            Path points = new Path();

            for (int i = 0; i < 4; i++)
                points.Add(new IntPoint((int)(curve.GetBoundingBox(false).GetCorners()[i].X * clipperPrecision),
                    (int)(curve.GetBoundingBox(false).GetCorners()[i].Y * clipperPrecision)));

            return points;
        }

        private IntersectResult Intersect2Curves(Curve a, Curve b)
        {
            int clipperPrecision = 100;
            IntersectResult result = new IntersectResult();
            if (Curve.PlanarCurveCollision(a, b, Plane.WorldXY, 0.001f))
            {
                Clipper clipper = new Clipper();
                Path subjectA = CurveToPath(a, clipperPrecision);
                Path subjectB = CurveToPath(b, clipperPrecision);
                Paths solution = new Paths();

                clipper.AddPath(subjectA, PolyType.ptClip, true);
                clipper.AddPath(subjectB, PolyType.ptSubject, true);

                clipper.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                if (solution.Count > 0)
                {
                    result.intersect = true;
                    PolylineCurve pl = PathToPolyline(solution[0], clipperPrecision);
                    result.unionCurve = pl;

                    Point3d minPoint = pl.GetBoundingBox(false).Min;
                    Point3d maxPoint = pl.GetBoundingBox(false).Max;

                    if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                    {
                        result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                        if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                            result.reboundingVector.Y *= -1;
                    }
                    else
                    {
                        result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                        if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                            result.reboundingVector.X *= -1;
                    }

                }
            }
            else
            {
                result.intersect = false;
                result.reboundingVector = Vector2d.Unset;
                result.unionCurve = null;
            }
            return result;
        }

        private struct IntersectResult
        {
            public Vector2d reboundingVector;
            public bool intersect;
            public Curve unionCurve;
        }

        private double GetRoomXYProportion(Curve room)
        {
            return (room.GetBoundingBox(false).Diagonal.X / (double)room.GetBoundingBox(false).Diagonal.Y);
        }


        private void Shuffle(ref List<Curve> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                Curve value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<string> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private List<Curve> AdjacentContraction(List<Curve> roomCurves, List<string> adjacenceStrings, Curve boundary, out List<Line> adjLines)
        {

            List<Adjacence> adjacences = new List<Adjacence>();

            foreach (string adjString in adjacenceStrings)
            {
                adjacences.Add(new Adjacence());
                adjacences[adjacences.Count - 1].aIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjacences[adjacences.Count - 1].bIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            foreach (Adjacence adj in adjacences)
            {
                Vector3d attractVector = roomCurves[adj.aIndex].GetBoundingBox(false).Center - roomCurves[adj.bIndex].GetBoundingBox(false).Center;

                Vector3d aDim = roomCurves[adj.aIndex].GetBoundingBox(false).Diagonal;
                Vector3d bDim = roomCurves[adj.bIndex].GetBoundingBox(false).Diagonal;

                if (Math.Abs(attractVector.X) - (aDim.X + bDim.X) / 2 > 0.001f ||
                    Math.Abs(attractVector.Y) - (aDim.Y + bDim.Y) / 2 > 0.001f)
                {

                    if (Math.Abs(attractVector.X) > Math.Abs(attractVector.Y))
                    {
                        attractVector.Y = 0;
                        aDim.Y = 0;
                        bDim.Y = 0;
                    }
                    else
                    {
                        attractVector.X = 0;
                        aDim.X = 0;
                        bDim.X = 0;
                    }

                    Point3d attractCenter = roomCurves[adj.aIndex].GetBoundingBox(false).Center + attractVector / 2;
                    if (attractVector.X != 0)
                        if (attractCenter.X > roomCurves[adj.aIndex].GetBoundingBox(false).Center.X)
                            bDim *= -1;
                        else
                            aDim *= -1;
                    else
                        if (attractCenter.Y > roomCurves[adj.aIndex].GetBoundingBox(false).Center.Y)
                        bDim *= -1;
                    else
                        aDim *= -1;


                    // roomCurves[adj.aIndex].Translate(-attractVector / 2 + aDim / 2);
                    // roomCurves[adj.bIndex].Translate(attractVector / 2 + bDim / 2);
                }
            }

            adjLines = new List<Line>();

            foreach (Adjacence adj in adjacences)
            {
                adjLines.Add(new Line(roomCurves[adj.aIndex].GetBoundingBox(false).Center, roomCurves[adj.bIndex].GetBoundingBox(false).Center));
            }

            return roomCurves;
        }

        private class Adjacence
        {
            public int aIndex;
            public int bIndex;
        }

        public class Room
        {
            public double CenterX = 0;
            public double CenterY = 0;

            public double width = 0;
            // height is used as a getter/setter function, so this variable doesn't exist actually

            public double area = 0;

            public Room(double CenterX, double CenterY, double width, double height)
            {
                this.CenterX = CenterX;
                this.CenterY = CenterY;
                this.width = width;
                this.area = width * height;
            }

            public Room()
            {
            }

            public Room(Point3d centerPoint, double width, double height)
            {
                this.CenterX = centerPoint.X;
                this.CenterY = centerPoint.Y;
                this.width = width;
                this.area = width * height;
            }

            public Room(Curve roomCurve)
            {
                this.CenterX = roomCurve.GetBoundingBox(false).Center.X;
                this.CenterY = roomCurve.GetBoundingBox(false).Center.Y;
                this.width = roomCurve.GetBoundingBox(false).Diagonal.X;
                this.area = roomCurve.GetBoundingBox(false).Diagonal.X * roomCurve.GetBoundingBox(false).Diagonal.Y;
            }

            // IMPORTANT: think about what precision means
            public Path GetClipperLibPath(int precision = 100)
            {

                IntPoint a = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY - height / 2) * precision));
                IntPoint b = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint c = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint d = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY - height / 2) * precision));

                Path output = new Path(new List<IntPoint>() { a, b, c, d });
                return output;
            }

            public Room Clone()
            {
                Room r = new Room(CenterX, CenterY, width, this.height);
                return r;
            }

            public double height
            {
                get
                {
                    return area / width;
                }
                set
                {
                    width = area / value;
                }
            }

        }

        public class Gene
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Room> collection = new List<Room>();
            public static int[,] adjacencyList;// = new int[0, 2];
            public static Curve boundary;
            public static double proportionThreshold = 2f;
            public static double fitnessFunctionBalance = 0.5f;


            public Gene(int[,] adjacences)
            {
                adjacencyList = adjacences;
            }

            public Gene()
            {
            }

            public double FitnessFunctionG()
            {
                // return 3;
                double fitnessFunctionVar = 0;
                int precision = 100;

                Clipper cc = new ClipperLib.Clipper();

                Paths solution = new Paths();
                Paths subjects = new Paths();
                Paths clips = new Paths();



                foreach (Room room in collection)
                    subjects.Add(new Path(room.GetClipperLibPath(precision)));

                IntPoint boundaryA = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryB = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryC = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryD = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));


                clips.Add(new Path(new List<IntPoint>() { boundaryA, boundaryB, boundaryC, boundaryD }));

                cc.AddPaths(subjects, PolyType.ptSubject, true);
                cc.AddPaths(clips, PolyType.ptClip, true);


                cc.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                foreach (Path path in solution)
                {
                    fitnessFunctionVar += Clipper.Area(path);
                }


                return fitnessFunctionVar;
            }

            public double FitnessFunctionT()
            {
                double distanceSum = 0;
                for (int i = 0; i < adjacencyList.GetLength(0); i++)
                {
                    Room a = collection[adjacencyList[i, 0]].Clone();
                    Room b = collection[adjacencyList[i, 1]].Clone();

                    double distX = Math.Abs(a.CenterX - b.CenterX) - a.width / 2f - b.width / 2f;
                    double distY = Math.Abs(a.CenterY - b.CenterY) - a.height / 2f - b.height / 2f;

                    distanceSum += Math.Max(Math.Abs(distX), Math.Abs(distY));
                }
                return distanceSum;
            }

            public double FitnessFunction()
            {
                return (FitnessFunctionG() * fitnessFunctionBalance + 1 / (FitnessFunctionT()) * (1 - fitnessFunctionBalance));
            }

            public Gene Clone()
            {
                List<Room> newColl = new List<Room>(collection);
                Gene t = new Gene();
                // t.collection = newColl;
                foreach (Room r in collection)
                    t.collection.Add(r.Clone());

                return t;
            }

            public void InstantiateRandomly(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));

                    // set width
                    collection[collection.Count - 1].width = Math.Sqrt(collection[collection.Count - 1].area
                        / proportionThreshold) + random.NextDouble()
                        * (Math.Sqrt(collection[collection.Count - 1].area * proportionThreshold)
                        - Math.Sqrt(collection[collection.Count - 1].area / proportionThreshold));

                    // set X and Y
                    collection[collection.Count - 1].CenterX = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.X - collection[collection.Count - 1].width)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).X
                     + collection[collection.Count - 1].width / 2;

                    collection[collection.Count - 1].CenterY = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.Y - collection[collection.Count - 1].height)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).Y
                        + collection[collection.Count - 1].height / 2;
                }
            }

            public Gene Instantiate(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));
                }
                return this;
            }

            public List<Curve> GetCurves()
            {
                List<Curve> curvesList = new List<Curve>();
                foreach (Room room in collection)
                {
                    curvesList.Add(new Rectangle3d(new Plane(new Point3d(room.CenterX - room.width / 2, room.CenterY - room.height / 2, 0), Vector3d.ZAxis), room.width, room.height).ToNurbsCurve());
                }
                return curvesList;
            }

            public void MutateSomehow()
            {
                double mutationProb = 0.3f;
                double mutationChangeK = 0.2f; // (boundary.width or .height or ... ) * mutationChangeK = max change
                foreach (Room room in collection)
                {
                    if (random.NextDouble() < mutationProb)
                    {
                        if (random.NextDouble() < mutationProb)
                            room.CenterX += boundary.GetBoundingBox(false).Diagonal.X * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.CenterY += boundary.GetBoundingBox(false).Diagonal.Y * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.width = Math.Sqrt(room.area / proportionThreshold) + random.NextDouble()
                                * (Math.Sqrt(room.area * proportionThreshold) - Math.Sqrt(room.area / proportionThreshold));

                        // Check whether the room is outside the boundary

                        if (room.CenterX - room.width / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(true, true, true).X + room.width / 2;

                        if (room.CenterX + room.width / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(false, false, false).X - room.width / 2;

                        if (room.CenterY - room.height / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(true, true, true).Y + room.height / 2;

                        if (room.CenterY + room.height / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(false, false, false).Y - room.height / 2;
                    }
                }
            }

        }

        /// <summary>
        /// This class serves for containing the collection of genes and doing
        /// some operations with them (sorting, iterating,..).
        /// </summary>
        public class GeneCollection
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Gene> genes;
            int genesNumber;

            public GeneCollection(int genesNumber, Curve boundary)
            {
                Gene.boundary = boundary;
                this.genesNumber = genesNumber;
                genes = new List<Gene>();
                for (int i = 0; i < genesNumber; i++)
                    genes.Add(new Gene());
            }

            public void SortGenes()
            {
                genes = genes.OrderBy(i => -i.FitnessFunction()).ToList();

            }

            /// <summary>
            /// Well, so this function produces new genes via mutations, cross-over and 
            /// generating new ones.
            /// </summary>
            public void Iterate()
            {
                double newGenesNumK = 4;
                // mutations + cross-over + newbies

                #region CROSS-OVER
                int[,] mutationIndexes = new int[(int)(genesNumber * newGenesNumK), 2];
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    mutationIndexes[i, 0] = random.Next(genesNumber);
                    mutationIndexes[i, 1] = random.Next(genesNumber);
                }

                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    genes.Add(CrossOverGenes(genes[mutationIndexes[i, 0]], genes[mutationIndexes[i, 1]]));
                }

                #endregion

                #region MUTATION
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    Gene mutGene = genes[random.Next(0, genes.Count)].Clone();

                    mutGene.MutateSomehow();
                    genes.Add(mutGene);
                }
                #endregion

                #region NEWBIES
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    Gene newGene = new Gene();
                    newGene.InstantiateRandomly(genes[0].GetCurves());
                    genes.Add(newGene);
                }
                #endregion

                SortGenes();
                genes.RemoveRange(genesNumber, genes.Count - 1 - genesNumber);

            }

            private Gene CrossOverGenes(Gene a, Gene b)
            {
                double mutationProb = 0.5f;
                Gene c = a.Clone();

                for (int i = 0; i < a.collection.Count; i++)
                    if (random.NextDouble() > mutationProb)
                        c.collection[i] = b.collection[i].Clone();

                return c;
            }

            public List<Curve> GetBest()
            {
                SortGenes();
                return genes[0].GetCurves();
            }
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                return Resources.SpringSystem_ESIcon;
            }
        }

        /// <summary>
        /// When Menu_ShuffleRoomsAtFirstChecked, in the very beginning of algorithm's work
        /// all the rooms will be shuffled randomly.  It serves for producing various results.
        /// But when SpringSystem_ES component takes results from MagnetizingRooms_ES, rooms 
        /// already have their approximate position and, therefore, must not be shuffled.
        /// (initially Menu_ShuffleRoomsAtFirstChecked = false)
        /// </summary>
        /// <param name="menu"></param>
        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {

            Menu_AppendItem(menu, "Shuffle rooms at first", Menu_ShuffleRoomsAtFirstChecked, true, Menu_ShuffleRoomsAtFirst);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        public void Menu_ShuffleRoomsAtFirstChecked(object sender, EventArgs e)
        {
            Menu_ShuffleRoomsAtFirst = !Menu_ShuffleRoomsAtFirst;
            this.ExpireSolution(true);
        }

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{7b02cbd7-910f-47cf-9601-348f8a214506}"); }
        }
    }
}


&&& FILE: ./Magnetizing_FPG/RoomProgram\HouseInstance.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    /* HouseInstance class contains all the information about one
     * instance of a set of rooms that belong to one house/storey.
     */

    public class HouseInstance : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the HouseInstance class.
        /// </summary>
        public HouseInstance()
          : base("HouseInstance", "HouseInstance",
              "HouseInstance",
             "Magnetizing_FPG", "Magnetizing_FPG")
        {
            adjStrList = new List<string>();
            m_attributes = new HouseInstanceAttributes(this);

        }

        public string HouseName = "HouseName";
        public string FloorName = "HouseFloor";
        public Curve boundary;
        public int[,] adjArray;
        public Point3d startingPoint;
        public List<string> adjStrList = new List<string>();
        public bool tryRotateBoundary = false;

        public List<string> RoomInstancesGuids
        {
            get { return (m_attributes as HouseInstanceAttributes).roomInstancesGuidList; }
            //  set { }
        }
        public List<RoomInstance> RoomInstances
        {
            get {
                List<RoomInstance> list = new List<RoomInstance>();
                foreach (string guid in (m_attributes as HouseInstanceAttributes).roomInstancesGuidList)
                    if (guid != "")
                    list.Add(OnPingDocument().FindComponent(new Guid(guid)) as RoomInstance);
                return list;
            }
            //  set { }
        }

        public override void CreateAttributes()
        {
            m_attributes = new HouseInstanceAttributes(this);
        }
        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "B", "Boundary", GH_ParamAccess.item);
            pManager.AddPointParameter("Entrance Point", "EP", "Entrance Point", GH_ParamAccess.item);
        }


        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("HouseInstance", "HI", "HouseInstance", GH_ParamAccess.item);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            adjStrList = new List<string>();
            List<string> roomNames = new List<string>();

            (m_attributes as HouseInstanceAttributes).AddPrevioslyConnectedRooms();

            DA.GetData(0, ref boundary);
            try
            {
                DA.GetData(1, ref startingPoint);
            }
            catch (Exception) { }


            for (int i = 0; i < RoomInstances.Count; i++)
            {
                for (int j = 0; j < RoomInstances[i].AdjacentRoomsList.Count; j++)
                    if (i + 1 < (RoomInstances.FindIndex(item => item.RoomId == (RoomInstances[i].AdjacentRoomsList[j] as RoomInstance).RoomId) + 1))
                        adjStrList.Add((i + 1) + " - " + (RoomInstances.FindIndex(item => item.RoomId == (RoomInstances[i].AdjacentRoomsList[j] as RoomInstance).RoomId) + 1) + "\n");


                roomNames.Add(RoomInstances[i].RoomName);
            }

            adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            DA.SetData(0, this);
        }


        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return Resources.HouseInstanceIcon;
            }
        }

        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            /// If checked, boundary will be rotated in such a way that it is 
            /// easier to pack rectangular rooms inside it. After algorithm is 
            /// executed, the boundary is rotated back to initial state.
            Menu_AppendItem(menu, "Try Rotate Boundary", Menu_TryRotateBoundaryClick, true, tryRotateBoundary);

            base.AppendAdditionalComponentMenuItems(menu);
        }
        protected void Menu_TryRotateBoundaryClick(object sender, EventArgs e)
        {
            tryRotateBoundary = !tryRotateBoundary;
            this.ExpireSolution(false);
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{9fb8241c-27d0-4683-9964-26c181c9ce36}"); }
        }
    }
}

&&& FILE: ./Magnetizing_FPG/RoomProgram\HouseInstanceAttributes.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Reflection;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class HouseInstanceAttributes : GH_ComponentAttributes, IRoomStructure<IGH_DocumentObject>
    {

        public HouseInstanceAttributes(HouseInstance param) : base(param)
        {            
            random = new Random(Guid.NewGuid().GetHashCode());
            houseBrush = PickBrush();
            roomInstancesGuidList = new List<string>();
            strArray = new string[] { };

        }

        private Brush PickBrush()
        {
            List<Brush> brushes = new List<Brush>
            {
                Brushes.Aqua,
                Brushes.Bisque,
                Brushes.BlanchedAlmond,
                Brushes.DarkViolet,
                Brushes.LemonChiffon,
                Brushes.LightBlue,
                Brushes.LightCyan,
                Brushes.LightGreen,
                Brushes.LightSkyBlue,
                Brushes.Olive,
                Brushes.Orange,
                Brushes.PaleGreen,
                Brushes.Peru,
                Brushes.PeachPuff,
                Brushes.Purple,
                Brushes.Salmon,
                Brushes.SlateBlue,
                Brushes.Yellow,
                Brushes.YellowGreen
            };


            return brushes[random.Next(brushes.Count)];
        }

        public GH_Capsule FloorName;//= GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, p);
        public GH_Capsule HouseName;//= GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, "RoomName");

        Rectangle FloorNameRectangle;
        Rectangle HouseNameRectangle;

        const int InflateAmount = 2; // Used to inflate all rectangles for producing outer rectangles for GH_TextCapsules
        const int InnerComponentRadius = 50; // Used to define the radius of the main circle
        const int OuterComponentRadius = 60; // Used to define the radius of the main circle

        public static Random random = new Random();
        public Brush houseBrush;


        //public List<RoomInstance> roomInstancesList = new List<RoomInstance>(); // List that contains all room instances that are to be in that house

        public List<string> roomInstancesGuidList = new List<string>();


        protected override void Layout()
        {

            base.Layout();

            Pivot = GH_Convert.ToPoint(Pivot);
            Rectangle rec0 = GH_Convert.ToRectangle(Bounds);
            //rec0.Height += 50;
            Bounds = rec0;

            /*
                        HouseNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X - 50 + 25, (int)Bounds.Location.Y + 50), new Size(80, 20));
                        FloorNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X - 50 + 50, (int)Bounds.Location.Y + 75), new Size(60, 20));
                        */

            //   Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);
        }


        protected RectangleF InnerComponentBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        protected RectangleF OuterComponentBounds
        {
            get
            {
                RectangleF outer = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                outer.Inflate(inflation, inflation);
                return outer;
            }
        }

        protected Rectangle InflateRect(Rectangle rect, int a = 5, int b = 5)
        {
            Rectangle rectOut = rect;
            rectOut.Inflate(-a, -b);
            return rectOut;
        }

        public void AddPrevioslyConnectedRooms()
        {
            if (strArray == null)
                return;
            if (strArray.Length > 0 && roomInstancesGuidList.Count == 0)
            {
                foreach (string guidS in strArray)
                    if (guidS != "")
                        if (Owner.OnPingDocument().FindComponent(new Guid(guidS)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(guidS)));

            }
            UpdateRoomInstancesColors();
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {

            //Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);
            //  Bounds = InnerComponentBounds;
            //         base.Render(canvas, graphics, channel);

            if (Owner is HouseInstance houseInstance)
                if (channel == GH_CanvasChannel.Objects)
                {
                    graphics.FillRectangle(houseBrush, OuterComponentBounds);
                    base.Render(canvas, graphics, channel);

                    //       Bounds = InnerComponentBounds;
                    //    GH_Capsule.CreateCapsule(Bounds, GH_Palette.Grey).Render(graphics, Color.Gray);

                    //       Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - 2 * OuterComponentRadius, 2 * OuterComponentRadius, OuterComponentRadius);
                    //     Layout();
                    //   GH_ComponentAttributes.RenderComponentParameters(canvas, graphics, Owner, new GH_PaletteStyle(Color.Brown));

                    //  Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);


                    //    foreach (IGH_DocumentObject obj in roomInstancesList)
                    //        DrawTargetArrow(graphics, obj.Attributes.Bounds);


                    //    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerComponentBounds, GH_Palette.Normal, InnerComponentRadius, 0);
                    //    capsule.Render(graphics, Selected, Owner.Locked, true);
                    //    capsule.Dispose();


                    //  graphics.DrawString("A:", SystemFonts.IconTitleFont, Brushes.Black, new RectangleF(new System.Drawing.Point((int)Bounds.Location.X + 30, (int)Bounds.Location.Y + 77), new Size(20, 20)));

                    HouseName = GH_Capsule.CreateTextCapsule(HouseNameRectangle, InflateRect(HouseNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, houseInstance.HouseName);
                    //  HouseName.Render(graphics, GH_Skin.palette_grey_standard);
                    HouseName.Dispose();

                    FloorName = GH_Capsule.CreateTextCapsule(FloorNameRectangle, InflateRect(FloorNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, houseInstance.FloorName.ToString());
                    //   FloorName.Render(graphics, GH_Skin.palette_white_standard);
                    FloorName.Dispose();



                }
                else
                {
                    //  foreach (IGH_DocumentObject obj in roomInstancesList)
                    //     DrawTargetArrow(graphics, obj.Attributes.Bounds);

                    base.Render(canvas, graphics, channel);

                }
        }

        public PointF CircleClosesPoint(PointF point, RectangleF circle)
        {
            Vector2d vec = new Vector2d(circle.X + circle.Width / 2 - point.X, circle.Y + circle.Width / 2 - point.Y);
            vec.Unitize();
            vec = new Vector2d(vec.X * circle.Width / 2, vec.Y * circle.Width / 2);
            return (new PointF((float)(circle.Location.X + circle.Width / 2 + -vec.X), (float)(circle.Location.Y + circle.Width / 2 - vec.Y)));
        }

        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            //  double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            //  if (distance < OuterComponentRadius)
            //      return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterComponentRadius - 2);
            PointF tp;// = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));
            tp = Grasshopper.GUI.GH_GraphicsUtil.BoxClosestPoint(new PointF(target.Location.X + target.Width / 2, target.Location.Y + target.Height / 2), Bounds);

            PointF cp = CircleClosesPoint(tp, target);

            Pen arrowPen = new Pen(houseBrush, (OuterComponentRadius - InnerComponentRadius) / 8);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            arrowPen.StartCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }

        public void UpdateRoomInstancesColors()
        {
            roomInstancesGuidList.RemoveAll(i => i == "");

            /*    for (int i = 0; i < roomInstancesGuidList.Count; i++)
                {
                    try
                    {
                        Owner.OnPingDocument().FindComponent(new Guid(roomInstancesGuidList[i]));
                        if (Owner.OnPingDocument().FindComponent(new Guid(roomInstancesGuidList[i])) == null)
                        {
                            roomInstancesGuidList.RemoveAt(i);
                            i--;
                        }
                    }
                    catch (Exception e)
                    {
                        roomInstancesGuidList.RemoveAt(i);
                        i--;
                    }
                }
                */

            foreach (string guidS in roomInstancesGuidList)
            {

                RoomInstance childRoom = Owner.OnPingDocument().FindComponent(new Guid(guidS)) as RoomInstance;
                if ((childRoom.Attributes as RoomInstanceAttributes).roomBrush != houseBrush)
                {
                    (childRoom.Attributes as RoomInstanceAttributes).roomBrush = houseBrush;
                    childRoom.ExpireSolution(true);
                }
            }

        }


        public void AddAdjacence(IGH_DocumentObject a)
        {
            if (a == null) return;

            if (roomInstancesGuidList.Find(item => item == a.InstanceGuid.ToString()) == null)
            {
                roomInstancesGuidList.Add(a.InstanceGuid.ToString());

                if (((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                    (((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance.Attributes as HouseInstanceAttributes).RemoveAdjacence(a);

                ((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance = Owner as HouseInstance;

                foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                {
                    if (intPair.a == a.InstanceGuid.ToString() && roomInstancesGuidList.FindIndex(i => i == intPair.b) < 0)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.b)));

                    if (intPair.b == a.InstanceGuid.ToString() && roomInstancesGuidList.FindIndex(i => i == intPair.a) < 0)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.a)));
                }
            }

            UpdateRoomInstancesColors();
        }


        // Removes the RoomInstance and all connected to it RoomInstances
        public void RemoveAdjacence(IGH_DocumentObject a)
        {
            if (a == null) return;

            if (roomInstancesGuidList.RemoveAll(i => i == a.InstanceGuid.ToString()) > 0)
            {

                ((a as RoomInstance).Attributes as RoomInstanceAttributes).roomBrush = Brushes.Gray;
                a.OnDisplayExpired(true);

                foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                {
                    if (intPair.a == a.InstanceGuid.ToString())
                        if (Owner.OnPingDocument() != null)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                            RemoveAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.b)));

                    if (intPair.b == a.InstanceGuid.ToString())
                        if (Owner.OnPingDocument() != null)
                            if (Owner.OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            RemoveAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.a)));
                }
            }
        }

        public override bool Write(GH_IO.Serialization.GH_IWriter writer)
        {
            string roomInstancesListString = "";
            foreach (string guid in roomInstancesGuidList)
                roomInstancesListString += guid + "@";

            if (roomInstancesListString.Length > 0)
                roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            writer.SetString("RoomInstancesListString", roomInstancesListString);
            writer.SetString("HouseName", (Owner as HouseInstance).HouseName);
            writer.SetString("FloorName", (Owner as HouseInstance).FloorName);
            writer.SetBoolean("TryRotateBoundary", (Owner as HouseInstance).tryRotateBoundary);

            return base.Write(writer);
        }
        string[] strArray;
        public override bool Read(GH_IO.Serialization.GH_IReader reader)
        {
            string roomInstancesListString = reader.GetString("RoomInstancesListString");
            strArray = roomInstancesListString.Split('@');



            (Owner as HouseInstance).HouseName = reader.GetString("HouseName");
            (Owner as HouseInstance).FloorName = reader.GetString("FloorName");
            (Owner as HouseInstance).tryRotateBoundary = reader.GetBoolean("TryRotateBoundary");

            Owner.ExpireSolution(false);

            UpdateRoomInstancesColors();
            return base.Read(reader);
        }

    }
}


&&& FILE: ./Magnetizing_FPG/RoomProgram\RoomInstance.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;
using Grasshopper.Kernel;
using Rhino.Geometry;
using System.Linq;

namespace Magnetizing_FPG
{
    /// <summary>
    ///  RoomInstance class contains all the information about 
    ///  one single room: name, ID, all connected rooms.
    /// </summary>
    public class RoomInstance : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the RoomInstance class.
        /// </summary>
        public RoomInstance()
        
          : base("RoomInstance", "RoomInstance",
              "RoomInstance",
             "Magnetizing_FPG", "Magnetizing_FPG")
        {
            if (entranceIds == null)
                entranceIds = new List<int>();
            RoomName = "Room " + RoomId.ToString();
            RoomId = maxId++;

            allRoomInstances.Add(this);
            m_attributes = new RoomInstanceAttributes(this);

            // if (m_attributes is RoomInstanceAttributes)
            foreach (RoomInstance room in (m_attributes as RoomInstanceAttributes).targetObjectList)
                (m_attributes as RoomInstanceAttributes).RemoveAdjacence(room as RoomInstance);

            //(m_attributes as RoomInstanceAttributes).targetObjectList.Clear();
            //(m_attributes as RoomInstanceAttributes).writerTargetObjectsListString = new string[0];
        }

        public class IntPair
        {
          public string a;
          public string b;
            public IntPair(string A, string B)
            {
                a = A;
                b = B;
            }
        }

        public override void AddedToDocument(GH_Document document)
        {
            base.AddedToDocument(document);
        }

        public double RoomArea = 40;
        public int RoomId;// = maxId++;
        public static int maxId = 0;
        public static List<int> entranceIds; // If there is an entrance which should be placed first, it's id will be stored here
        public string RoomName;// = "Room Name";
        public bool isHall = false; // true if the room is to be a hall (connecting-space)
        public bool hasMissingAdj = false;
        public static List<IntPair> allAdjacencesList = new List<IntPair>();
        public static List<RoomInstance> allRoomInstances = new List<RoomInstance>();

        public List<RoomInstance> AdjacentRoomsList
        {
            get {
                List<RoomInstance> list = new List<RoomInstance>();
                foreach (IntPair intPair in allAdjacencesList)
                {
                    if (intPair.a == this.InstanceGuid.ToString())
                        if (OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                        list.Add(OnPingDocument().FindComponent(new Guid(intPair.b)) as RoomInstance);
                    if (intPair.b == this.InstanceGuid.ToString())
                        if (OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            list.Add(OnPingDocument().FindComponent(new Guid(intPair.a)) as RoomInstance);
                }
                list = list.Distinct().ToList();

                return list;
            }

        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddTextParameter("a", "a", "a", GH_ParamAccess.item);
        }

        public override void CreateAttributes()
        {
            m_attributes = new RoomInstanceAttributes(this);
        }
        

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            //  AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "Name: " + RoomName +"\nArea: " + RoomArea);

            //AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, AdjacentRoomsList.Count.ToString());

            DA.SetData(0, RoomName);
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                return Resources.RoomInstanceIcon;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{85beb9d6-e6cd-4499-9659-2d51784d948c}"); }
        }

        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "Set as Entrance", Menu_SetAsEntrance, true, RoomInstance.entranceIds.Contains(this.RoomId));
            Menu_AppendItem(menu, "Set as Hall", Menu_SetAsHall, true, isHall);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        private void Menu_SetAsEntrance(object sender, EventArgs e)
        {
            if (!entranceIds.Contains(RoomId))
            {
                if (entranceIds.Count > 0)
                {
                    List<int> copyList = RoomInstance.entranceIds.ConvertAll(i => i);

                    List<RoomInstance> allConnectedRooms = new List<RoomInstance>();
                    foreach (RoomInstance room in (((m_attributes as RoomInstanceAttributes).AssignedHouseInstance as HouseInstance).RoomInstances))
                        if (room != null)
                        if (room.RoomId != RoomId)
                            allConnectedRooms.Add(room);

                    int prevCount;
                    List<RoomInstance> tempRoomList = new List<RoomInstance>();
                    do
                    {
                        tempRoomList.Clear();
                        prevCount = allConnectedRooms.Count;
                        foreach (RoomInstance room in allConnectedRooms)
                            foreach (RoomInstance roomConnected in room.AdjacentRoomsList)
                                if (roomConnected != null)
                                if (!allConnectedRooms.Contains(roomConnected) && roomConnected.RoomId != RoomId)
                                    tempRoomList.Add(roomConnected);

                        allConnectedRooms.AddRange(tempRoomList);
                    } while (prevCount != allConnectedRooms.Count);


                    foreach (int id in copyList)
                        if (id != RoomId)
                            if (allConnectedRooms.Find(room => (room as RoomInstance).RoomId == id) != null)
                            {
                                entranceIds.Remove(id);
                                //     AdjacentRoomsList.Find(room => (room as RoomInstance).RoomId == id).ExpireSolution(false);
                            }
                }
                RoomInstance.entranceIds.Add(this.RoomId);
            }
            else
                entranceIds.Remove(RoomId);

            ExpireSolution(true);
        }

        private void Menu_SetAsHall(object sender, EventArgs e)
        {
            isHall = !isHall;
            ExpireSolution(false);
        }

    }
}

&&& FILE: ./Magnetizing_FPG/RoomProgram\RoomInstanceAttributes.cs
&&& CONTENT:
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.GUI;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Parameters;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System.Linq;

namespace Magnetizing_FPG
{
    public interface IRoomStructure<T>
    {
        void AddAdjacence(T a);
        void RemoveAdjacence(T a);
    }

    public class RoomInstanceAttributes : GH_ComponentAttributes, IRoomStructure<IGH_DocumentObject>
    {

        public RoomInstanceAttributes(RoomInstance param) : base(param)
        {
            if (RoomArea == null) RoomArea = GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, param.RoomArea.ToString());
            RoomName = GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, param.RoomName);

            roomBrush = Brushes.Gray;


        }

        protected override void Layout()
        {
            Pivot = GH_Convert.ToPoint(Pivot);
            Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);

        }

        public GH_Capsule RoomArea;
        public GH_Capsule RoomName;


        Rectangle RoomAreaRectangle;
        Rectangle RoomNameRectangle;
        Rectangle RoomIdRectangle;

        bool haveReadTargetObjectsList = false;
        public Brush roomBrush;

        const int InflateAmount = 2; // Used to inflate all rectangles for producing outer rectangles for GH_TextCapsules
        const int InnerComponentRadius = 55; // Used to define the radius of the main circle
        const int OuterComponentRadius = 75; // Used to define the radius of the main circle

        public string[] writerTargetObjectsListString = new string[0];

        public HouseInstance AssignedHouseInstance;

        public List<IGH_DocumentObject> targetObjectList = new List<IGH_DocumentObject>();

        protected Rectangle InflateRect(Rectangle rect, int a = 5, int b = 5)
        {
            Rectangle rectOut = rect;
            rectOut.Inflate(-a, -b);
            return rectOut;
        }

        protected RectangleF InnerComponentBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        public override bool IsPickRegion(PointF point)
        {
            return Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, point);
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {
            if (Owner is RoomInstance roomInstance)
                if (channel == GH_CanvasChannel.Objects)
                {
                    graphics.FillEllipse(roomBrush, Bounds);

                    if ((Owner as RoomInstance).hasMissingAdj)
                    {
                        graphics.FillEllipse(Brushes.Red, new RectangleF(Pivot.X - InnerComponentRadius - 9, Pivot.Y - InnerComponentRadius - 9
                            , 2 * InnerComponentRadius + 18, 2 * InnerComponentRadius + 18));
                    }

                    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerComponentBounds, GH_Palette.Normal, InnerComponentRadius - 5, 0);
                    capsule.Render(graphics, Selected, Owner.Locked, true);
                    capsule.Dispose();

                    RoomNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 28, (int)Bounds.Location.Y + 55), new Size(94, 20));
                    RoomAreaRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 65, (int)Bounds.Location.Y + 80), new Size(57, 20));
                    RoomIdRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 35, (int)Bounds.Location.Y + 105), new Size(80, 40));

                    graphics.DrawString("m² :", new Font(FontFamily.GenericSansSerif, 6f, FontStyle.Regular), Brushes.Black, new RectangleF(new System.Drawing.Point((int)Bounds.Location.X + 35, (int)Bounds.Location.Y + 81), new Size(30, 20)));
                    if (!RoomInstance.entranceIds.Contains(roomInstance.RoomId))
                        graphics.DrawString("ID: " + roomInstance.RoomId, new Font(FontFamily.GenericSansSerif, 4f, FontStyle.Regular), Brushes.Black, RoomIdRectangle, new StringFormat() { Alignment = StringAlignment.Center });
                    else
                        graphics.DrawString("ID: " + roomInstance.RoomId + "\n(entrance)", new Font(FontFamily.GenericSansSerif, 4f, FontStyle.Bold), Brushes.Black, RoomIdRectangle, new StringFormat() { Alignment = StringAlignment.Center });


                    RoomName = GH_Capsule.CreateTextCapsule(RoomNameRectangle, InflateRect(RoomNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, roomInstance.RoomName);
                    RoomName.Render(graphics, GH_Skin.palette_grey_standard);
                    RoomName.Dispose();

                    RoomArea = GH_Capsule.CreateTextCapsule(RoomAreaRectangle, InflateRect(RoomAreaRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, roomInstance.RoomArea.ToString());
                    RoomArea.Render(graphics, GH_Skin.palette_white_standard);
                    RoomArea.Dispose();


                    for (int i = 0; i < RoomInstance.allAdjacencesList.Count; i++)
                        try
                        {
                            Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].b));
                            Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].a));

                            if (Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].b)) == null ||
                                Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].a)) == null)
                            {
                                RoomInstance.allAdjacencesList.RemoveAt(i); i--;
                            }
                        }
                        catch (Exception) { RoomInstance.allAdjacencesList.RemoveAt(i); i--; }


                    foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                    {
                        if (intPair.a == this.Owner.InstanceGuid.ToString())
                            try
                            {
                                if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                                    DrawTargetArrow(graphics, Owner.OnPingDocument().FindComponent(new Guid(intPair.b)).Attributes.Bounds);
                            }
                            catch (Exception) { }
                        if (intPair.b == this.Owner.InstanceGuid.ToString())
                            try
                            {
                                if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                                    DrawTargetArrow(graphics, Owner.OnPingDocument().FindComponent(new Guid(intPair.a)).Attributes.Bounds);
                            }
                            catch (Exception) { }
                    }

                    // if (obj != null)
                    //     DrawTargetArrow(graphics, obj.Attributes.Bounds);


                }
                else
                {
                    base.Render(canvas, graphics, channel);
                }

            if (RoomInstance.allAdjacencesList == null || RoomInstance.allAdjacencesList.Count == 0)
                if (writerTargetObjectsListString.Length > 0)// && targetObjectList.Count == 0)
                {
                    if (writerTargetObjectsListString.Length > 0)
                        foreach (string guidS in writerTargetObjectsListString)
                        {
                            try
                            {
                                RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(guidS.Split('%')[0], guidS.Split('%')[1]));
                                //   Owner.OnPingDocument().FindComponent(new Guid(guidS.Split('!')[0]))

                                /*  if (!targetObjectList.Contains(Owner.OnPingDocument().FindComponent(
                                      new System.Drawing.Point(int.Parse(guidS.Split('!')[0]), int.Parse(guidS.Split('!')[1]))) as RoomInstance))
                                      targetObjectList.Add(Owner.OnPingDocument().FindComponent(
                                          new System.Drawing.Point(int.Parse(guidS.Split('!')[0]), int.Parse(guidS.Split('!')[1]))) as RoomInstance);*/
                            }
                            catch (Exception) { }
                        }
                }

        }

        /// <summary>
        /// Get the closest point on the circle
        /// </summary>
        /// <param name="point"></param>
        /// <param name="circle"></param>
        /// <returns></returns>
        public PointF CircleClosestPoint(PointF point, RectangleF circle)
        {
            Vector2d vec = new Vector2d(circle.X + circle.Width / 2 - point.X, circle.Y + circle.Width / 2 - point.Y);
            vec.Unitize();
            vec = new Vector2d(vec.X * circle.Width / 2, vec.Y * circle.Width / 2);
            return (new PointF((float)(circle.Location.X + circle.Width / 2 + -vec.X), (float)(circle.Location.Y + circle.Width / 2 - vec.Y)));
        }

        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            PointF cp = CircleClosestPoint(Pivot, target);

            double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            if (distance < OuterComponentRadius)
                return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterComponentRadius - 2);
            PointF tp = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));

            Pen arrowPen = new Pen(roomBrush, (OuterComponentRadius - InnerComponentRadius) / 2);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            arrowPen.StartCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }


        private bool _drawing;
        private RectangleF _drawingBox;

        public override GH_ObjectResponse RespondToMouseDown(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            _drawing = false;
            _drawingBox = InnerComponentBounds;

            if (e.Button == System.Windows.Forms.MouseButtons.Left)
            {
                // If on outer disc, but not in inner disc, then start a wire drawing process.
                bool onOuterDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, e.CanvasLocation);
                bool onInnerDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(InnerComponentBounds, e.CanvasLocation);
                if (onOuterDisc && !onInnerDisc)
                {
                    // Begin arrow drawing behaviour.
                    _drawing = true;
                    sender.CanvasPostPaintObjects += CanvasPostPaintObjects;
                    return GH_ObjectResponse.Capture;
                }
            }

            // Otherwise revert to default behaviour.
            return base.RespondToMouseDown(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseMove(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (!_drawing)
                return base.RespondToMouseMove(sender, e);

            _drawingBox = new RectangleF(e.CanvasLocation, new SizeF(0, 0));

            GH_Document doc = sender.Document;
            if (doc != null)
            {
                IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                if (att != null)
                {
                    if (att is IRoomStructure<IGH_DocumentObject>)
                        _drawingBox = att.Bounds;
                }
            }
            sender.Invalidate();
            return GH_ObjectResponse.Handled;
        }

        public override GH_ObjectResponse RespondToMouseUp(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawing = false;
                sender.CanvasPostPaintObjects -= CanvasPostPaintObjects;

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                        if (att is IRoomStructure<IGH_DocumentObject> target)
                        {
                            Owner.RecordUndoEvent("Add Modifier");
                            if (att.DocObject is RoomInstance)
                            {
                                if ((att.DocObject as RoomInstance).InstanceGuid != (DocObject as RoomInstance).InstanceGuid)
                                {
                                    if (RoomInstance.allAdjacencesList.Find(i => i.a == att.DocObject.InstanceGuid.ToString() && i.b == DocObject.InstanceGuid.ToString()) == null &&
                                        RoomInstance.allAdjacencesList.Find(i => i.b == att.DocObject.InstanceGuid.ToString() && i.a == DocObject.InstanceGuid.ToString()) == null)
                                    {
                                        AddAdjacence(att.DocObject);
                                        target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                    }
                                    /*
                                    if (targetObjectList.Find(item => (item as RoomInstance).RoomId == (att.DocObject as RoomInstance).RoomId) == null)
                                    {
                                        AddAdjacence(att.DocObject);
                                        target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                    }*/
                                    else
                                    {
                                        RemoveAdjacence(att.DocObject);
                                        target.RemoveAdjacence(this.DocObject as IGH_DocumentObject);
                                    }

                                    RoomInstance.allAdjacencesList = RoomInstance.allAdjacencesList.Distinct().ToList();
                                }
                            }
                            else if (att.DocObject is HouseInstance houseInstance)
                            {
                                if ((att as HouseInstanceAttributes).roomInstancesGuidList.Find(item => item == (this.DocObject as RoomInstance).InstanceGuid.ToString()) == null)
                                    target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                else
                                {
                                    target.RemoveAdjacence(this.DocObject as IGH_DocumentObject);
                                }

                            }

                            IGH_ActiveObject obj = att.DocObject as IGH_ActiveObject;
                        }
                }

                sender.Invalidate();
                return GH_ObjectResponse.Release;
            }

            return base.RespondToMouseUp(sender, e);
        }
        void CanvasPostPaintObjects(GH_Canvas sender)
        {
            if (!_drawing) return;
            DrawTargetArrow(sender.Graphics, _drawingBox);
        }


        public override GH_ObjectResponse RespondToMouseDoubleClick(GH_Canvas sender, GH_CanvasMouseEvent e)
        {
            if (Owner is RoomInstance roomInstance)
            {
                string initial = string.Empty;


                var matrix = sender.Viewport.XFormMatrix(GH_Viewport.GH_DisplayMatrix.CanvasToControl);

                if (this.RoomArea.Contains(e.CanvasLocation))
                {
                    var field = new CapsuleInputBase(RoomArea, roomInstance, RoomInstanceVar.RoomArea)
                    {
                        Bounds = GH_Convert.ToRectangle(RoomArea.Box)
                    };

                    field.ShowTextInputBox(sender, RoomArea.Text, true, false, matrix);
                }


                if (this.RoomName.Contains(e.CanvasLocation))
                {
                    var field = new CapsuleInputBase(RoomName, roomInstance, RoomInstanceVar.RoomName)
                    {
                        Bounds = GH_Convert.ToRectangle(RoomName.Box)
                    };

                    field.ShowTextInputBox(sender, RoomName.Text, true, false, matrix);
                }
                roomInstance.ExpireSolution(false);

                return GH_ObjectResponse.Handled;
            }
            return base.RespondToMouseDoubleClick(sender, e);
        }



        public void AddAdjacence(IGH_DocumentObject a)
        {
            // int t = String.Compare(a.InstanceGuid.ToString(), this.Owner.InstanceGuid.ToString());
            // if (t >= 0)
            RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(a.InstanceGuid.ToString(), this.Owner.InstanceGuid.ToString()));
            //  else
            RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(this.Owner.InstanceGuid.ToString(), a.InstanceGuid.ToString()));

            //  if (!targetObjectList.Contains(a))
            //      targetObjectList.Add(a);

            if (AssignedHouseInstance != null)
                (AssignedHouseInstance.Attributes as HouseInstanceAttributes).AddAdjacence(a);
            else if ((a.Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                ((a.Attributes as RoomInstanceAttributes).AssignedHouseInstance.Attributes as HouseInstanceAttributes).AddAdjacence(this.Owner as RoomInstance);
        }

        public void RemoveAdjacence(IGH_DocumentObject a)
        {
            RoomInstance.allAdjacencesList.RemoveAll(i => i.a == Owner.InstanceGuid.ToString() && i.b == a.InstanceGuid.ToString());
            RoomInstance.allAdjacencesList.RemoveAll(i => i.b == Owner.InstanceGuid.ToString() && i.a == a.InstanceGuid.ToString());


            //  while (targetObjectList.Contains(a))
            //   {
            //       targetObjectList.Remove(a);
            //  }



        }


        public override bool Write(GH_IO.Serialization.GH_IWriter writer)
        {
            string roomInstancesListString = "";
            foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                roomInstancesListString += intPair.a + "%" + intPair.b + "@";

            /*   foreach (RoomInstance room in targetObjectList)
                   if (room != null)
                       roomInstancesListString += ((int)(room.Attributes.Pivot.X)).ToString() + "!" +
                       ((int)(room.Attributes.Pivot.Y)).ToString() + "@";
   */
            if (roomInstancesListString.Length > 0)
                roomInstancesListString = roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            writer.SetString("TargetObjectList", roomInstancesListString);
            writer.SetString("RoomName", (Owner as RoomInstance).RoomName);
            //    writer.SetInt32("RoomId", (int)(Owner as RoomInstance).RoomId);
            writer.SetDouble("RoomArea", (Owner as RoomInstance).RoomArea);

            writer.SetBoolean("isHall", (Owner as RoomInstance).isHall);

            string temp = "";
            foreach (int a in RoomInstance.entranceIds)
                temp += a.ToString() + "&";
            if (temp.Length > 0)
                temp = temp.Remove(temp.Length - 1);

            writer.SetString("EntranceIds", temp);

            return base.Write(writer);
        }


        public override bool Read(GH_IO.Serialization.GH_IReader reader)
        {
            string roomInstancesListString = reader.GetString("TargetObjectList");
            writerTargetObjectsListString = roomInstancesListString.Split('@');

            // roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            (Owner as RoomInstance).RoomName = reader.GetString("RoomName");//, (Owner as RoomInstance).RoomName);
                                                                            //    (Owner as RoomInstance).RoomId = (uint)reader.GetInt32("RoomId");//, (int)(Owner as RoomInstance).RoomId);
            (Owner as RoomInstance).RoomArea = (int)Math.Floor(reader.GetDouble("RoomArea"));//, (Owner as RoomInstance).RoomArea);

            try
            {
                (Owner as RoomInstance).isHall = reader.GetBoolean("isHall");
            }
            catch (Exception e) { }

            RoomInstance.entranceIds = new List<int>();
            string temp = "";
            try
            {
                temp = reader.GetString("EntranceIds");
            }
            catch (Exception) { }

            if (temp != null && temp.Length > 0)
            {
                string[] tempList = temp.Split('&');
                foreach (string s in tempList)
                    RoomInstance.entranceIds.Add(Int32.Parse(s));
            }

            Owner.ExpireSolution(false);

            return base.Read(reader);
        }
    }

    public enum RoomInstanceVar { RoomName, RoomArea };

    class CapsuleInputBase : Grasshopper.GUI.Base.GH_TextBoxInputBase
    {
        public GH_Capsule _input;
        public RoomInstance _roomInstance;
        private RoomInstanceVar _roomInstanceVar;

        public CapsuleInputBase(GH_Capsule input, RoomInstance roomInstance, RoomInstanceVar roomInstanceVar)
        {
            _input = input ?? throw new ArgumentNullException(nameof(input));
            _roomInstance = roomInstance;
            _roomInstanceVar = roomInstanceVar;
        }

        protected override void HandleTextInputAccepted(string text)
        {
            _input.Text = text;

            switch (_roomInstanceVar)
            {
                case (RoomInstanceVar.RoomName):
                    _roomInstance.RoomName = text;
                    break;

                case (RoomInstanceVar.RoomArea):
                    _roomInstance.RoomArea = Int32.Parse(text);
                    break;
            }
            _roomInstance.ExpireSolution(false);
            if ((_roomInstance.Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                (_roomInstance.Attributes as RoomInstanceAttributes).AssignedHouseInstance.ExpireSolution(false);
        }
    }


}


