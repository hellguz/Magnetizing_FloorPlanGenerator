<./FloorPlan_Generator_1Info.cs>
﻿using System;
using System.Drawing;
using Grasshopper.Kernel;

namespace FloorPlan_Generator
{
    public class FloorPlan_Generator_1Info : GH_AssemblyInfo
    {
        public override string Name
        {
            get
            {
                return "FloorPlanGenerator";
            }
        }
        public override Bitmap Icon
        {
            get
            {
                //Return a 24x24 pixel bitmap to represent this GHA library.
                return null;
            }
        }
        public override string Description
        {
            get
            {
                //Return a short string describing the purpose of this GHA library.
                return "";
            }
        }
        public override Guid Id
        {
            get
            {
                return new Guid("802849a2-befa-47bb-9c19-a2d1f328f105");
            }
        }

        public override string AuthorName
        {
            get
            {
                //Return a string identifying you or your company.
                return "";
            }
        }
        public override string AuthorContact
        {
            get
            {
                //Return a string representing your preferred contact details.
                return "";
            }
        }
    }
}


<./Magnetizing_FPG.csproj>
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug32</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{F5F278EA-405F-40D9-9A0D-00C1854F8D43}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Magnetizing_FPG</RootNamespace>
    <AssemblyName>Magnetizing_FPG</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug32|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug64|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="clipper_library">
      <HintPath>References\clipper_library.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="RhinoCommon">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>References\RhinoCommon.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Grasshopper">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>.\References\Grasshopper.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="GH_IO">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>References\GH_IO.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Magnetizing_FPG\RoomProgram\HouseInstanceTextInput.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Magnetizing_FPG\RoomProgram\HouseInstance.cs" />
    <Compile Include="Magnetizing_FPG\RoomProgram\HouseInstanceAttributes.cs" />
    <Compile Include="Magnetizing_FPG\RoomProgram\RoomInstance.cs" />
    <Compile Include="Magnetizing_FPG\RoomProgram\RoomInstanceAttributes.cs" />
    <Compile Include="Magnetizing_FPG\MagnetizingRooms_ES.cs" />
    <None Include="studies\Study2\ShneiderKoenig.cs" />
    <None Include="studies\Study4\David.cs" />
    <None Include="studies\Study4\MagnetizingRooms_HeapES.cs" />
    <None Include="studies\Study4\RoomInstance_00.cs" />
    <Compile Include="Magnetizing_FPG\SpringSystem_ES.cs" />
    <None Include="studies\Study5\GenerateCorridorsInBetween.cs" />
    <None Include="studies\Study4\MagnetizingRooms.cs" />
    <None Include="studies\Study2\SpringSystem.cs" />
    <Compile Include="FloorPlan_Generator_1Info.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <None Include="studies\Study6\TensorFields Quad.cs" />
    <None Include="studies\Study6\TensorFields 3.cs" />
    <Compile Include="FloorPlan_Generator_1Info.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <None Include="studies\Study7\EvoStrat.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\HouseInstanceIcon.png" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <WCFMetadata Include="Connected Services\" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\RoomInstanceIcon.png" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\MagnetizingRoomsIcon.png" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="Resources\SpringSystem_ESIcon.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
  <PropertyGroup>
    <PostBuildEvent>Copy "$(TargetPath)" "$(TargetDir)$(ProjectName).gha"
Copy "$(TargetPath)" "%25AppData%25\Grasshopper\Libraries\$(ProjectName).gha"</PostBuildEvent>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug32|AnyCPU' ">
    <StartArguments>
    </StartArguments>
    <StartAction>Program</StartAction>
    <StartProgram>c:\Program Files (x86)\Rhinoceros 5\System\Rhino4.exe</StartProgram>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <FallbackCulture>en-US</FallbackCulture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug64|AnyCPU'">
    <StartProgram>c:\Program Files\Rhinoceros 5 (64-bit)\System\Rhino.exe</StartProgram>
    <StartArguments>
    </StartArguments>
    <StartAction>Program</StartAction>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
</Project>

<./Magnetizing_FPG.csproj.user>
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug32|AnyCPU'">
    <StartProgram>C:\Program Files\Rhino 7\System\Rhino.exe</StartProgram>
  </PropertyGroup>
</Project>

<./Magnetizing_FPG.sln>
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Magnetizing_FPG", "Magnetizing_FPG.csproj", "{F5F278EA-405F-40D9-9A0D-00C1854F8D43}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug32|Any CPU = Debug32|Any CPU
		Debug64|Any CPU = Debug64|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Debug32|Any CPU.ActiveCfg = Debug32|Any CPU
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Debug32|Any CPU.Build.0 = Debug32|Any CPU
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Debug64|Any CPU.ActiveCfg = Debug64|Any CPU
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Debug64|Any CPU.Build.0 = Debug64|Any CPU
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F5F278EA-405F-40D9-9A0D-00C1854F8D43}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D4F8FF12-2464-4D9F-A076-1ED10B7C4601}
	EndGlobalSection
EndGlobal


<./packages.config>
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Clipper" version="6.4.0" targetFramework="net40" />
</packages>

<./README.md>
# Magnetizing Floor Plan Generator

## Overview

The Magnetizing Floor Plan Generator is an innovative tool for automatically generating floor plans for public buildings. It uses a novel "magnetizing" approach to arrange rooms and create efficient layouts while considering adjacency requirements and spatial constraints.

This Grasshopper plugin provides an algorithmic solution for the complex task of floor plan generation, which is typically time-consuming and challenging for architects, developers, and urban planners. The generator aims to produce diverse, flexible, and rapid results that can serve as a starting point for further design refinement.

## Key Features

- Automatic generation of floor plans based on room program and adjacency requirements
- Flexible input of room areas, connections, and building boundary
- Iterative optimization using a quasi-evolutionary strategy 
- Corridor and circulation space generation
- Adjustable parameters for fine-tuning results
- Visual output of generated floor plans in Rhino/Grasshopper

## Installation

1. Ensure you have Rhino 6 or later and Grasshopper installed
2. Download the latest release from the [Food4Rhino page](https://www.food4rhino.com/en/app/magnetizing-floor-plan-generator)
3. Unzip the downloaded file
4. Copy the `Magnetizing_FPG.gha` file to your Grasshopper Libraries folder (typically `%AppData%\Grasshopper\Libraries\`)
5. Restart Rhino and Grasshopper
6. The Magnetizing Floor Plan Generator components should now be available in the Grasshopper canvas under the "Magnetizing_FPG" tab

## Usage

1. Create a new Grasshopper definition
2. Add the `HouseInstance` component to your canvas
3. Connect your building boundary curve to the "Boundary" input
4. Use `RoomInstance` components to define your room program (names, areas, connections)
5. Connect the `RoomInstance` components to the `HouseInstance`
6. Add the `MagnetizingRooms_ES` component and connect the `HouseInstance` to it
7. Adjust parameters as needed (cell size, iterations, etc.)
8. The generated floor plan will be output as curves

For more detailed usage instructions and examples, please refer to the [official documentation](https://www.food4rhino.com/en/app/magnetizing-floor-plan-generator).

## How It Works

The Magnetizing Floor Plan Generator uses the following key steps:

1. Initialization of rooms based on input program
2. Iterative placement of rooms considering adjacencies
3. Corridor generation to connect spaces
4. Optimization using a quasi-evolutionary strategy
5. Fine-tuning of room positions and proportions
6. Optional post-processing (e.g., dead-end removal)

The algorithm aims to balance various factors such as room adjacencies, proportions, and overall layout efficiency.

## Contributing

Contributions to improve the Magnetizing Floor Plan Generator are welcome. Please feel free to submit issues or pull requests through GitHub.

## License


## Authors

- Egor Gavrilov

## Co-Authors

- Sven Schneider
- Martin Dennemark
- Reinhard Koenig

## Acknowledgments

This project was developed at the Bauhaus-University Weimar. We thank all contributors and testers who have helped improve this tool.

## Citation

If you use this tool in your research or projects, please cite:

```
Gavrilov, E., Schneider, S., Dennemark, M., Koenig, R. (2020). Computer-aided approach to public buildings floor plan generation. Magnetizing Floor Plan Generator. In Proceedings of the 1st International Conference on Optimization-Driven Architectural Design.
```

## Contact

For questions or support, please contact [contact information].

Citations:
[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/11249532/25a1c0c0-c0ef-4931-8df6-98bf77f7b074/Computer-aided_approach_to_public_buildings_floor.pdf
[2] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/11249532/7a06ca7e-a198-4bcf-86ae-607b84a82103/concatenated_code.txt
[3] https://www.food4rhino.com/en/app/magnetizing-floor-plan-generator

<./Magnetizing_FPG\MagnetizingRooms_ES.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class MagnetizingRooms_ES : GH_Component
    {

        Random random = new Random();

        List<RoomCells> roomCellsList = new List<RoomCells>();
        List<GridSolution> gridSolutionsCollection;

        // MaxRatio stated for maximum allowed proportions of every room. 
        const double MaxRatio = 1.9f;
        
        double boundaryOffset = 2.3f;

        // That's needed for AppendAdditionalMenuItems functions.
        bool oneSideCorridorsChecked = false;
        bool twoSidesCorridorsChecked = true;
        bool allSidesCorridorsChecked = false;

        bool corridorsAsAdditionalSpacesChecked = true;

        bool shouldOnlyRecomputeDeadEnds = false;

        bool removeDeadEndsChecked = true;
        bool removeAllCorridorsChecked = false;

        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public MagnetizingRooms_ES()
          : base("MagnetizingRooms_ES", "Magnetizing_FPG",
              "MagnetizingRooms_ES",
              "Magnetizing_FPG", "Magnetizing_FPG")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("House Instance", "HI", "One or more House Instances. It already contains the information about " +
                "boundary, areas of rooms, starting point and so on.", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Iterations", "I", "Iterations counter. Generally value between 300-900 works best.", GH_ParamAccess.item, 3);
            pManager.AddNumberParameter("MaxAdjDistance", "MAD", "Max distance between 2 connected rooms. Generally 2-3 works best.", GH_ParamAccess.item, 2);
            pManager.AddNumberParameter("CellSize(m)", "CS(m)", "Resolution of grid in meters, 1m is used by default", GH_ParamAccess.item, 1);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddBrepParameter("Corridors", "C", "Corridors as Breps", GH_ParamAccess.item);
            pManager.AddBrepParameter("Room Breps", "Rs", "Rooms as Breps list", GH_ParamAccess.list);
            pManager.AddTextParameter("Room Names", "Ns", "Room Names", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacencies", "A", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.item);
            pManager.AddIntegerParameter("MissingAdjacences", "!A", "Missing Adjacences for every room of the list", GH_ParamAccess.list);
            pManager.AddCurveParameter("Boundary", "B", "Boundary output", GH_ParamAccess.item);
            pManager.AddCurveParameter("Boundary+Offset", "Bo", "Boundary offset output", GH_ParamAccess.item);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<Curve> rooms = new List<Curve>();
            List<int> dims = new List<int>();
            int iterations = 0;
            List<int> roomAreas = new List<int>();
            List<string> adjStrList = new List<string>();
            double maxAdjDistance = 0;
            int entranceIndexInRoomAreas = -1;
            IHouseInstance houseInstance = null;
            double oneCellSize = 1;

            GH_ObjectWrapper houseInstanceWrapper = new GH_ObjectWrapper();
            DA.GetData("House Instance", ref houseInstanceWrapper);
            houseInstance = houseInstanceWrapper.Value as IHouseInstance;

            DA.GetData("CellSize(m)", ref oneCellSize);

            // initialRoomsList contains all (RoomInstance) objects with their attributes.
            List<IRoomInstance> initialRoomsList = houseInstance.RoomInstances;
            Curve boundaryCrv = houseInstance.boundary;
            int[,] adjArray = houseInstance.adjArray;
            adjStrList = houseInstance.adjStrList;

            DA.SetData("Boundary", boundaryCrv);
            boundaryCrv = boundaryCrv.Offset(Plane.WorldXY, boundaryOffset, 0.001f, CurveOffsetCornerStyle.Sharp)[0];
            DA.SetData("Boundary+Offset", boundaryCrv);

            
            boundaryCrv.Scale(1 / oneCellSize);
            houseInstance.startingPoint.Transform(Transform.Scale(new Point3d(0, 0, 0), 1 / oneCellSize));

            // startingPoints contains a list of Points which were provided as points for placing the first (entrance) room.
            // IMPORTANT: currently the algorithm can't work with a list of points, it uses only the first one from the list.
            List<Point3d> startingPoints = new List<Point3d>();
            startingPoints.Add(houseInstance.startingPoint);

            // Let's go through all the rooms from the input and try to find the entrance room. It must be placed first.
            // RoomInstance.entranceIds is a static field, it contains a list of all entrance rooms which are on grasshopper workingGrid.
            // For example, if we have 3 room structures on the workingGrid (3 houses), then the list will contain 3 rooms: one for every house.
            for (int i = 0; i < initialRoomsList.Count; i++)
                if (RoomInstance.entranceIds.Contains(initialRoomsList[i].RoomId))
                {
                    entranceIndexInRoomAreas = i + 1;
                    break;
                }

            int x = 0;
            int y = 0;

            DA.GetData("Iterations", ref iterations);
            DA.GetData("MaxAdjDistance", ref maxAdjDistance);

            // Let's deal with setting boundary curve. The curve is rotated so it fits best into rectangle. 
            // Then a workingGrid of cells (Breps) should be generated so it covers the whole boundary.
            // As we generated a workingGrid of cells on top of the rotated boundary, they should be rotated back again,
            // together with the boundary itself.
            // Moreover, we should rotate the starting point also.

            double boundaryCurveRotationRad = 0;
            double minBoundaryArea = double.MaxValue;
            if (houseInstance.tryRotateBoundary)

                for (double i = 0; i <= Math.PI / 2f; i += Math.PI / 360f)
                {
                    Curve rotatedBoundaryCurve = boundaryCrv.Duplicate() as Curve;
                    rotatedBoundaryCurve.Rotate(i, Vector3d.ZAxis, rotatedBoundaryCurve.GetBoundingBox(false).Center);
                    double newArea = AreaMassProperties.Compute(new Rectangle3d(new Plane(rotatedBoundaryCurve.GetBoundingBox(false).Center, Vector3d.ZAxis)
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.X
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.Y).ToNurbsCurve()).Area;

                    if (newArea < minBoundaryArea)
                    {
                        minBoundaryArea = newArea;
                        boundaryCurveRotationRad = i;
                    }
                }
            Point3d rotationCenter = boundaryCrv.GetBoundingBox(false).Center;
            Point3d tempP = startingPoints[0];
            tempP.Transform(Transform.Rotation(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter));
            startingPoints[0] = tempP;
            boundaryCrv.Rotate(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);

            x = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.X);
            y = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.Y);

            Point3d originPoint = boundaryCrv.GetBoundingBox(false).Corner(true, true, true);
            Vector3d diagonal = boundaryCrv.GetBoundingBox(false).Diagonal;

            // gridSurfaceArray will contain all cell Breps for our workingGrid. They will be used to form
            // rooms and corridors in the very end of the algorithm.
            Surface[] gridSurfaceArray = new Surface[x * y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    gridSurfaceArray[j + y * i] = new PlaneSurface(new Plane(
                        Point3d.Origin, Vector3d.ZAxis)
                        , new Interval(originPoint.X + (i) * diagonal.X / x, originPoint.X + (i + 1) * diagonal.X / x)
                        , new Interval(originPoint.Y + (j) * diagonal.Y / y, originPoint.Y + (j + 1) * diagonal.Y / y));



            if (houseInstance.tryRotateBoundary)
                for (int i = 0; i < x; i++)
                    for (int j = 0; j < y; j++)
                        gridSurfaceArray[i + x * j].Rotate(-boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);

            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    gridSurfaceArray[i + x * j].Scale(oneCellSize);


            // So the cells are rotated back again, they can be used now.

            // workingGrid is an array[int, int], containing the current state of a room structure.
            //
            // If the cell = -1         -> it is a corridor
            //             =  0         -> it is free
            //             =  N (1-...) -> it is a room 
            //             =  9999      -> it is outside initial curve boundary, therefore it cannot be used
            //                             (sorry for that, was too lazy to write smth more complicated)

            // If the initial curve boundary was not rectangular, we should make sure that the algorithm
            // will not place rooms outside it. Let's fill all cells with 9999 (sorry for that, was too lazy to write smth more complicated)
            int[,] workingGrid = new int[x, y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    if (boundaryCrv.Contains(new Point3d(boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X + i + 0.5f
                    , boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y + j + 0.5f, 0)) == PointContainment.Inside)
                        workingGrid[i, j] = 0;
                    else
                        workingGrid[i, j] = 9999;


            // If there is no startingPoint provided, let's assume that the center of 
            // the grid is a starting point.
            if (startingPoints == null)
                workingGrid[x / 2, y / 2] = -1;
            else
                foreach (Point3d point in startingPoints)
                {
                    if (boundaryCrv.Contains(point) == PointContainment.Inside)
                    {
                        int xIndex = (int)Math.Floor(point.X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X);
                        int yIndex = (int)Math.Floor(point.Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y);
                        workingGrid[xIndex, yIndex] = -1;
                    }
                }


            // Actual algorithm starts.

            // Let's save the initial state of workingGrid, so we can restore it in each iteration beginning
            int[,] initialWorkingGrid = workingGrid.Clone() as int[,];

            // placedRoomsOrderedList contains the current order of rooms based on their priority. Rooms which
            // have more adjacences with already placed rooms have higher priority. For example if
            // room_1, room_2, room_3 are already placed and room_4 (adj. to 1, 2), room_5 (adj. to 4, 6),
            // room_6 (adj. to 1, 2, 3) are not placed yet,
            // the placedRoomsOrderedList list will look like {room_6, room_4, room_5}.
            List<int> placedRoomsOrderedList = new List<int>();
            bool placedEntranceRoom;

            // If there is no need to execute the whole sequence, for example when user only 
            // checkes shouldOnlyRecomputeDeadEnds variable and does not change initial input,
            // then let's set iterations to 0 and do not execute the main part.
            // Otherwise, let's initialize gridSolutionsCollection list. It will
            // contain the whole number of best solutions (explained in details further).
            if (shouldOnlyRecomputeDeadEnds && gridSolutionsCollection != null && gridSolutionsCollection.Count > 0)
            {
                shouldOnlyRecomputeDeadEnds = false;
                iterations = 0;
            }
            else
                gridSolutionsCollection = new List<GridSolution>();

            // This is the main part of the algorithm.
            for (int currentIteration = 0; currentIteration < iterations; currentIteration++)
            {
                // gridSolutionCurrentIndex indicates current solution from gridSolution that we are working with.
                // So, each THIRD (explained below) iteration we try to alter a number of best solutions that we get from previous
                // iteration, and if these new solutions are better, we exchange them with initial ones.

                // gridSolutionCapacity is number of solutions that we keep after each iteration.
                // After every iteration the gridSolution list is sorted and then shortened to its capacity.
                int gridSolutionCapacity = 5;
                for (int gridSolutionCurrentIndex = 0; gridSolutionCurrentIndex < gridSolutionCapacity; gridSolutionCurrentIndex++)
                {
                    // If (iteration % newSolutionsFrequency != 0) -> some new solutions are generated, so we don't get stuck with local maximum.
                    int newSolutionsFrequency = 3;

                    // If it is time to alter one of previous solutions...
                    if (gridSolutionsCollection.Count > gridSolutionCurrentIndex && currentIteration != 0 && currentIteration % newSolutionsFrequency == 0)
                    {
                        // ... then let's fill all variables used in algorithm with already precomputed data
                        // from previous iteration.
                        placedEntranceRoom = true;

                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].grid.GetLength(0); q++)
                            for (int w = 0; w < gridSolutionsCollection[gridSolutionCurrentIndex].grid.GetLength(1); w++)
                                workingGrid[q, w] = gridSolutionsCollection[gridSolutionCurrentIndex].grid[q, w];

                        placedRoomsOrderedList.Clear();
                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList.Count; q++)
                            placedRoomsOrderedList.Add(gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList[q]);

                        roomCellsList.Clear();
                        for (int q = 0; q < gridSolutionsCollection[gridSolutionCurrentIndex].roomCellsList.Count; q++)
                            roomCellsList.Add(new RoomCells(gridSolutionsCollection[gridSolutionCurrentIndex].roomCellsList[q]));

                        // Then let's remove last placed 1-5 rooms from the solution. So we can try to place
                        // them differently and maybe a new and better way of placement would appear.
                        int roomRemovalCount = 1 + random.Next(5);
                        for (int j = 0; j < roomRemovalCount; j++)
                            if (placedRoomsOrderedList.Count > 1)
                            {
                                RemoveRoomFromGrid(ref workingGrid, roomCellsList[placedRoomsOrderedList[placedRoomsOrderedList.Count - 1]]);
                                placedRoomsOrderedList.RemoveAt(placedRoomsOrderedList.Count - 1);
                            }
                    }
                    // If it is time to generate a new solution, let's initialize all
                    // required variables and proceed.
                    else
                    {
                        workingGrid = initialWorkingGrid.Clone() as int[,];
                        placedRoomsOrderedList = new List<int>();
                        placedEntranceRoom = false;

                        roomCellsList.Clear();
                        foreach (IRoomInstance room in initialRoomsList)
                            roomCellsList.Add(new RoomCells());
                    }

                    // Let's try to place each room in case it is not placed yet
                    for (int j = 0; j < initialRoomsList.Count; j++)
                    {
                        // In the very beginning of the algorithm's execution we have set a value 
                        // in a starting point of a workingGrid from 0 to -1. When the first room is already
                        // placed, we can remove that first starting point. Otherwise, it can affect the
                        // structure of rooms and cause some empty spaces in between them to appear.
                        if (j == 1 && workingGrid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] == -1 && placedRoomsOrderedList.Count == 1)
                        {
                            workingGrid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] = 0;
                        }

                        // This list contains all rooms that are to be placed, together with their 
                        // priority.
                        // IntPair contains {(room number in the initialRoomsList) + 1, room priority}
                        List<IntPair> roomsOrderList = new List<IntPair>();

                        for (int w = 1; w <= initialRoomsList.Count; w++)
                            if (!GridContains(workingGrid, w))
                                roomsOrderList.Add(new IntPair(w, 0));
                            else
                                roomsOrderList.Add(new IntPair(w, -1));

                        // Let's fill the priority of every room and then sort the list
                        for (int q = 0; q < adjArray.GetLength(0); q++)
                        {
                            if (GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber) && !GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber))
                                roomsOrderList[adjArray[q, 0] - 1] = new IntPair(roomsOrderList[adjArray[q, 0] - 1].roomNumber
                                    , roomsOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                            if (GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber) && !GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber))
                                roomsOrderList[adjArray[q, 1] - 1] = new IntPair(roomsOrderList[adjArray[q, 1] - 1].roomNumber
                                    , roomsOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);
                        }
                        roomsOrderList = roomsOrderList.OrderBy(key => -key.AdjNum).ToList();

                        // roomToBePlacedNum contains the number of next room which should be placed on the workingGrid.
                        int roomToBePlacedNum;

                        // So if the entrance room is not place yet, let's place it first!
                        if (RoomInstance.entranceIds.Count > 0 && entranceIndexInRoomAreas >= 0 && placedEntranceRoom == false)
                        {
                            roomToBePlacedNum = entranceIndexInRoomAreas;
                            placedEntranceRoom = true;
                        }
                        // If at least one unplaced room is adjacent to at least one placed room, then place it
                        else if (roomsOrderList[0].AdjNum > 0)
                            roomToBePlacedNum = roomsOrderList[0].roomNumber;
                        // If no, then place the most adjacent room overall
                        else
                        {
                            roomsOrderList = new List<IntPair>();

                            for (int w = 1; w <= initialRoomsList.Count; w++)
                                if (!GridContains(workingGrid, w))
                                    roomsOrderList.Add(new IntPair(w, 0));
                                else
                                    roomsOrderList.Add(new IntPair(w, -1));

                            for (int q = 0; q < adjArray.GetLength(0); q++)
                            {
                                if (!GridContains(workingGrid, roomsOrderList[adjArray[q, 0] - 1].roomNumber))
                                    roomsOrderList[adjArray[q, 0] - 1] = new IntPair(roomsOrderList[adjArray[q, 0] - 1].roomNumber
                                        , roomsOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                                if (!GridContains(workingGrid, roomsOrderList[adjArray[q, 1] - 1].roomNumber))
                                    roomsOrderList[adjArray[q, 1] - 1] = new IntPair(roomsOrderList[adjArray[q, 1] - 1].roomNumber
                                        , roomsOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                            }
                            roomsOrderList = roomsOrderList.OrderBy(key => -key.AdjNum).ToList();
                            roomToBePlacedNum = roomsOrderList[0].roomNumber;
                        }

                        // Check again that workingGrid does not contain roomToBePlacedNum. 
                        // It should not happen, but whatever ¯\_(ツ)_/¯
                        if (!GridContains(workingGrid, roomToBePlacedNum))
                        {
                            // This is the function which determines the position of a room and which 
                            // tries to place it. However, if the room can't be placed anywhere,
                            // the iteration stops. Then results are evaluated and the next iteration starts.
                            if (TryPlaceNewRoomToTheGrid(ref workingGrid, initialRoomsList[roomToBePlacedNum - 1].RoomArea / oneCellSize / oneCellSize 
                                , roomToBePlacedNum, adjArray, maxAdjDistance, initialRoomsList[roomToBePlacedNum - 1].isHall))
                                placedRoomsOrderedList.Add(roomToBePlacedNum - 1);
                            else
                                break;
                        }
                    }

                    // If the new solution is one of altered previous solutions and it is better
                    // than its predecessor, then let's exchange them. 
                    // Other decision could be just to add a new solution to the list and do not
                    // remove the predecessor, however, it is not made like this intentionally.
                    // This decision badly affects the variety of results.
                    if (gridSolutionsCollection.Count > gridSolutionCurrentIndex && currentIteration % gridSolutionCapacity == 0)
                    {
                        if (placedRoomsOrderedList.Count > gridSolutionsCollection[gridSolutionCurrentIndex].placedRoomsOrderedList.Count)
                        {
                            gridSolutionsCollection.Add(new GridSolution(workingGrid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), placedRoomsOrderedList));
                            gridSolutionsCollection.RemoveAt(gridSolutionCurrentIndex);
                        }
                    }
                    else
                        gridSolutionsCollection.Add(new GridSolution(workingGrid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), placedRoomsOrderedList));

                }

                // Let's shorten the gridSolutionsCollection a bit, so it won't
                // get too big.
                gridSolutionsCollection = gridSolutionsCollection.OrderBy(solution => -solution.placedRoomsOrderedList.Count).ToList();
                if (gridSolutionsCollection.Count > gridSolutionCapacity + 2)
                    gridSolutionsCollection.RemoveRange(gridSolutionCapacity + 2, Math.Max(0, gridSolutionsCollection.Count - gridSolutionCapacity - 2));
            }

            // Not it's time to sort gridSolutionsCollection! It is sorted according to the number of placed rooms
            // in every solution.
            gridSolutionsCollection = gridSolutionsCollection.OrderBy(solution => -solution.placedRoomsOrderedList.Count).ToList() as List<GridSolution>;


            // bestGrid contains the best solution after all iterations. Only this
            // solution is used further for generating output data.
            int[,] bestGrid = gridSolutionsCollection[0].grid.Clone() as int[,];

            if (removeDeadEndsChecked)
                RemoveDeadEnds(ref bestGrid, gridSolutionsCollection[0].roomCellsList);

            if (removeAllCorridorsChecked)
                RemoveAllCorridors(ref bestGrid, gridSolutionsCollection[0].roomCellsList);

            // the list that contains all values from bestGrid, but in linear array.
            List<int> bestGridLinear = new List<int>();

            HashSet<int> placedRoomsNums = new HashSet<int>();

            // Remove all '9999' cells, they stand for cells that are outside the curve boundary of the building
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                {
                    // Again sorry for that lazy solution ¯\_(ツ)_/¯
                    if (bestGrid[i, j] != 9999)
                        bestGridLinear.Add(bestGrid[i, j]);
                    else
                        bestGridLinear.Add(0);

                    if (!placedRoomsNums.Contains(bestGrid[i, j]) && bestGrid[i, j] != 0 && bestGrid[i, j] != -1 && bestGrid[i, j] != 9999)
                        placedRoomsNums.Add(bestGrid[i, j]);
                }
            //placedRoomsNums.Sort();

            // Indicate all RoomInstances that are not placed in the workingGrid on the graph in grasshopper window
            List<int> missingRoomAdj = MissingRoomAdjacences(bestGrid, adjArray);
            for (int i = 0; i < initialRoomsList.Count; i++)
                if (!placedRoomsNums.Contains(Convert.ToInt32(i + 1)))
                {
                    if (initialRoomsList[i].hasMissingAdj != true)
                        initialRoomsList[i].hasMissingAdj = true;
                }
                else
                {
                    if (initialRoomsList[i].hasMissingAdj != false)
                        initialRoomsList[i].hasMissingAdj = false;
                }

            List<int> placedRoomsNumsList = placedRoomsNums.ToList();


            // missingRoomAdj is not the list that we're looking for. It considers wrong list of rooms (all of them, instead of only placed ones)
            // So we have to fix it a bit
            List<int> missingRoomAdjSortedList = new List<int>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
                missingRoomAdjSortedList.Add(missingRoomAdj[placedRoomsNumsList[i] - 1]);


            List<string> roomNames = new List<string>();
            for (int i = 0; i < placedRoomsNumsList.Count; i++)
            {
                if (!initialRoomsList[placedRoomsNumsList[i] - 1].isHall)
                    roomNames.Add(initialRoomsList[placedRoomsNumsList[i] - 1].RoomName);
                else
                    roomNames.Add("&&HALL&&" + initialRoomsList[placedRoomsNumsList[i] - 1].RoomName);
            }


            // That should not be there I guess

            /*            // At the end let's convert all needed rooms to halls   
            for (int i = 0; i < bestGrid.GetLength(0); i++)
                for (int j = 0; j < bestGrid.GetLength(1); j++)
                    if (bestGrid[i, j] > 0 && bestGrid[i, j] <= initialRoomsList.Count)
                        if (initialRoomsList[bestGrid[i, j] - 1].isHall)
                            bestGrid[i, j] = -1;
            */


            // Now let's convert all cells to corresponding rooms
            List<Brep> roomBrepsList = new List<Brep>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < bestGridLinear.Count; q++)
                    if (bestGridLinear[q] == placedRoomsNumsList[i])
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    roomBrepsList.Add(Brep.JoinBreps(cellsCollection, 0.01f)[0]);

            }

            // Now let's convert all cells to united corridors structure
            Brep corridorsBrep = new Brep();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < bestGridLinear.Count; q++)
                    if (bestGridLinear[q] == -1)
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    corridorsBrep = Brep.JoinBreps(cellsCollection, 0.01f)[0];

            }

            string adjacenciesOutputString = "";
            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (placedRoomsNumsList.Contains(adjArray[i, 0]) && placedRoomsNumsList.Contains(adjArray[i, 1]))
                    adjacenciesOutputString += placedRoomsNumsList.IndexOf(adjArray[i, 0]) + "-" + placedRoomsNumsList.IndexOf(adjArray[i, 1]) + "\n";

            DA.SetDataList("Room Breps", roomBrepsList);
            DA.SetData("Corridors", corridorsBrep);
            DA.SetDataList("MissingAdjacences", missingRoomAdjSortedList);
            DA.SetData("Adjacencies", adjacenciesOutputString);
            DA.SetDataList("Room Names", roomNames);

            this.Message = gridSolutionsCollection[0].placedRoomsOrderedList.Count + " of " + initialRoomsList.Count + " placed";
        }

        /// <summary>
        /// This function serves for removing dead ends from the corridor structure 
        /// after the main part of generation is executed already.
        /// The 'dead end' is a corridor, which is not actually required for the 
        /// corridor system to be coherent.
        /// </summary>
        /// <param name="grid"> workingGrid</param>
        /// <param name="roomCellsList"> List of all dimensions and positions of all rooms which are placed on a grid</param>
        private void RemoveDeadEnds(ref int[,] grid, List<RoomCells> roomCellsList)
        {
            List<int[]> toRemove = new List<int[]>();
            List<int> newValues = new List<int>();

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {
                        List<int[]> neighbours = new List<int[]>();
                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (j >= 0 && j < grid.GetLength(1))
                        {
                            if (i > 0)
                                if (grid[i - 1, j] == -1)
                                    neighbours.Add(new int[] { i - 1, j });
                            if (i < grid.GetLength(0) - 1)
                                if (grid[i + 1, j] == -1)
                                    neighbours.Add(new int[] { i + 1, j });
                        }
                        if (i >= 0 && i < grid.GetLength(0))
                        {
                            if (j > 0)
                                if (grid[i, j - 1] == -1)
                                    neighbours.Add(new int[] { i, j - 1 });
                            if (j < grid.GetLength(1) - 1)
                                if (grid[i, j + 1] == -1)
                                    neighbours.Add(new int[] { i, j + 1 });
                        }

                        if (neighbours.Count == 1)
                        {
                            //toRemove.Add(new int[] { i, j });
                            int iT = i;
                            int jT = j;

                            int iDelta = neighbours[0][0] - i;
                            int jDelta = neighbours[0][1] - j;


                            if (indexInRoomCellsList >= 0)
                                while (jT >= 0 && jT < grid.GetLength(1) && iT >= 0 && iT < grid.GetLength(0)
                                    && grid[iT, jT] == -1 && neighbours.Count <= 2
                                    && iT >= roomCellsList[indexInRoomCellsList].x && iT < roomCellsList[indexInRoomCellsList].x + roomCellsList[indexInRoomCellsList].w
                                && jT >= roomCellsList[indexInRoomCellsList].y && jT < roomCellsList[indexInRoomCellsList].y + roomCellsList[indexInRoomCellsList].h)
                                {
                                    toRemove.Add(new int[] { iT, jT });
                                    newValues.Add(indexInRoomCellsList + 1);
                                    iT += iDelta;
                                    jT += jDelta;

                                    neighbours = new List<int[]>();

                                    if (jT >= 0 && jT < grid.GetLength(1))
                                    {
                                        if (iT > 0)
                                            if (grid[iT - 1, jT] == -1)
                                                neighbours.Add(new int[] { iT - 1, jT });
                                        if (iT < grid.GetLength(0) - 1)
                                            if (grid[iT + 1, jT] == -1)
                                                neighbours.Add(new int[] { iT + 1, jT });
                                    }
                                    if (iT >= 0 && iT < grid.GetLength(0))
                                    {
                                        if (jT > 0)
                                            if (grid[iT, jT - 1] == -1)
                                                neighbours.Add(new int[] { iT, jT - 1 });
                                        if (jT < grid.GetLength(1) - 1)
                                            if (grid[iT, jT + 1] == -1)
                                                neighbours.Add(new int[] { iT, jT + 1 });
                                    }
                                }
                        }
                    }
                }

            for (int i = 0; i < toRemove.Count; i++)
                grid[toRemove[i][0], toRemove[i][1]] = newValues[i];
        }

        /// <summary>
        /// This function serves for removing all corridors from the corridor structure 
        /// after the main part of generation is executed already.
        /// Corridors are added to the area of corresponding rooms.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="roomCellsList"></param>
        private void RemoveAllCorridors(ref int[,] grid, List<RoomCells> roomCellsList)
        {

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {

                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (indexInRoomCellsList > -1)
                            grid[i, j] = indexInRoomCellsList + 1;
                    }
                }
        }

        /// <summary>
        /// Contains the whole solution that was once computed. It is used to
        /// store solutions which were generated during previous iterations.
        /// </summary>
        private class GridSolution
        {
            public int[,] grid;
            public List<RoomCells> roomCellsList = new List<RoomCells>();
            public List<int> placedRoomsOrderedList = new List<int>();

            public GridSolution(int[,] Grid, List<RoomCells> RoomCellsList, List<int> RoomOrder)
            {
                grid = Grid;
                roomCellsList = RoomCellsList.ConvertAll(roomCells => new RoomCells(roomCells));
                placedRoomsOrderedList = RoomOrder.ConvertAll(i => i);
            }
        }

        /// <summary>
        /// Returns a list of room numbers, which have missing adjacences.
        /// Later this information is used for indicating rooms which miss connections.
        /// It is indicated with red dots in Rhino environment.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="adjArray"></param>
        /// <returns></returns>
        public List<int> MissingRoomAdjacences(int[,] grid, int[,] adjArray)
        {
            List<int> missingAdj = new List<int>();// (adjArray.GetLength(0));
            int maxRoomNum = 0;
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                 if (grid[i,j] < 999)
                        maxRoomNum = Math.Max(maxRoomNum, grid[i, j]);

            //for (int i = 0; i < adjArray.GetLength(0); i++)
              //  maxRoomNum = 
                //maxRoomNum = Math.Max(Math.Max(maxRoomNum, adjArray[i, 0]), adjArray[i, 1]);

            for (int i = 0; i < maxRoomNum; i++)
                missingAdj.Add(0);

            for (int l = 0; l < adjArray.GetLength(0); l++)
            {
                bool exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 0])
                            exists = true;
                if (!exists) 
                    if (adjArray[l, 1] - 1 < missingAdj.Count)
                    missingAdj[adjArray[l, 1] - 1]++;


                exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 1])
                            exists = true;
                if (!exists)
                    if (adjArray[l, 0] - 1 < missingAdj.Count)
                        missingAdj[adjArray[l, 0] - 1]++;
            }

            return missingAdj;
        }

        /// <summary>
        /// This is the function which determines the position of a room and which 
        /// tries to place it. 
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="area"></param>
        /// <param name="roomNumber"></param>
        /// <param name="adjArray"></param>
        /// <param name="maxAdjDistance"></param>
        /// <param name="isHall"></param>
        /// <returns></returns>
        public bool TryPlaceNewRoomToTheGrid(ref int[,] grid, double area, int roomNumber, int[,] adjArray, double maxAdjDistance, bool isHall = false)
        {
            int[,] availableCellsGrid = new int[grid.GetLength(0), grid.GetLength(1)];  //= workingGrid;
            int[,] room = new int[50, 50];

            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == roomNumber && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == roomNumber && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);

            // Let's try to define proportions for the room considering its area and 
            // the requested ratio 
            double ratio = 1 + random.NextDouble() * (MaxRatio - 1);
            double xDim_d = Math.Sqrt((area / ratio));
            double yDim_d = ratio * Math.Sqrt((area / ratio));

            xDim = (int)Math.Round(xDim_d);
            //yDim = (int)Math.Floor(area / (int)xDim);
            yDim = (int)Math.Round(yDim_d);

            if (xDim == 0)
                xDim++;
            if (yDim == 0)
                yDim++;

            if (random.Next(2) == 0)
            {
                int temp = xDim;
                xDim = yDim;
                yDim = temp;
            }


            // Choose the corridor generation mode according to MenuItemDropDown selection
            if (oneSideCorridorsChecked && !isHall)
            {
                if (random.Next(2) == 0)
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        xDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim + 1, yDim];
                    for (int i = 0; i < xDim + 1; i++)
                        for (int j = 0; j < yDim; j++)
                            if (i == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNumber;
                }
                else
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        yDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim, yDim + 1];
                    for (int i = 0; i < xDim; i++)
                        for (int j = 0; j < yDim + 1; j++)
                            if (j == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNumber;
                }

            }
            else if (twoSidesCorridorsChecked && !isHall)
            {
                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim--;
                    yDim--;
                }

                if (xDim == 0)
                    xDim++;
                if (yDim == 0)
                    yDim++;


                room = new int[xDim + 1, yDim + 1];
                for (int i = 0; i < xDim + 1; i++)
                    for (int j = 0; j < yDim + 1; j++)
                        if (i == 0 || j == 0)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNumber;
            }
            else if (allSidesCorridorsChecked || isHall)
            {
                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim -= 2;
                    yDim -= 2;
                }

                if (xDim <= 0)
                    xDim = 1;
                if (yDim <= 0)
                    yDim = 1;


                room = new int[xDim + 2, yDim + 2];
                for (int i = 0; i <= xDim + 1; i++)
                    for (int j = 0; j <= yDim + 1; j++)
                        if (i == 0 || j == 0 || i == xDim + 1 || j == yDim + 1)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNumber;
            }

            // availableCellsGrid contains 0 or 1 and indicated if the cell is available 
            // for placing a room there.

            // Start filling availableCellsGrid: 0 = not available, 1 = available
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    availableCellsGrid[i, j] = 0;

                    // So, if we find a free cell in a grid, let's check that it one
                    // of its neighbours is a corridor cell (so the placed room will 
                    // be attached to the corridor structure). 
                    if (grid[i, j] == 0)
                        for (int l = -1; l <= 1; l++)
                            for (int k = -1; k <= 1; k++)
                                if ((l == 0 || k == 0) && l != k)
                                    if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))
                                        if (grid[i + l, j + k] == -1)
                                        {
                                            // If we found that kind of a cell, let's check that it is 
                                            // close enough to rooms (only those which are placed already)
                                            // that must be connected to the room that is to be placed.
                                            if (CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                                            {
                                                // If so, let's check this cell as suitable for placing a new room
                                                availableCellsGrid[i, j] = 1;
                                                // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "availableCell! " + roomNum + ": " + i + "_" + j);
                                            }
                                        }
                }

            // This list contains all possible solutions for a room placement. It means,
            // that for every suitable cell from availableCellsGrid the algorithm
            // tries to place the room in all different ways (RoomPosition contains 
            // these different orientations that a room can take). Then, solutions
            // that are successful are placed into this list.
            //
            // It is also important to mention, that each of these solutions gets its 
            // rating. It is calculated according to number of rooms that share a border with
            // this newly placed room. So we can be sure that there will be as few empty
            // spaces between rooms as possible.
            // For instance, if there are 2 options for a room position: one in which a room is
            // sharing one border with another room (so 3 other sides are naked), and the other one
            // in which a room is placed in a way that it shares 3 sides with other rooms (and only
            // one side is naked) -> the rating of the second solutions will obviously be higher.
            // This is how we ensure that the final solution will be as compact as possible.
            List<RoomPlacementSolution> placementSolutions = new List<RoomPlacementSolution>();

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {

                    if (availableCellsGrid[i, j] == 1)
                    {
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.BottomLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomLeft, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.BottomLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.BottomRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomRight, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.BottomRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.TopLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopLeft, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.TopLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceableHere(grid, room, i, j, RoomPosition.TopRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopRight, room
                                , GetRoomPlacementRating(grid, room, i, j, RoomPosition.TopRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                    }
                }

            // Let's order a list by rating
            placementSolutions = placementSolutions.OrderBy(t => -t.rating).ToList();

            if (placementSolutions.Count > 0)
            {
                int x = placementSolutions[0].x;
                int y = placementSolutions[0].y;
                int w = placementSolutions[0].room.GetLength(0);
                int h = placementSolutions[0].room.GetLength(1);

                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.TopLeft)
                    x -= w - 1;
                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.BottomRight)
                    y -= h - 1;

                roomCellsList[roomNumber - 1] = new RoomCells(x, y, w, h);


                // Finally, let's place a room where it should be placed! This line will do all work for us
                PlaceRoomSolution(placementSolutions[0], placementSolutions[0].room, ref grid, isHall);
                return true;
            }
            else
                return false;
        }
        
        /// <summary>
        /// Contains the dimensions and the origin of a room on a grid.
        /// </summary>
        private class RoomCells
        {
            public int x;
            public int y;
            public int w;
            public int h;

            public RoomCells() { }

            public RoomCells(int X, int Y, int W, int H)
            {
                x = X;
                y = Y;
                w = W;
                h = H;
            }

            public RoomCells(RoomCells roomCells)
            {
                x = roomCells.x;
                y = roomCells.y;
                w = roomCells.w;
                h = roomCells.h;
            }
        }

        private void RemoveRoomFromGrid(ref int[,] grid, RoomCells roomCells)
        {
            for (int i = roomCells.x; i < roomCells.x + roomCells.w; i++)
                for (int j = roomCells.y; j < roomCells.y + roomCells.h; j++)
                    grid[i, j] = 0;
        }

        /// <summary>
        /// Basically this function takes the RoomPlacementSolution and places it.
        /// It fills the corresponding cells of grid with the given room number.
        /// </summary>
        /// <param name="solution"></param>
        /// <param name="room"></param>
        /// <param name="grid"></param>
        /// <param name="isHall"></param>
        private void PlaceRoomSolution(RoomPlacementSolution solution, int[,] room, ref int[,] grid, bool isHall = false)
        {
            switch (solution.roomPosition)
            {
                case RoomPosition.TopRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[i - solution.x, j - solution.y];
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[i - solution.x, -(j - solution.y)];
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[-(i - solution.x), -(j - solution.y)];
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[-(i - solution.x), j - solution.y];
                    }
                    break;
            }
        }

        /// <summary>
        /// This function is fairly important.
        /// The rating is calculated according to number of rooms that share a border with
        /// this newly placed room. So we can be sure that there will be as few empty
        /// spaces between rooms as possible.
        /// 
        /// For instance, if there are 2 options for a room position: one in which a room is
        /// sharing one border with another room (so 3 other sides are naked), and the other one
        /// in which a room is placed in a way that it shares 3 sides with other rooms (and only
        /// one side is naked) -> the rating of the second solutions will obviously be higher.
        /// This is how we ensure that the final solution will be as compact as possible.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="room"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="roomPosition"></param>
        /// <returns></returns>
        private int GetRoomPlacementRating(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            int rating = 0;

            List<int> cellsToCheck = new List<int>();



            if (roomPosition == RoomPosition.BottomLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + 1]);

                    if (x - i >= 0 && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y - j >= 0)
                        cellsToCheck.Add(grid[x + 1, y - j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.BottomRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + 1]);

                    if (x + i < grid.GetLength(0) && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - 1, y - j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y - j > 0)
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.TopLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - 1]);

                    if (x - i >= 0 && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + 1, y + j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y + j]);
                }
            }

            if (roomPosition == RoomPosition.TopRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - 1]);

                    if (x + i < grid.GetLength(0) && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - 1, y + j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y + j]);
                }
            }

            foreach (int a in cellsToCheck)
                if (a != 0 && a != 9999)
                    rating++;

            return rating;
        }

        /// <summary>
        /// This one is simple, it contains the room placement solution as well as 
        /// rating of the room.
        /// </summary>
        private class RoomPlacementSolution
        {
            public RoomPlacementSolution(int roomX, int roomY, RoomPosition position, int[,] mRoom, int mScore)
            {
                x = roomX;
                y = roomY;
                roomPosition = position;
                this.rating = mScore;
                this.room = mRoom.Clone() as int[,];
            }

            public RoomPlacementSolution(RoomPlacementSolution a)
            {
                x = a.x;
                y = a.y;
                roomPosition = a.roomPosition;
                this.rating = a.rating;
                this.room = a.room.Clone() as int[,];
            }

            public int GetRoomNum()
            {
                int max = -1;
                for (int i = 0; i < room.GetLength(0); i++)
                    for (int j = 0; j < room.GetLength(1); j++)
                        max = Math.Max(max, room[i, j]);
                return max;
            }

            public RoomPosition roomPosition;
            public int rating = 0;
            public int x;
            public int y;
            public int[,] room;
        }

        private enum RoomPosition { TopRight, BottomRight, BottomLeft, TopLeft, Undefined }

        /// <summary>
        /// This function checks that the given room with the given RoomPosition
        /// can be successfully placed on the grid. So if all cells that this room
        /// will want to occupy are free (0), it will return true.
        /// </summary>
        /// <param name="grid"></param>
        /// <param name="room"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="roomPosition"></param>
        /// <returns></returns>
        private bool RoomIsPlaceableHere(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            switch (roomPosition)
            {
                case RoomPosition.TopRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (x - room.GetLength(0) >= 0 && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (x - room.GetLength(0) >= 0 && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

            }
            return false;
        }


        /// <summary>
        /// IntPair generally is used for saving {(room number in the initialRoomsList) + 1, room priority}
        /// </summary>
        public struct IntPair
        {
            public IntPair(int a1, int b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }

            public IntPair(int a1, double b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }
            public int roomNumber;
            public double AdjNum;
        }


        public bool CellsAreNearerThan(int x, int y, List<int> targetCellsList, int[,] grid, double maxDistance = 2)
        {
            foreach (int targetCell in targetCellsList)
            {
                if (!CellIsNearerThan(x, y, targetCell, grid, maxDistance))
                    return false;
            }
            return true;
        }

        public bool CellIsNearerThan(int x, int y, int targetCellNumber, int[,] grid, double maxDistance = 2)
        {
            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;
                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;
            availabilityGrid[x, y] = true;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);


            int minX = -1;
            int minY = -1;
            double minTargetDist = -1;

            for (int i = 0; i < availabilityGrid.GetLength(0); i++)
                for (int j = 0; j < availabilityGrid.GetLength(1); j++)
                {
                    if (grid[i, j] == targetCellNumber)
                        if ((distanceGrid[i, j] < minTargetDist || minTargetDist == -1) && distanceGrid[i, j] > 0)
                        {
                            minTargetDist = distanceGrid[i, j];
                            minX = i;
                            minY = j;
                        }
                }

            if (minTargetDist != -1 && minTargetDist <= maxDistance)
                return true;
            else
                return false;
        }

        public void SetCellDistancesAround(int x, int y, ref double[,] distanceGrid, ref bool[,] availabilityGrid, double maxDist)
        {
            List<List<int>> recursionList = new List<List<int>>();


            for (int i = -1; i <= 1; i++)
                for (int j = -1; j <= 1; j++)
                {
                    if (x + i >= 0 && x + i < distanceGrid.GetLength(0) &&
                        y + j >= 0 && y + j < distanceGrid.GetLength(1))
                        if (!(i == 0 && j == 0))
                        {
                            double addValue;
                            if (i * j != 0) //if the cell is corner cell
                                addValue = 1.414f; //sqrt(2)
                            else
                                addValue = 1;

                            if (availabilityGrid[x, y])
                                if (distanceGrid[x + i, y + j] > distanceGrid[x, y] + addValue || distanceGrid[x + i, y + j] == -1)
                                {
                                    distanceGrid[x + i, y + j] = distanceGrid[x, y] + addValue;
                                    if (distanceGrid[x + i, y + j] <= maxDist)
                                        recursionList.Add(new List<int>() { x + i, y + j });
                                }
                        }
                }
            // doesnt really affect performance
            foreach (List<int> item in recursionList)
                SetCellDistancesAround(item[0], item[1], ref distanceGrid, ref availabilityGrid, maxDist);

            return;
        }
        
        public bool GridContains(int[,] grid, int val)
        {
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                    if (grid[i, j] == val)
                        return true;
            return false;
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        
        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                return Properties.Resources.MagnetizingRoomsIcon;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{78fe6801-611b-453f-946a-2fda951393eb}"); }
        }


        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "One-side corridors", Menu_OneSideCorClick, true, oneSideCorridorsChecked);
            Menu_AppendItem(menu, "Two-sides corridors", Menu_TwoSidesCorClick, true, twoSidesCorridorsChecked);
            Menu_AppendItem(menu, "All-sides corridors", Menu_AllSidesCorClick, true, allSidesCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Remove Dead Ends", Menu_RemoveDeadEndsClick, true, removeDeadEndsChecked);
            Menu_AppendItem(menu, "Remove All Corridors", Menu_RemoveAllCorridorsClick, true, removeAllCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Corridors as additional spaces", Menu_CorridorsAsAdditionalSpacesChecked, true, corridorsAsAdditionalSpacesChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Boundary offset:", (obj, e) => { }, false);
            Menu_AppendTextItem(menu, boundaryOffset.ToString()
               , (obj, e) => { }, Menu_ChangeBoundaryOffsetNumberChanged, false);

            base.AppendAdditionalComponentMenuItems(menu);
        }


        public void Menu_ChangeBoundaryOffsetNumberChanged(object sender, string text)
        {
            try
            {
                this.boundaryOffset = Double.Parse(text);
            }
            catch (Exception) { }

            //this.ExpireSolution(false);
        }

        public void Menu_ChangeBoundaryOffsetNumberPressed(object sender, EventArgs e)
        {
            this.ExpireSolution(false);
        }

        public void Menu_CorridorsAsAdditionalSpacesChecked(object sender, EventArgs e)
        {
            corridorsAsAdditionalSpacesChecked = !corridorsAsAdditionalSpacesChecked;
            this.ExpireSolution(false);
        }

       

        public void Menu_RemoveDeadEndsClick(object sender, EventArgs e)
        {
            removeDeadEndsChecked = !removeDeadEndsChecked;

            if (removeDeadEndsChecked)
                removeAllCorridorsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(false);
        }

        public void Menu_RemoveAllCorridorsClick(object sender, EventArgs e)
        {
            removeAllCorridorsChecked = !removeAllCorridorsChecked;
            if (removeAllCorridorsChecked)
                removeDeadEndsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(false);
        }

        public void Menu_OneSideCorClick(object sender, EventArgs e)
        {
            if (!oneSideCorridorsChecked)
            {
                oneSideCorridorsChecked = !oneSideCorridorsChecked;

                twoSidesCorridorsChecked = !oneSideCorridorsChecked;
                allSidesCorridorsChecked = !oneSideCorridorsChecked;

                ExpireSolution(false);
            }
        }

        public void Menu_TwoSidesCorClick(object sender, EventArgs e)
        {
            if (!twoSidesCorridorsChecked)
            {
                twoSidesCorridorsChecked = !twoSidesCorridorsChecked;

                oneSideCorridorsChecked = !twoSidesCorridorsChecked;
                allSidesCorridorsChecked = !twoSidesCorridorsChecked;

                ExpireSolution(false);
            }
        }

        public void Menu_AllSidesCorClick(object sender, EventArgs e)
        {
            if (!allSidesCorridorsChecked)
            {
                allSidesCorridorsChecked = !allSidesCorridorsChecked;

                oneSideCorridorsChecked = !allSidesCorridorsChecked;
                twoSidesCorridorsChecked = !allSidesCorridorsChecked;

                ExpireSolution(false);
            }
        }
    }
}

<./Magnetizing_FPG\SpringSystem_ES.cs>
﻿using System;
using System.Collections.Generic;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System.Linq;
using Rhino;
using ClipperLib;

using Path = System.Collections.Generic.List<ClipperLib.IntPoint>;
using Paths = System.Collections.Generic.List<System.Collections.Generic.List<ClipperLib.IntPoint>>;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;

namespace Magnetizing_FPG
{
    public class SpringSystem_ES : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public SpringSystem_ES()
          : base("SpringSystem_ES", "SpringSystem_ES",
              "Evolutionary Strategy + SpringSystem",
              "Magnetizing_FPG", "Magnetizing_FPG")
        {
        }

        private List<Curve> rooms = new List<Curve>();
        private List<Curve> originalInputRooms = new List<Curve>();
        private List<Curve> currentInputRooms = new List<Curve>();
        List<string> adjStrList;
        private Random random = new Random();
        double proportionThreshold = 0;
        GeneCollection geneCollection;
        double boundaryArea = 0;
        bool Menu_ShuffleRoomsAtFirst = false;


        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms as curves", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacencies", "Adjacencies", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, " - ");
            pManager.AddNumberParameter("ProportionThreshold", "ProportionThreshold", "ProportionThreshold, >= 1", GH_ParamAccess.item, 2);
            pManager.AddNumberParameter("FF Balance", "FF Balance", "FF Balance\n[0,1]", GH_ParamAccess.item, 0);
            pManager.AddBooleanParameter("SpringCollAllGenes", "SpringCollAllGenes", "Spring collisions in all genes, not only in the best one. " +
                "It makes execution slower, but provides much better results, because every gene is getting better faster and they compete" +
                "with each other more honestly", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("AdjustArea", "AdjustArea", "Adjust sum of rooms areas to the area of the boundary.", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Reset", "Reset", "Reset", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddLineParameter("Adjacencies", "Adjacences", "Adjacence lines", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            Curve boundary = new PolylineCurve();
            bool shouldInstantiateRooms = false;
            adjStrList = new List<string>();
            List<Line> adjLines = new List<Line>();
            bool shouldClearGenes = false;
            bool springCollAllGenes = false;
            bool adjustArea = false;
            
            DA.GetData("Reset", ref shouldInstantiateRooms);
            DA.GetData("Boundary", ref boundary);

            currentInputRooms.Clear();
            DA.GetDataList(1, currentInputRooms);

            if (shouldInstantiateRooms || rooms.Count == 0 || boundaryArea != AreaMassProperties.Compute(boundary).Area
                || originalInputRooms == null || !RoomListsAreEqual(originalInputRooms, currentInputRooms))
            {
                shouldClearGenes = true;
                boundaryArea = AreaMassProperties.Compute(boundary).Area;
                rooms.Clear();
                originalInputRooms.Clear();
                DA.GetDataList(1, rooms);
                DA.GetDataList(1, originalInputRooms);
            }

            DA.GetData("ProportionThreshold", ref proportionThreshold);
            DA.GetData("FF Balance", ref Gene.fitnessFunctionBalance);
            DA.GetDataList("Adjacencies", adjStrList);
            DA.GetData("SpringCollAllGenes", ref springCollAllGenes);
            DA.GetData("AdjustArea", ref adjustArea);
            
            int[,] adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            Gene.proportionThreshold = proportionThreshold;
            Gene.adjacencyList = adjArray;

            if (shouldClearGenes)
            {
                // Adapt the summarized rooms area to the boundary area if it is needed
                if (adjustArea)
                {
                    double roomSumArea = 0;
                    foreach (Curve room in rooms)
                        roomSumArea += AreaMassProperties.Compute(room).Area;

                    foreach (Curve room in rooms)
                        room.Transform(Transform.Scale(room.GetBoundingBox(false).Center, Math.Sqrt(boundaryArea / roomSumArea)));// AreaMassProperties.Compute(room).Area;

                }

                shouldClearGenes = false;
                geneCollection = new GeneCollection(15, boundary);

                // Let's create some starting genes
                foreach (Gene gene in geneCollection.genes)
                    if (Menu_ShuffleRoomsAtFirst)
                        gene.InstantiateRandomly(rooms);
                    else
                        gene.Instantiate(rooms);
            }

            
            geneCollection.Iterate();

            if (springCollAllGenes)
                for (int l = 0; l < geneCollection.genes.Count; l++)
                {
                    Gene gene = geneCollection.genes[l];
                    rooms = gene.GetCurves();

                    rooms = CollisionDetectionMain(rooms, boundary);

                    gene.collection.Clear();
                    gene.Instantiate(rooms);
                }


            rooms = geneCollection.GetBest();
            AdjacentContraction(rooms, adjStrList, boundary, out adjLines);

            List<GH_Curve> GH_rooms = new List<GH_Curve>();
            foreach (Curve c in rooms)
                GH_rooms.Add(new GH_Curve(c));

            DA.SetDataList(0, GH_rooms);
            DA.SetDataList(1, adjLines);
        }

        protected bool RoomListsAreEqual(List<Curve> a, List<Curve> b)
        {
            if (a == null || b == null)
                return false;
            if (a.Count != b.Count)
                return false;
            for (int i = 0; i < a.Count; i++)
            {
                Vector3d differenceV = a[i].GetBoundingBox(false).Center - b[i].GetBoundingBox(false).Center;
                if (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y) > 0.001f)
                {
                    //AddRuntimeMessage(GH_RuntimeMessageLevel.Error, (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y).ToString()));
                    return false;
                }
            }

            return true;
        }

        protected List<Curve> CopyCurveList(List<Curve> a)
        {
            List<Curve> output = new List<Curve>();
            foreach (Curve curve in a)
                output.Add(curve.DuplicateCurve());

            return output;
        }

        private List<Curve> CollisionDetectionMain(List<Curve> roomCurves, Curve boundary)
        {
            List<int> indexes = new List<int>();
            for (int i = 0; i < roomCurves.Count; i++)
                indexes.Add(i);


            // Check roomCurves[i] and roomCurves[j] intersection
            // Then let's move both rooms by 1/2 of the rebounding vector
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];

                for (int j = i + 1; j < roomCurves.Count; j++)

                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], roomCurves[j]);

                    if (intersectResult.intersect)
                    {
                        if (intersectResult.reboundingVector.X != 0)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[j].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));
                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(intersectResult.reboundingVector.X / 2, 0, 0));
                                roomCurves[j].Translate(new Vector3d(-intersectResult.reboundingVector.X / 2, 0, 0));

                            }
                        }
                        else
                        {
                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2]
                            // Else - change the position of the rooms
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(0, intersectResult.reboundingVector.Y / 2, 0));
                                roomCurves[j].Translate(new Vector3d(0, -intersectResult.reboundingVector.Y / 2, 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], roomCurves[j], Plane.WorldXY, 0.0001f) != RegionContainment.Disjoint)
                        {
                            BoundingBox aRoomBB = roomCurves[j].GetBoundingBox(false);
                            BoundingBox bRoomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).X) - (aRoomBB.Diagonal.X / 2 - bRoomBB.Diagonal.X / 2);
                            double yDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).Y) - (aRoomBB.Diagonal.Y / 2 - bRoomBB.Diagonal.Y / 2);
                            if (xDist > yDist)
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist - bRoomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist + bRoomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist - bRoomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist + bRoomBB.Diagonal.Y, 0));
                            }
                        }
                    }

                }
            }


            // Check roomCurves[i] and boundary intersection
            // Let's do it twice to be sure that X and Y positions are both defined perfectly
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];
                for (int t = 0; t < 1; t++)
                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], boundary);

                    if (intersectResult.intersect)
                    {
                        double boundaryProportionThreshold = 1;// proportionThreshold;

                        if (Math.Abs(intersectResult.reboundingVector.X) > 0.01f)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d((intersectResult.reboundingVector.X > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.X - Math.Abs(intersectResult.reboundingVector.X)), 0, 0));
                            }
                        }
                        else if (Math.Abs(intersectResult.reboundingVector.Y) > 0.01f)
                        { // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d(0, (intersectResult.reboundingVector.Y > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.Y - Math.Abs(intersectResult.reboundingVector.Y)), 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], boundary, Plane.WorldXY, 0.0001f) != RegionContainment.AInsideB)
                        {
                            BoundingBox boundaryBB = boundary.GetBoundingBox(false);
                            BoundingBox roomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((boundaryBB.Center - roomBB.Center).X) - boundaryBB.Diagonal.X / 2 - roomBB.Diagonal.X / 2;
                            double yDist = Math.Abs((boundaryBB.Center - roomBB.Center).Y) - boundaryBB.Diagonal.Y / 2 - roomBB.Diagonal.Y / 2;
                            if (xDist > yDist)
                            {
                                if ((boundaryBB.Center - roomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist + roomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist - roomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((boundaryBB.Center - roomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist + roomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist - roomBB.Diagonal.Y, 0));
                            }
                        }
                    }
                }
            }
            return roomCurves;
        }

        public PolylineCurve PathToPolyline(Path path, int clipperPrecision = 100)
        {
            List<Point3d> points = new List<Point3d>();
            foreach (IntPoint intPoint in path)
                points.Add(new Point3d(intPoint.X / (double)clipperPrecision, intPoint.Y / (double)clipperPrecision, 0));
            PolylineCurve polyline = new PolylineCurve(points);

            return polyline;
        }

        public Path CurveToPath(Curve curve, int clipperPrecision = 100)
        {
            Path points = new Path();

            for (int i = 0; i < 4; i++)
                points.Add(new IntPoint((int)(curve.GetBoundingBox(false).GetCorners()[i].X * clipperPrecision),
                    (int)(curve.GetBoundingBox(false).GetCorners()[i].Y * clipperPrecision)));

            return points;
        }

        private IntersectResult Intersect2Curves(Curve a, Curve b)
        {
            int clipperPrecision = 100;
            IntersectResult result = new IntersectResult();
            if (Curve.PlanarCurveCollision(a, b, Plane.WorldXY, 0.001f))
            {
                Clipper clipper = new Clipper();
                Path subjectA = CurveToPath(a, clipperPrecision);
                Path subjectB = CurveToPath(b, clipperPrecision);
                Paths solution = new Paths();

                clipper.AddPath(subjectA, PolyType.ptClip, true);
                clipper.AddPath(subjectB, PolyType.ptSubject, true);

                clipper.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                if (solution.Count > 0)
                {
                    result.intersect = true;
                    PolylineCurve pl = PathToPolyline(solution[0], clipperPrecision);
                    result.unionCurve = pl;

                    Point3d minPoint = pl.GetBoundingBox(false).Min;
                    Point3d maxPoint = pl.GetBoundingBox(false).Max;

                    if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                    {
                        result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                        if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                            result.reboundingVector.Y *= -1;
                    }
                    else
                    {
                        result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                        if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                            result.reboundingVector.X *= -1;
                    }

                }
            }
            else
            {
                result.intersect = false;
                result.reboundingVector = Vector2d.Unset;
                result.unionCurve = null;
            }
            return result;
        }

        private struct IntersectResult
        {
            public Vector2d reboundingVector;
            public bool intersect;
            public Curve unionCurve;
        }

        private double GetRoomXYProportion(Curve room)
        {
            return (room.GetBoundingBox(false).Diagonal.X / (double)room.GetBoundingBox(false).Diagonal.Y);
        }


        private void Shuffle(ref List<Curve> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                Curve value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<string> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private List<Curve> AdjacentContraction(List<Curve> roomCurves, List<string> adjacenceStrings, Curve boundary, out List<Line> adjLines)
        {

            List<Adjacence> adjacences = new List<Adjacence>();

            foreach (string adjString in adjacenceStrings)
            {
                adjacences.Add(new Adjacence());
                adjacences[adjacences.Count - 1].aIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjacences[adjacences.Count - 1].bIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            foreach (Adjacence adj in adjacences)
            {
                Vector3d attractVector = roomCurves[adj.aIndex].GetBoundingBox(false).Center - roomCurves[adj.bIndex].GetBoundingBox(false).Center;

                Vector3d aDim = roomCurves[adj.aIndex].GetBoundingBox(false).Diagonal;
                Vector3d bDim = roomCurves[adj.bIndex].GetBoundingBox(false).Diagonal;

                if (Math.Abs(attractVector.X) - (aDim.X + bDim.X) / 2 > 0.001f ||
                    Math.Abs(attractVector.Y) - (aDim.Y + bDim.Y) / 2 > 0.001f)
                {

                    if (Math.Abs(attractVector.X) > Math.Abs(attractVector.Y))
                    {
                        attractVector.Y = 0;
                        aDim.Y = 0;
                        bDim.Y = 0;
                    }
                    else
                    {
                        attractVector.X = 0;
                        aDim.X = 0;
                        bDim.X = 0;
                    }

                    Point3d attractCenter = roomCurves[adj.aIndex].GetBoundingBox(false).Center + attractVector / 2;
                    if (attractVector.X != 0)
                        if (attractCenter.X > roomCurves[adj.aIndex].GetBoundingBox(false).Center.X)
                            bDim *= -1;
                        else
                            aDim *= -1;
                    else
                        if (attractCenter.Y > roomCurves[adj.aIndex].GetBoundingBox(false).Center.Y)
                        bDim *= -1;
                    else
                        aDim *= -1;


                    // roomCurves[adj.aIndex].Translate(-attractVector / 2 + aDim / 2);
                    // roomCurves[adj.bIndex].Translate(attractVector / 2 + bDim / 2);
                }
            }

            adjLines = new List<Line>();

            foreach (Adjacence adj in adjacences)
            {
                adjLines.Add(new Line(roomCurves[adj.aIndex].GetBoundingBox(false).Center, roomCurves[adj.bIndex].GetBoundingBox(false).Center));
            }

            return roomCurves;
        }

        private class Adjacence
        {
            public int aIndex;
            public int bIndex;
        }

        public class Room
        {
            public double CenterX = 0;
            public double CenterY = 0;

            public double width = 0;
            // height is used as a getter/setter function, so this variable doesn't exist actually

            public double area = 0;

            public Room(double CenterX, double CenterY, double width, double height)
            {
                this.CenterX = CenterX;
                this.CenterY = CenterY;
                this.width = width;
                this.area = width * height;
            }

            public Room()
            {
            }

            public Room(Point3d centerPoint, double width, double height)
            {
                this.CenterX = centerPoint.X;
                this.CenterY = centerPoint.Y;
                this.width = width;
                this.area = width * height;
            }

            public Room(Curve roomCurve)
            {
                this.CenterX = roomCurve.GetBoundingBox(false).Center.X;
                this.CenterY = roomCurve.GetBoundingBox(false).Center.Y;
                this.width = roomCurve.GetBoundingBox(false).Diagonal.X;
                this.area = roomCurve.GetBoundingBox(false).Diagonal.X * roomCurve.GetBoundingBox(false).Diagonal.Y;
            }

            // IMPORTANT: think about what precision means
            public Path GetClipperLibPath(int precision = 100)
            {

                IntPoint a = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY - height / 2) * precision));
                IntPoint b = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint c = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint d = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY - height / 2) * precision));

                Path output = new Path(new List<IntPoint>() { a, b, c, d });
                return output;
            }

            public Room Clone()
            {
                Room r = new Room(CenterX, CenterY, width, this.height);
                return r;
            }

            public double height
            {
                get
                {
                    return area / width;
                }
                set
                {
                    width = area / value;
                }
            }

        }

        public class Gene
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Room> collection = new List<Room>();
            public static int[,] adjacencyList;// = new int[0, 2];
            public static Curve boundary;
            public static double proportionThreshold = 2f;
            public static double fitnessFunctionBalance = 0.5f;


            public Gene(int[,] adjacences)
            {
                adjacencyList = adjacences;
            }

            public Gene()
            {
            }

            public double FitnessFunctionG()
            {
                // return 3;
                double fitnessFunctionVar = 0;
                int precision = 100;

                Clipper cc = new ClipperLib.Clipper();

                Paths solution = new Paths();
                Paths subjects = new Paths();
                Paths clips = new Paths();



                foreach (Room room in collection)
                    subjects.Add(new Path(room.GetClipperLibPath(precision)));

                IntPoint boundaryA = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryB = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryC = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryD = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));


                clips.Add(new Path(new List<IntPoint>() { boundaryA, boundaryB, boundaryC, boundaryD }));

                cc.AddPaths(subjects, PolyType.ptSubject, true);
                cc.AddPaths(clips, PolyType.ptClip, true);


                cc.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                foreach (Path path in solution)
                {
                    fitnessFunctionVar += Clipper.Area(path);
                }


                return fitnessFunctionVar;
            }

            public double FitnessFunctionT()
            {
                double distanceSum = 0;
                for (int i = 0; i < adjacencyList.GetLength(0); i++)
                {
                    Room a = collection[adjacencyList[i, 0]].Clone();
                    Room b = collection[adjacencyList[i, 1]].Clone();

                    double distX = Math.Abs(a.CenterX - b.CenterX) - a.width / 2f - b.width / 2f;
                    double distY = Math.Abs(a.CenterY - b.CenterY) - a.height / 2f - b.height / 2f;

                    distanceSum += Math.Max(Math.Abs(distX), Math.Abs(distY));
                }
                return distanceSum;
            }

            public double FitnessFunction()
            {
                return (FitnessFunctionG() * fitnessFunctionBalance + 1 / (FitnessFunctionT()) * (1 - fitnessFunctionBalance));
            }

            public Gene Clone()
            {
                List<Room> newColl = new List<Room>(collection);
                Gene t = new Gene();
                // t.collection = newColl;
                foreach (Room r in collection)
                    t.collection.Add(r.Clone());

                return t;
            }

            public void InstantiateRandomly(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));

                    // set width
                    collection[collection.Count - 1].width = Math.Sqrt(collection[collection.Count - 1].area
                        / proportionThreshold) + random.NextDouble()
                        * (Math.Sqrt(collection[collection.Count - 1].area * proportionThreshold)
                        - Math.Sqrt(collection[collection.Count - 1].area / proportionThreshold));

                    // set X and Y
                    collection[collection.Count - 1].CenterX = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.X - collection[collection.Count - 1].width)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).X
                     + collection[collection.Count - 1].width / 2;

                    collection[collection.Count - 1].CenterY = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.Y - collection[collection.Count - 1].height)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).Y
                        + collection[collection.Count - 1].height / 2;
                }
            }

            public Gene Instantiate(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));
                }
                return this;
            }

            public List<Curve> GetCurves()
            {
                List<Curve> curvesList = new List<Curve>();
                foreach (Room room in collection)
                {
                    curvesList.Add(new Rectangle3d(new Plane(new Point3d(room.CenterX - room.width / 2, room.CenterY - room.height / 2, 0), Vector3d.ZAxis), room.width, room.height).ToNurbsCurve());
                }
                return curvesList;
            }

            public void MutateSomehow()
            {
                double mutationProb = 0.3f;
                double mutationChangeK = 0.2f; // (boundary.width or .height or ... ) * mutationChangeK = max change
                foreach (Room room in collection)
                {
                    if (random.NextDouble() < mutationProb)
                    {
                        if (random.NextDouble() < mutationProb)
                            room.CenterX += boundary.GetBoundingBox(false).Diagonal.X * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.CenterY += boundary.GetBoundingBox(false).Diagonal.Y * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.width = Math.Sqrt(room.area / proportionThreshold) + random.NextDouble()
                                * (Math.Sqrt(room.area * proportionThreshold) - Math.Sqrt(room.area / proportionThreshold));

                        // Check whether the room is outside the boundary

                        if (room.CenterX - room.width / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(true, true, true).X + room.width / 2;

                        if (room.CenterX + room.width / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(false, false, false).X - room.width / 2;

                        if (room.CenterY - room.height / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(true, true, true).Y + room.height / 2;

                        if (room.CenterY + room.height / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(false, false, false).Y - room.height / 2;
                    }
                }
            }

        }

        /// <summary>
        /// This class serves for containing the collection of genes and doing
        /// some operations with them (sorting, iterating,..).
        /// </summary>
        public class GeneCollection
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Gene> genes;
            int genesNumber;

            public GeneCollection(int genesNumber, Curve boundary)
            {
                Gene.boundary = boundary;
                this.genesNumber = genesNumber;
                genes = new List<Gene>();
                for (int i = 0; i < genesNumber; i++)
                    genes.Add(new Gene());
            }

            public void SortGenes()
            {
                genes = genes.OrderBy(i => -i.FitnessFunction()).ToList();

            }

            /// <summary>
            /// Well, so this function produces new genes via mutations, cross-over and 
            /// generating new ones.
            /// </summary>
            public void Iterate()
            {
                double newGenesNumK = 4;
                // mutations + cross-over + newbies

                #region CROSS-OVER
                int[,] mutationIndexes = new int[(int)(genesNumber * newGenesNumK), 2];
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    mutationIndexes[i, 0] = random.Next(genesNumber);
                    mutationIndexes[i, 1] = random.Next(genesNumber);
                }

                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    genes.Add(CrossOverGenes(genes[mutationIndexes[i, 0]], genes[mutationIndexes[i, 1]]));
                }

                #endregion

                #region MUTATION
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    Gene mutGene = genes[random.Next(0, genes.Count)].Clone();

                    mutGene.MutateSomehow();
                    genes.Add(mutGene);
                }
                #endregion

                #region NEWBIES
                for (int i = 0; i < genesNumber * newGenesNumK; i++)
                {
                    Gene newGene = new Gene();
                    newGene.InstantiateRandomly(genes[0].GetCurves());
                    genes.Add(newGene);
                }
                #endregion

                SortGenes();
                genes.RemoveRange(genesNumber, genes.Count - 1 - genesNumber);

            }

            private Gene CrossOverGenes(Gene a, Gene b)
            {
                double mutationProb = 0.5f;
                Gene c = a.Clone();

                for (int i = 0; i < a.collection.Count; i++)
                    if (random.NextDouble() > mutationProb)
                        c.collection[i] = b.collection[i].Clone();

                return c;
            }

            public List<Curve> GetBest()
            {
                SortGenes();
                return genes[0].GetCurves();
            }
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                return Resources.SpringSystem_ESIcon;
            }
        }

        /// <summary>
        /// When Menu_ShuffleRoomsAtFirstChecked, in the very beginning of algorithm's work
        /// all the rooms will be shuffled randomly.  It serves for producing various results.
        /// But when SpringSystem_ES component takes results from MagnetizingRooms_ES, rooms 
        /// already have their approximate position and, therefore, must not be shuffled.
        /// (initially Menu_ShuffleRoomsAtFirstChecked = false)
        /// </summary>
        /// <param name="menu"></param>
        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {

            Menu_AppendItem(menu, "Shuffle rooms at first", Menu_ShuffleRoomsAtFirstChecked, true, Menu_ShuffleRoomsAtFirst);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        public void Menu_ShuffleRoomsAtFirstChecked(object sender, EventArgs e)
        {
            Menu_ShuffleRoomsAtFirst = !Menu_ShuffleRoomsAtFirst;
            this.ExpireSolution(true);
        }

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{7b02cbd7-910f-47cf-9601-348f8a214506}"); }
        }
    }
}


<./Magnetizing_FPG\RoomProgram\HouseInstance.cs>
﻿using System;
using System.Collections.Generic;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    /* HouseInstance class contains all the information about one
     * instance of a set of rooms that belong to one house/storey.
     */

    public class HouseInstance : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the HouseInstance class.
        /// </summary>
        public HouseInstance()
          : base("HouseInstance", "HouseInstance",
              "HouseInstance",
             "Magnetizing_FPG", "Magnetizing_FPG")
        {
            adjStrList = new List<string>();
            m_attributes = new HouseInstanceAttributes(this);

        }

        public string HouseName = "HouseName";
        public string FloorName = "HouseFloor";
        public Curve boundary;
        public int[,] adjArray;
        public Point3d startingPoint;
        public List<string> adjStrList = new List<string>();
        public bool tryRotateBoundary = false;

        public List<string> RoomInstancesGuids
        {
            get { return (m_attributes as HouseInstanceAttributes).roomInstancesGuidList; }
            //  set { }
        }
        public List<RoomInstance> RoomInstances
        {
            get {
                List<RoomInstance> list = new List<RoomInstance>();
                foreach (string guid in (m_attributes as HouseInstanceAttributes).roomInstancesGuidList)
                    if (guid != "")
                    list.Add(OnPingDocument().FindComponent(new Guid(guid)) as RoomInstance);
                return list;
            }
            //  set { }
        }

        public override void CreateAttributes()
        {
            m_attributes = new HouseInstanceAttributes(this);
        }
        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "B", "Boundary", GH_ParamAccess.item);
            pManager.AddPointParameter("Entrance Point", "EP", "Entrance Point", GH_ParamAccess.item);
        }


        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("HouseInstance", "HI", "HouseInstance", GH_ParamAccess.item);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            adjStrList = new List<string>();
            List<string> roomNames = new List<string>();

            (m_attributes as HouseInstanceAttributes).AddPrevioslyConnectedRooms();

            DA.GetData(0, ref boundary);
            try
            {
                DA.GetData(1, ref startingPoint);
            }
            catch (Exception) { }


            for (int i = 0; i < RoomInstances.Count; i++)
            {
                for (int j = 0; j < RoomInstances[i].AdjacentRoomsList.Count; j++)
                    if (i + 1 < (RoomInstances.FindIndex(item => item.RoomId == (RoomInstances[i].AdjacentRoomsList[j] as RoomInstance).RoomId) + 1))
                        adjStrList.Add((i + 1) + " - " + (RoomInstances.FindIndex(item => item.RoomId == (RoomInstances[i].AdjacentRoomsList[j] as RoomInstance).RoomId) + 1) + "\n");


                roomNames.Add(RoomInstances[i].RoomName);
            }

            adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            DA.SetData(0, this);
        }


        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return Resources.HouseInstanceIcon;
            }
        }

        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            /// If checked, boundary will be rotated in such a way that it is 
            /// easier to pack rectangular rooms inside it. After algorithm is 
            /// executed, the boundary is rotated back to initial state.
            Menu_AppendItem(menu, "Try Rotate Boundary", Menu_TryRotateBoundaryClick, true, tryRotateBoundary);

            base.AppendAdditionalComponentMenuItems(menu);
        }
        protected void Menu_TryRotateBoundaryClick(object sender, EventArgs e)
        {
            tryRotateBoundary = !tryRotateBoundary;
            this.ExpireSolution(false);
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{9fb8241c-27d0-4683-9964-26c181c9ce36}"); }
        }
    }
}

<./Magnetizing_FPG\RoomProgram\HouseInstanceAttributes.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Reflection;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class HouseInstanceAttributes : GH_ComponentAttributes, IRoomStructure<IGH_DocumentObject>
    {

        public HouseInstanceAttributes(HouseInstance param) : base(param)
        {            
            random = new Random(Guid.NewGuid().GetHashCode());
            houseBrush = PickBrush();
            roomInstancesGuidList = new List<string>();
            strArray = new string[] { };

        }

        private Brush PickBrush()
        {
            List<Brush> brushes = new List<Brush>
            {
                Brushes.Aqua,
                Brushes.Bisque,
                Brushes.BlanchedAlmond,
                Brushes.DarkViolet,
                Brushes.LemonChiffon,
                Brushes.LightBlue,
                Brushes.LightCyan,
                Brushes.LightGreen,
                Brushes.LightSkyBlue,
                Brushes.Olive,
                Brushes.Orange,
                Brushes.PaleGreen,
                Brushes.Peru,
                Brushes.PeachPuff,
                Brushes.Purple,
                Brushes.Salmon,
                Brushes.SlateBlue,
                Brushes.Yellow,
                Brushes.YellowGreen
            };


            return brushes[random.Next(brushes.Count)];
        }

        public GH_Capsule FloorName;//= GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, p);
        public GH_Capsule HouseName;//= GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, "RoomName");

        Rectangle FloorNameRectangle;
        Rectangle HouseNameRectangle;

        const int InflateAmount = 2; // Used to inflate all rectangles for producing outer rectangles for GH_TextCapsules
        const int InnerComponentRadius = 50; // Used to define the radius of the main circle
        const int OuterComponentRadius = 60; // Used to define the radius of the main circle

        public static Random random = new Random();
        public Brush houseBrush;


        //public List<RoomInstance> roomInstancesList = new List<RoomInstance>(); // List that contains all room instances that are to be in that house

        public List<string> roomInstancesGuidList = new List<string>();


        protected override void Layout()
        {

            base.Layout();

            Pivot = GH_Convert.ToPoint(Pivot);
            Rectangle rec0 = GH_Convert.ToRectangle(Bounds);
            //rec0.Height += 50;
            Bounds = rec0;

            /*
                        HouseNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X - 50 + 25, (int)Bounds.Location.Y + 50), new Size(80, 20));
                        FloorNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X - 50 + 50, (int)Bounds.Location.Y + 75), new Size(60, 20));
                        */

            //   Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);
        }


        protected RectangleF InnerComponentBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        protected RectangleF OuterComponentBounds
        {
            get
            {
                RectangleF outer = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                outer.Inflate(inflation, inflation);
                return outer;
            }
        }

        protected Rectangle InflateRect(Rectangle rect, int a = 5, int b = 5)
        {
            Rectangle rectOut = rect;
            rectOut.Inflate(-a, -b);
            return rectOut;
        }

        public void AddPrevioslyConnectedRooms()
        {
            if (strArray == null)
                return;
            if (strArray.Length > 0 && roomInstancesGuidList.Count == 0)
            {
                foreach (string guidS in strArray)
                    if (guidS != "")
                        if (Owner.OnPingDocument().FindComponent(new Guid(guidS)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(guidS)));

            }
            UpdateRoomInstancesColors();
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {

            //Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);
            //  Bounds = InnerComponentBounds;
            //         base.Render(canvas, graphics, channel);

            if (Owner is HouseInstance houseInstance)
                if (channel == GH_CanvasChannel.Objects)
                {
                    graphics.FillRectangle(houseBrush, OuterComponentBounds);
                    base.Render(canvas, graphics, channel);

                    //       Bounds = InnerComponentBounds;
                    //    GH_Capsule.CreateCapsule(Bounds, GH_Palette.Grey).Render(graphics, Color.Gray);

                    //       Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - 2 * OuterComponentRadius, 2 * OuterComponentRadius, OuterComponentRadius);
                    //     Layout();
                    //   GH_ComponentAttributes.RenderComponentParameters(canvas, graphics, Owner, new GH_PaletteStyle(Color.Brown));

                    //  Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);


                    //    foreach (IGH_DocumentObject obj in roomInstancesList)
                    //        DrawTargetArrow(graphics, obj.Attributes.Bounds);


                    //    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerComponentBounds, GH_Palette.Normal, InnerComponentRadius, 0);
                    //    capsule.Render(graphics, Selected, Owner.Locked, true);
                    //    capsule.Dispose();


                    //  graphics.DrawString("A:", SystemFonts.IconTitleFont, Brushes.Black, new RectangleF(new System.Drawing.Point((int)Bounds.Location.X + 30, (int)Bounds.Location.Y + 77), new Size(20, 20)));

                    HouseName = GH_Capsule.CreateTextCapsule(HouseNameRectangle, InflateRect(HouseNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, houseInstance.HouseName);
                    //  HouseName.Render(graphics, GH_Skin.palette_grey_standard);
                    HouseName.Dispose();

                    FloorName = GH_Capsule.CreateTextCapsule(FloorNameRectangle, InflateRect(FloorNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, houseInstance.FloorName.ToString());
                    //   FloorName.Render(graphics, GH_Skin.palette_white_standard);
                    FloorName.Dispose();



                }
                else
                {
                    //  foreach (IGH_DocumentObject obj in roomInstancesList)
                    //     DrawTargetArrow(graphics, obj.Attributes.Bounds);

                    base.Render(canvas, graphics, channel);

                }
        }

        public PointF CircleClosesPoint(PointF point, RectangleF circle)
        {
            Vector2d vec = new Vector2d(circle.X + circle.Width / 2 - point.X, circle.Y + circle.Width / 2 - point.Y);
            vec.Unitize();
            vec = new Vector2d(vec.X * circle.Width / 2, vec.Y * circle.Width / 2);
            return (new PointF((float)(circle.Location.X + circle.Width / 2 + -vec.X), (float)(circle.Location.Y + circle.Width / 2 - vec.Y)));
        }

        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            //  double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            //  if (distance < OuterComponentRadius)
            //      return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterComponentRadius - 2);
            PointF tp;// = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));
            tp = Grasshopper.GUI.GH_GraphicsUtil.BoxClosestPoint(new PointF(target.Location.X + target.Width / 2, target.Location.Y + target.Height / 2), Bounds);

            PointF cp = CircleClosesPoint(tp, target);

            Pen arrowPen = new Pen(houseBrush, (OuterComponentRadius - InnerComponentRadius) / 8);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            arrowPen.StartCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }

        public void UpdateRoomInstancesColors()
        {
            roomInstancesGuidList.RemoveAll(i => i == "");

            /*    for (int i = 0; i < roomInstancesGuidList.Count; i++)
                {
                    try
                    {
                        Owner.OnPingDocument().FindComponent(new Guid(roomInstancesGuidList[i]));
                        if (Owner.OnPingDocument().FindComponent(new Guid(roomInstancesGuidList[i])) == null)
                        {
                            roomInstancesGuidList.RemoveAt(i);
                            i--;
                        }
                    }
                    catch (Exception e)
                    {
                        roomInstancesGuidList.RemoveAt(i);
                        i--;
                    }
                }
                */

            foreach (string guidS in roomInstancesGuidList)
            {

                RoomInstance childRoom = Owner.OnPingDocument().FindComponent(new Guid(guidS)) as RoomInstance;
                if ((childRoom.Attributes as RoomInstanceAttributes).roomBrush != houseBrush)
                {
                    (childRoom.Attributes as RoomInstanceAttributes).roomBrush = houseBrush;
                    childRoom.ExpireSolution(true);
                }
            }

        }


        public void AddAdjacence(IGH_DocumentObject a)
        {
            if (a == null) return;

            if (roomInstancesGuidList.Find(item => item == a.InstanceGuid.ToString()) == null)
            {
                roomInstancesGuidList.Add(a.InstanceGuid.ToString());

                if (((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                    (((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance.Attributes as HouseInstanceAttributes).RemoveAdjacence(a);

                ((a as RoomInstance).Attributes as RoomInstanceAttributes).AssignedHouseInstance = Owner as HouseInstance;

                foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                {
                    if (intPair.a == a.InstanceGuid.ToString() && roomInstancesGuidList.FindIndex(i => i == intPair.b) < 0)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.b)));

                    if (intPair.b == a.InstanceGuid.ToString() && roomInstancesGuidList.FindIndex(i => i == intPair.a) < 0)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            AddAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.a)));
                }
            }

            UpdateRoomInstancesColors();
        }


        // Removes the RoomInstance and all connected to it RoomInstances
        public void RemoveAdjacence(IGH_DocumentObject a)
        {
            if (a == null) return;

            if (roomInstancesGuidList.RemoveAll(i => i == a.InstanceGuid.ToString()) > 0)
            {

                ((a as RoomInstance).Attributes as RoomInstanceAttributes).roomBrush = Brushes.Gray;
                a.OnDisplayExpired(true);

                foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                {
                    if (intPair.a == a.InstanceGuid.ToString())
                        if (Owner.OnPingDocument() != null)
                        if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                            RemoveAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.b)));

                    if (intPair.b == a.InstanceGuid.ToString())
                        if (Owner.OnPingDocument() != null)
                            if (Owner.OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            RemoveAdjacence(Owner.OnPingDocument().FindComponent(new Guid(intPair.a)));
                }
            }
        }

        public override bool Write(GH_IO.Serialization.GH_IWriter writer)
        {
            string roomInstancesListString = "";
            foreach (string guid in roomInstancesGuidList)
                roomInstancesListString += guid + "@";

            if (roomInstancesListString.Length > 0)
                roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            writer.SetString("RoomInstancesListString", roomInstancesListString);
            writer.SetString("HouseName", (Owner as HouseInstance).HouseName);
            writer.SetString("FloorName", (Owner as HouseInstance).FloorName);
            writer.SetBoolean("TryRotateBoundary", (Owner as HouseInstance).tryRotateBoundary);

            return base.Write(writer);
        }
        string[] strArray;
        public override bool Read(GH_IO.Serialization.GH_IReader reader)
        {
            string roomInstancesListString = reader.GetString("RoomInstancesListString");
            strArray = roomInstancesListString.Split('@');



            (Owner as HouseInstance).HouseName = reader.GetString("HouseName");
            (Owner as HouseInstance).FloorName = reader.GetString("FloorName");
            (Owner as HouseInstance).tryRotateBoundary = reader.GetBoolean("TryRotateBoundary");

            Owner.ExpireSolution(false);

            UpdateRoomInstancesColors();
            return base.Read(reader);
        }

    }
}


<./Magnetizing_FPG\RoomProgram\HouseInstanceTextInput.cs>
﻿using Grasshopper.Kernel;
using Rhino.Geometry;
using System;
using System.Collections.Generic;
using System.Drawing;

public interface IHouseInstance
{
    /// <summary>
    /// The building boundary.
    /// </summary>
    Curve boundary { get; }

    /// <summary>
    /// The entrance point.
    /// </summary>
    Point3d startingPoint { get; }

    /// <summary>
    /// If the boundary should be rotated.
    /// </summary>
    bool tryRotateBoundary { get; }

    /// <summary>
    /// The list of room instances.
    /// </summary>
    List<IRoomInstance> RoomInstances { get; }

    /// <summary>
    /// The adjacency data as strings (e.g. "1-2").
    /// </summary>
    List<string> adjStrList { get; }

    int[,] adjArray { get; set; }
}

public interface IRoomInstance
{
    /// <summary>
    /// A unique room identifier.
    /// </summary>
    int RoomId { get; set; }

    /// <summary>
    /// The room area (in m²).
    /// </summary>
    double RoomArea { get; set; }

    /// <summary>
    /// The room name.
    /// </summary>
    string RoomName { get; set; }

    /// <summary>
    /// Whether the room is a hall.
    /// </summary>
    bool isHall { get; set; }

    /// <summary>
    /// A list of rooms adjacent to this room.
    /// </summary>
    List<IRoomInstance> AdjacentRoomsList { get; }

    bool hasMissingAdj { get; set; }
}



namespace Magnetizing_FPG
{
    /// <summary>
    /// A GH_Component that implements IHouseInstance.
    /// This advanced house builds its own internal rooms (of type InternalRoomInstance)
    /// and wires up adjacency according to input.
    /// </summary>
    public class HouseInstanceAdvanced : GH_Component, IHouseInstance
    {
        // IHouseInstance interface properties
        public Curve boundary { get; private set; }
        public Point3d startingPoint { get; private set; }
        public bool tryRotateBoundary { get; private set; }
        public List<IRoomInstance> RoomInstances { get; private set; } = new List<IRoomInstance>();
        public List<string> adjStrList { get; private set; } = new List<string>();
        // Additional: Provide an "adjArray" property for backward compatibility.
        public int[,] adjArray
        {
            get
            {
                if (adjStrList == null || adjStrList.Count == 0)
                    return new int[0, 0];
                int n = adjStrList.Count;
                int[,] arr = new int[n, 2];
                for (int i = 0; i < n; i++)
                {
                    string[] parts = adjStrList[i].Split('-');
                    if (parts.Length == 2)
                    {
                        int a, b;
                        if (int.TryParse(parts[0], out a) && int.TryParse(parts[1], out b))
                        {
                            arr[i, 0] = a;
                            arr[i, 1] = b;
                        }
                    }
                }
                return arr;
            }
            set { }
        }
        public HouseInstanceAdvanced()
          : base("HouseInstanceAdvanced", "HIAdv",
                 "Advanced House Instance which takes information about the rooms in text forms. Does not need RoomInstance objects.",
                 "Magnetizing_FPG", "Magnetizing_FPG")
        {
        }


        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "B", "House boundary", GH_ParamAccess.item);
            pManager.AddPointParameter("Entrance Point", "EP", "Entrance point", GH_ParamAccess.item);
            pManager.AddNumberParameter("Room Areas", "RA", "List of room areas (m²)", GH_ParamAccess.list);
            pManager.AddTextParameter("Room Names", "RN", "List of room names", GH_ParamAccess.list);
            pManager.AddBooleanParameter("Is Hall", "IH", "List of hall flags", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacency", "AD", "Adjacency list as strings (e.g. \"1-2\"). Room numbering starts with 1.", GH_ParamAccess.list);
            pManager.AddBooleanParameter("Rotate Boundary", "RB", "Try rotating boundary", GH_ParamAccess.item, false);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("HouseInstance", "HI", "House Instance", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            // Retrieve basic house inputs.
            Curve boundary = null;
            if (!DA.GetData(0, ref boundary)) return;
            Point3d entrance = Point3d.Unset;
            if (!DA.GetData(1, ref entrance)) return;
            List<double> areas = new List<double>();
            DA.GetDataList(2, areas);
            List<string> names = new List<string>();
            DA.GetDataList(3, names);
            List<bool> halls = new List<bool>();
            DA.GetDataList(4, halls);
            List<string> adj = new List<string>();
            DA.GetDataList(5, adj);
            bool rb = false;
            DA.GetData(6, ref rb);

            // Set properties.
            this.boundary = boundary;
            this.startingPoint = entrance;
            this.tryRotateBoundary = rb;

            // Process room areas, names and hall flags.
            if (areas.Count == 0)
                areas.Add(40.0);
            int roomCount = areas.Count;

            // Build final room names (auto-generate if necessary)
            List<string> finalNames = new List<string>();
            for (int i = 0; i < roomCount; i++)
            {
                if (i < names.Count && !string.IsNullOrEmpty(names[i]))
                    finalNames.Add(names[i]);
                else
                    finalNames.Add("Room " + (i + 1).ToString());
            }

            // Build final hall flags (default to false if missing)
            List<bool> finalHalls = new List<bool>();
            for (int i = 0; i < roomCount; i++)
            {
                if (i < halls.Count)
                    finalHalls.Add(halls[i]);
                else
                    finalHalls.Add(false);
            }

            // Create internal room instances.
            RoomInstances.Clear();
            for (int i = 0; i < roomCount; i++)
            {
                InternalRoomInstance room = new InternalRoomInstance();
                room.RoomId = i + 1;
                room.RoomArea = areas[i];
                room.RoomName = finalNames[i];
                room.isHall = finalHalls[i];
                RoomInstances.Add(room);
            }

            // Process and store adjacency strings.
            adjStrList.Clear();
            foreach (string s in adj)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    adjStrList.Add(s.Replace(" ", ""));
            }

            // Wire up adjacency for each pair (e.g., "1-2" links room 1 and room 2).
            foreach (string s in adjStrList)
            {
                string[] parts = s.Split('-');
                if (parts.Length == 2)
                {
                    int a, b;
                    if (int.TryParse(parts[0], out a) && int.TryParse(parts[1], out b))
                    {
                        if (a >= 1 && b >= 1 && a <= roomCount && b <= roomCount)
                        {
                            IRoomInstance roomA = RoomInstances[a - 1];
                            IRoomInstance roomB = RoomInstances[b - 1];
                            if (!roomA.AdjacentRoomsList.Contains(roomB))
                                roomA.AdjacentRoomsList.Add(roomB);
                            if (!roomB.AdjacentRoomsList.Contains(roomA))
                                roomB.AdjacentRoomsList.Add(roomA);
                        }
                    }
                }
            }

            // Output this advanced house instance.
            DA.SetData(0, this);
        }

        public override Guid ComponentGuid
        {
            get { return new Guid("E2D7B0F4-1111-2222-3333-444455556666"); }
        }

        protected override Bitmap Icon
        {
            get { return null; }
        }

    }

    /// <summary>
    /// A plain class implementing IRoomInstance.
    /// This internal room does not rely on any GH_Component GUI elements.
    /// </summary>
    public class InternalRoomInstance : IRoomInstance
    {
        public int RoomId { get; set; }
        public double RoomArea { get; set; }
        public string RoomName { get; set; }
        public bool isHall { get; set; }
        public List<IRoomInstance> AdjacentRoomsList { get; private set; } = new List<IRoomInstance>();

        bool IRoomInstance.hasMissingAdj { get; set; }

        public override string ToString()
        {
            return $"{RoomName} ({RoomArea} m²)";
        }
    }
}


<./Magnetizing_FPG\RoomProgram\RoomInstance.cs>
﻿using System;
using System.Collections.Generic;
using System.Windows.Forms;
using Magnetizing_FPG.Properties;
using Grasshopper.Kernel;
using Rhino.Geometry;
using System.Linq;

namespace Magnetizing_FPG
{
    /// <summary>
    ///  RoomInstance class contains all the information about 
    ///  one single room: name, ID, all connected rooms.
    /// </summary>
    public class RoomInstance : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the RoomInstance class.
        /// </summary>
        public RoomInstance()
        
          : base("RoomInstance", "RoomInstance",
              "RoomInstance",
             "Magnetizing_FPG", "Magnetizing_FPG")
        {
            if (entranceIds == null)
                entranceIds = new List<int>();
            RoomName = "Room " + RoomId.ToString();
            RoomId = maxId++;

            allRoomInstances.Add(this);
            m_attributes = new RoomInstanceAttributes(this);

            // if (m_attributes is RoomInstanceAttributes)
            foreach (RoomInstance room in (m_attributes as RoomInstanceAttributes).targetObjectList)
                (m_attributes as RoomInstanceAttributes).RemoveAdjacence(room as RoomInstance);

            //(m_attributes as RoomInstanceAttributes).targetObjectList.Clear();
            //(m_attributes as RoomInstanceAttributes).writerTargetObjectsListString = new string[0];
        }

        public class IntPair
        {
          public string a;
          public string b;
            public IntPair(string A, string B)
            {
                a = A;
                b = B;
            }
        }

        public override void AddedToDocument(GH_Document document)
        {
            base.AddedToDocument(document);
        }

        public double RoomArea = 40;
        public int RoomId;// = maxId++;
        public static int maxId = 0;
        public static List<int> entranceIds; // If there is an entrance which should be placed first, it's id will be stored here
        public string RoomName;// = "Room Name";
        public bool isHall = false; // true if the room is to be a hall (connecting-space)
        public bool hasMissingAdj = false;
        public static List<IntPair> allAdjacencesList = new List<IntPair>();
        public static List<RoomInstance> allRoomInstances = new List<RoomInstance>();

        public List<RoomInstance> AdjacentRoomsList
        {
            get {
                List<RoomInstance> list = new List<RoomInstance>();
                foreach (IntPair intPair in allAdjacencesList)
                {
                    if (intPair.a == this.InstanceGuid.ToString())
                        if (OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                        list.Add(OnPingDocument().FindComponent(new Guid(intPair.b)) as RoomInstance);
                    if (intPair.b == this.InstanceGuid.ToString())
                        if (OnPingDocument().FindComponent(new Guid(intPair.a)) != null)
                            list.Add(OnPingDocument().FindComponent(new Guid(intPair.a)) as RoomInstance);
                }
                list = list.Distinct().ToList();

                return list;
            }

        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddTextParameter("a", "a", "a", GH_ParamAccess.item);
        }

        public override void CreateAttributes()
        {
            m_attributes = new RoomInstanceAttributes(this);
        }
        

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            //  AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "Name: " + RoomName +"\nArea: " + RoomArea);

            //AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, AdjacentRoomsList.Count.ToString());

            DA.SetData(0, RoomName);
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                return Resources.RoomInstanceIcon;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{85beb9d6-e6cd-4499-9659-2d51784d948c}"); }
        }

        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "Set as Entrance", Menu_SetAsEntrance, true, RoomInstance.entranceIds.Contains(this.RoomId));
            Menu_AppendItem(menu, "Set as Hall", Menu_SetAsHall, true, isHall);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        private void Menu_SetAsEntrance(object sender, EventArgs e)
        {
            if (!entranceIds.Contains(RoomId))
            {
                if (entranceIds.Count > 0)
                {
                    List<int> copyList = RoomInstance.entranceIds.ConvertAll(i => i);

                    List<RoomInstance> allConnectedRooms = new List<RoomInstance>();
                    foreach (RoomInstance room in (((m_attributes as RoomInstanceAttributes).AssignedHouseInstance as HouseInstance).RoomInstances))
                        if (room != null)
                        if (room.RoomId != RoomId)
                            allConnectedRooms.Add(room);

                    int prevCount;
                    List<RoomInstance> tempRoomList = new List<RoomInstance>();
                    do
                    {
                        tempRoomList.Clear();
                        prevCount = allConnectedRooms.Count;
                        foreach (RoomInstance room in allConnectedRooms)
                            foreach (RoomInstance roomConnected in room.AdjacentRoomsList)
                                if (roomConnected != null)
                                if (!allConnectedRooms.Contains(roomConnected) && roomConnected.RoomId != RoomId)
                                    tempRoomList.Add(roomConnected);

                        allConnectedRooms.AddRange(tempRoomList);
                    } while (prevCount != allConnectedRooms.Count);


                    foreach (int id in copyList)
                        if (id != RoomId)
                            if (allConnectedRooms.Find(room => (room as RoomInstance).RoomId == id) != null)
                            {
                                entranceIds.Remove(id);
                                //     AdjacentRoomsList.Find(room => (room as RoomInstance).RoomId == id).ExpireSolution(false);
                            }
                }
                RoomInstance.entranceIds.Add(this.RoomId);
            }
            else
                entranceIds.Remove(RoomId);

            ExpireSolution(true);
        }

        private void Menu_SetAsHall(object sender, EventArgs e)
        {
            isHall = !isHall;
            ExpireSolution(false);
        }

    }
}

<./Magnetizing_FPG\RoomProgram\RoomInstanceAttributes.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.GUI;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Parameters;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System.Linq;

namespace Magnetizing_FPG
{
    public interface IRoomStructure<T>
    {
        void AddAdjacence(T a);
        void RemoveAdjacence(T a);
    }

    public class RoomInstanceAttributes : GH_ComponentAttributes, IRoomStructure<IGH_DocumentObject>
    {

        public RoomInstanceAttributes(RoomInstance param) : base(param)
        {
            if (RoomArea == null) RoomArea = GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, param.RoomArea.ToString());
            RoomName = GH_Capsule.CreateTextCapsule(new Rectangle(), new Rectangle(), GH_Palette.Black, param.RoomName);

            roomBrush = Brushes.Gray;


        }

        protected override void Layout()
        {
            Pivot = GH_Convert.ToPoint(Pivot);
            Bounds = new RectangleF(Pivot.X - OuterComponentRadius, Pivot.Y - OuterComponentRadius, 2 * OuterComponentRadius, 2 * OuterComponentRadius);

        }

        public GH_Capsule RoomArea;
        public GH_Capsule RoomName;


        Rectangle RoomAreaRectangle;
        Rectangle RoomNameRectangle;
        Rectangle RoomIdRectangle;

        bool haveReadTargetObjectsList = false;
        public Brush roomBrush;

        const int InflateAmount = 2; // Used to inflate all rectangles for producing outer rectangles for GH_TextCapsules
        const int InnerComponentRadius = 55; // Used to define the radius of the main circle
        const int OuterComponentRadius = 75; // Used to define the radius of the main circle

        public string[] writerTargetObjectsListString = new string[0];

        public HouseInstance AssignedHouseInstance;

        public List<IGH_DocumentObject> targetObjectList = new List<IGH_DocumentObject>();

        protected Rectangle InflateRect(Rectangle rect, int a = 5, int b = 5)
        {
            Rectangle rectOut = rect;
            rectOut.Inflate(-a, -b);
            return rectOut;
        }

        protected RectangleF InnerComponentBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterComponentRadius - InnerComponentRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        public override bool IsPickRegion(PointF point)
        {
            return Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, point);
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {
            if (Owner is RoomInstance roomInstance)
                if (channel == GH_CanvasChannel.Objects)
                {
                    graphics.FillEllipse(roomBrush, Bounds);

                    if ((Owner as RoomInstance).hasMissingAdj)
                    {
                        graphics.FillEllipse(Brushes.Red, new RectangleF(Pivot.X - InnerComponentRadius - 9, Pivot.Y - InnerComponentRadius - 9
                            , 2 * InnerComponentRadius + 18, 2 * InnerComponentRadius + 18));
                    }

                    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerComponentBounds, GH_Palette.Normal, InnerComponentRadius - 5, 0);
                    capsule.Render(graphics, Selected, Owner.Locked, true);
                    capsule.Dispose();

                    RoomNameRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 28, (int)Bounds.Location.Y + 55), new Size(94, 20));
                    RoomAreaRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 65, (int)Bounds.Location.Y + 80), new Size(57, 20));
                    RoomIdRectangle = new Rectangle(new System.Drawing.Point((int)Bounds.Location.X + 35, (int)Bounds.Location.Y + 105), new Size(80, 40));

                    graphics.DrawString("m² :", new Font(FontFamily.GenericSansSerif, 6f, FontStyle.Regular), Brushes.Black, new RectangleF(new System.Drawing.Point((int)Bounds.Location.X + 35, (int)Bounds.Location.Y + 81), new Size(30, 20)));
                    if (!RoomInstance.entranceIds.Contains(roomInstance.RoomId))
                        graphics.DrawString("ID: " + roomInstance.RoomId, new Font(FontFamily.GenericSansSerif, 4f, FontStyle.Regular), Brushes.Black, RoomIdRectangle, new StringFormat() { Alignment = StringAlignment.Center });
                    else
                        graphics.DrawString("ID: " + roomInstance.RoomId + "\n(entrance)", new Font(FontFamily.GenericSansSerif, 4f, FontStyle.Bold), Brushes.Black, RoomIdRectangle, new StringFormat() { Alignment = StringAlignment.Center });


                    RoomName = GH_Capsule.CreateTextCapsule(RoomNameRectangle, InflateRect(RoomNameRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, roomInstance.RoomName);
                    RoomName.Render(graphics, GH_Skin.palette_grey_standard);
                    RoomName.Dispose();

                    RoomArea = GH_Capsule.CreateTextCapsule(RoomAreaRectangle, InflateRect(RoomAreaRectangle, InflateAmount, InflateAmount), GH_Palette.Pink, roomInstance.RoomArea.ToString());
                    RoomArea.Render(graphics, GH_Skin.palette_white_standard);
                    RoomArea.Dispose();


                    for (int i = 0; i < RoomInstance.allAdjacencesList.Count; i++)
                        try
                        {
                            Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].b));
                            Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].a));

                            if (Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].b)) == null ||
                                Owner.OnPingDocument().FindComponent(new Guid(RoomInstance.allAdjacencesList[i].a)) == null)
                            {
                                RoomInstance.allAdjacencesList.RemoveAt(i); i--;
                            }
                        }
                        catch (Exception) { RoomInstance.allAdjacencesList.RemoveAt(i); i--; }


                    foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                    {
                        if (intPair.a == this.Owner.InstanceGuid.ToString())
                            try
                            {
                                if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                                    DrawTargetArrow(graphics, Owner.OnPingDocument().FindComponent(new Guid(intPair.b)).Attributes.Bounds);
                            }
                            catch (Exception) { }
                        if (intPair.b == this.Owner.InstanceGuid.ToString())
                            try
                            {
                                if (Owner.OnPingDocument().FindComponent(new Guid(intPair.b)) != null)
                                    DrawTargetArrow(graphics, Owner.OnPingDocument().FindComponent(new Guid(intPair.a)).Attributes.Bounds);
                            }
                            catch (Exception) { }
                    }

                    // if (obj != null)
                    //     DrawTargetArrow(graphics, obj.Attributes.Bounds);


                }
                else
                {
                    base.Render(canvas, graphics, channel);
                }

            if (RoomInstance.allAdjacencesList == null || RoomInstance.allAdjacencesList.Count == 0)
                if (writerTargetObjectsListString.Length > 0)// && targetObjectList.Count == 0)
                {
                    if (writerTargetObjectsListString.Length > 0)
                        foreach (string guidS in writerTargetObjectsListString)
                        {
                            try
                            {
                                RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(guidS.Split('%')[0], guidS.Split('%')[1]));
                                //   Owner.OnPingDocument().FindComponent(new Guid(guidS.Split('!')[0]))

                                /*  if (!targetObjectList.Contains(Owner.OnPingDocument().FindComponent(
                                      new System.Drawing.Point(int.Parse(guidS.Split('!')[0]), int.Parse(guidS.Split('!')[1]))) as RoomInstance))
                                      targetObjectList.Add(Owner.OnPingDocument().FindComponent(
                                          new System.Drawing.Point(int.Parse(guidS.Split('!')[0]), int.Parse(guidS.Split('!')[1]))) as RoomInstance);*/
                            }
                            catch (Exception) { }
                        }
                }

        }

        /// <summary>
        /// Get the closest point on the circle
        /// </summary>
        /// <param name="point"></param>
        /// <param name="circle"></param>
        /// <returns></returns>
        public PointF CircleClosestPoint(PointF point, RectangleF circle)
        {
            Vector2d vec = new Vector2d(circle.X + circle.Width / 2 - point.X, circle.Y + circle.Width / 2 - point.Y);
            vec.Unitize();
            vec = new Vector2d(vec.X * circle.Width / 2, vec.Y * circle.Width / 2);
            return (new PointF((float)(circle.Location.X + circle.Width / 2 + -vec.X), (float)(circle.Location.Y + circle.Width / 2 - vec.Y)));
        }

        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            PointF cp = CircleClosestPoint(Pivot, target);

            double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            if (distance < OuterComponentRadius)
                return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterComponentRadius - 2);
            PointF tp = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));

            Pen arrowPen = new Pen(roomBrush, (OuterComponentRadius - InnerComponentRadius) / 2);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            arrowPen.StartCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }


        private bool _drawing;
        private RectangleF _drawingBox;

        public override GH_ObjectResponse RespondToMouseDown(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            _drawing = false;
            _drawingBox = InnerComponentBounds;

            if (e.Button == System.Windows.Forms.MouseButtons.Left)
            {
                // If on outer disc, but not in inner disc, then start a wire drawing process.
                bool onOuterDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, e.CanvasLocation);
                bool onInnerDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(InnerComponentBounds, e.CanvasLocation);
                if (onOuterDisc && !onInnerDisc)
                {
                    // Begin arrow drawing behaviour.
                    _drawing = true;
                    sender.CanvasPostPaintObjects += CanvasPostPaintObjects;
                    return GH_ObjectResponse.Capture;
                }
            }

            // Otherwise revert to default behaviour.
            return base.RespondToMouseDown(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseMove(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (!_drawing)
                return base.RespondToMouseMove(sender, e);

            _drawingBox = new RectangleF(e.CanvasLocation, new SizeF(0, 0));

            GH_Document doc = sender.Document;
            if (doc != null)
            {
                IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                if (att != null)
                {
                    if (att is IRoomStructure<IGH_DocumentObject>)
                        _drawingBox = att.Bounds;
                }
            }
            sender.Invalidate();
            return GH_ObjectResponse.Handled;
        }

        public override GH_ObjectResponse RespondToMouseUp(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawing = false;
                sender.CanvasPostPaintObjects -= CanvasPostPaintObjects;

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                        if (att is IRoomStructure<IGH_DocumentObject> target)
                        {
                            Owner.RecordUndoEvent("Add Modifier");
                            if (att.DocObject is RoomInstance)
                            {
                                if ((att.DocObject as RoomInstance).InstanceGuid != (DocObject as RoomInstance).InstanceGuid)
                                {
                                    if (RoomInstance.allAdjacencesList.Find(i => i.a == att.DocObject.InstanceGuid.ToString() && i.b == DocObject.InstanceGuid.ToString()) == null &&
                                        RoomInstance.allAdjacencesList.Find(i => i.b == att.DocObject.InstanceGuid.ToString() && i.a == DocObject.InstanceGuid.ToString()) == null)
                                    {
                                        AddAdjacence(att.DocObject);
                                        target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                    }
                                    /*
                                    if (targetObjectList.Find(item => (item as RoomInstance).RoomId == (att.DocObject as RoomInstance).RoomId) == null)
                                    {
                                        AddAdjacence(att.DocObject);
                                        target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                    }*/
                                    else
                                    {
                                        RemoveAdjacence(att.DocObject);
                                        target.RemoveAdjacence(this.DocObject as IGH_DocumentObject);
                                    }

                                    RoomInstance.allAdjacencesList = RoomInstance.allAdjacencesList.Distinct().ToList();
                                }
                            }
                            else if (att.DocObject is HouseInstance houseInstance)
                            {
                                if ((att as HouseInstanceAttributes).roomInstancesGuidList.Find(item => item == (this.DocObject as RoomInstance).InstanceGuid.ToString()) == null)
                                    target.AddAdjacence(this.DocObject as IGH_DocumentObject);
                                else
                                {
                                    target.RemoveAdjacence(this.DocObject as IGH_DocumentObject);
                                }

                            }

                            IGH_ActiveObject obj = att.DocObject as IGH_ActiveObject;
                        }
                }

                sender.Invalidate();
                return GH_ObjectResponse.Release;
            }

            return base.RespondToMouseUp(sender, e);
        }
        void CanvasPostPaintObjects(GH_Canvas sender)
        {
            if (!_drawing) return;
            DrawTargetArrow(sender.Graphics, _drawingBox);
        }


        public override GH_ObjectResponse RespondToMouseDoubleClick(GH_Canvas sender, GH_CanvasMouseEvent e)
        {
            if (Owner is RoomInstance roomInstance)
            {
                string initial = string.Empty;


                var matrix = sender.Viewport.XFormMatrix(GH_Viewport.GH_DisplayMatrix.CanvasToControl);

                if (this.RoomArea.Contains(e.CanvasLocation))
                {
                    var field = new CapsuleInputBase(RoomArea, roomInstance, RoomInstanceVar.RoomArea)
                    {
                        Bounds = GH_Convert.ToRectangle(RoomArea.Box)
                    };

                    field.ShowTextInputBox(sender, RoomArea.Text, true, false, matrix);
                }


                if (this.RoomName.Contains(e.CanvasLocation))
                {
                    var field = new CapsuleInputBase(RoomName, roomInstance, RoomInstanceVar.RoomName)
                    {
                        Bounds = GH_Convert.ToRectangle(RoomName.Box)
                    };

                    field.ShowTextInputBox(sender, RoomName.Text, true, false, matrix);
                }
                roomInstance.ExpireSolution(false);

                return GH_ObjectResponse.Handled;
            }
            return base.RespondToMouseDoubleClick(sender, e);
        }



        public void AddAdjacence(IGH_DocumentObject a)
        {
            // int t = String.Compare(a.InstanceGuid.ToString(), this.Owner.InstanceGuid.ToString());
            // if (t >= 0)
            RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(a.InstanceGuid.ToString(), this.Owner.InstanceGuid.ToString()));
            //  else
            RoomInstance.allAdjacencesList.Add(new RoomInstance.IntPair(this.Owner.InstanceGuid.ToString(), a.InstanceGuid.ToString()));

            //  if (!targetObjectList.Contains(a))
            //      targetObjectList.Add(a);

            if (AssignedHouseInstance != null)
                (AssignedHouseInstance.Attributes as HouseInstanceAttributes).AddAdjacence(a);
            else if ((a.Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                ((a.Attributes as RoomInstanceAttributes).AssignedHouseInstance.Attributes as HouseInstanceAttributes).AddAdjacence(this.Owner as RoomInstance);
        }

        public void RemoveAdjacence(IGH_DocumentObject a)
        {
            RoomInstance.allAdjacencesList.RemoveAll(i => i.a == Owner.InstanceGuid.ToString() && i.b == a.InstanceGuid.ToString());
            RoomInstance.allAdjacencesList.RemoveAll(i => i.b == Owner.InstanceGuid.ToString() && i.a == a.InstanceGuid.ToString());


            //  while (targetObjectList.Contains(a))
            //   {
            //       targetObjectList.Remove(a);
            //  }



        }


        public override bool Write(GH_IO.Serialization.GH_IWriter writer)
        {
            string roomInstancesListString = "";
            foreach (RoomInstance.IntPair intPair in RoomInstance.allAdjacencesList)
                roomInstancesListString += intPair.a + "%" + intPair.b + "@";

            /*   foreach (RoomInstance room in targetObjectList)
                   if (room != null)
                       roomInstancesListString += ((int)(room.Attributes.Pivot.X)).ToString() + "!" +
                       ((int)(room.Attributes.Pivot.Y)).ToString() + "@";
   */
            if (roomInstancesListString.Length > 0)
                roomInstancesListString = roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            writer.SetString("TargetObjectList", roomInstancesListString);
            writer.SetString("RoomName", (Owner as RoomInstance).RoomName);
            //    writer.SetInt32("RoomId", (int)(Owner as RoomInstance).RoomId);
            writer.SetDouble("RoomArea", (Owner as RoomInstance).RoomArea);

            writer.SetBoolean("isHall", (Owner as RoomInstance).isHall);

            string temp = "";
            foreach (int a in RoomInstance.entranceIds)
                temp += a.ToString() + "&";
            if (temp.Length > 0)
                temp = temp.Remove(temp.Length - 1);

            writer.SetString("EntranceIds", temp);

            return base.Write(writer);
        }


        public override bool Read(GH_IO.Serialization.GH_IReader reader)
        {
            string roomInstancesListString = reader.GetString("TargetObjectList");
            writerTargetObjectsListString = roomInstancesListString.Split('@');

            // roomInstancesListString.Remove(roomInstancesListString.Length - 1);

            (Owner as RoomInstance).RoomName = reader.GetString("RoomName");//, (Owner as RoomInstance).RoomName);
                                                                            //    (Owner as RoomInstance).RoomId = (uint)reader.GetInt32("RoomId");//, (int)(Owner as RoomInstance).RoomId);
            (Owner as RoomInstance).RoomArea = (int)Math.Floor(reader.GetDouble("RoomArea"));//, (Owner as RoomInstance).RoomArea);

            try
            {
                (Owner as RoomInstance).isHall = reader.GetBoolean("isHall");
            }
            catch (Exception e) { }

            RoomInstance.entranceIds = new List<int>();
            string temp = "";
            try
            {
                temp = reader.GetString("EntranceIds");
            }
            catch (Exception) { }

            if (temp != null && temp.Length > 0)
            {
                string[] tempList = temp.Split('&');
                foreach (string s in tempList)
                    RoomInstance.entranceIds.Add(Int32.Parse(s));
            }

            Owner.ExpireSolution(false);

            return base.Read(reader);
        }
    }

    public enum RoomInstanceVar { RoomName, RoomArea };

    class CapsuleInputBase : Grasshopper.GUI.Base.GH_TextBoxInputBase
    {
        public GH_Capsule _input;
        public RoomInstance _roomInstance;
        private RoomInstanceVar _roomInstanceVar;

        public CapsuleInputBase(GH_Capsule input, RoomInstance roomInstance, RoomInstanceVar roomInstanceVar)
        {
            _input = input ?? throw new ArgumentNullException(nameof(input));
            _roomInstance = roomInstance;
            _roomInstanceVar = roomInstanceVar;
        }

        protected override void HandleTextInputAccepted(string text)
        {
            _input.Text = text;

            switch (_roomInstanceVar)
            {
                case (RoomInstanceVar.RoomName):
                    _roomInstance.RoomName = text;
                    break;

                case (RoomInstanceVar.RoomArea):
                    _roomInstance.RoomArea = Int32.Parse(text);
                    break;
            }
            _roomInstance.ExpireSolution(false);
            if ((_roomInstance.Attributes as RoomInstanceAttributes).AssignedHouseInstance != null)
                (_roomInstance.Attributes as RoomInstanceAttributes).AssignedHouseInstance.ExpireSolution(false);
        }
    }


}


<./Properties\AssemblyInfo.cs>
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Rhino.PlugIns;


// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FloorPlan_Generator_1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("FloorPlan_Generator_1")]
[assembly: AssemblyCopyright("Copyright ©  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f5f278ea-405f-40d9-9a0d-00c1854f8d43")] // This will also be the Guid of the Rhino plug-in

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


<./Properties\Resources.Designer.cs>
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Magnetizing_FPG.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Magnetizing_FPG.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap HouseInstanceIcon {
            get {
                object obj = ResourceManager.GetObject("HouseInstanceIcon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap MagnetizingRoomsIcon {
            get {
                object obj = ResourceManager.GetObject("MagnetizingRoomsIcon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap RoomInstanceIcon {
            get {
                object obj = ResourceManager.GetObject("RoomInstanceIcon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap SpringSystem_ESIcon {
            get {
                object obj = ResourceManager.GetObject("SpringSystem_ESIcon", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}


<./Properties\Resources.resx>
﻿<?xml version="1.0"
................................

<./studies\Study2\ShneiderKoenig.cs>
﻿using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace FloorPlan_Generator
{
    public class ShneiderKoenig : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public ShneiderKoenig()
          : base("ShneiderKoenig", "ASpi",
              "",
              "FloorPlanGen", "Study_1")
        {
        }

        private List<Curve> rooms = new List<Curve>();
        List<string> adjStrList;
        private Random random = new Random();
        double proportionThreshold = 0;

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacences", "Adjacences", "Adjacences as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, " - ");
            pManager.AddNumberParameter("ProportionThreshold", "ProportionThreshold", "ProportionThreshold, >= 1", GH_ParamAccess.item, 2);
            pManager.AddBooleanParameter("Reset", "Reset", "Reset", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddLineParameter("Adjacences", "Adjacences", "Adjacence lines", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            //List<Curve> rooms = new List<Curve>();
            Curve boundary = new PolylineCurve();
            bool shouldInstantiateRooms = false;
            adjStrList = new List<string>();// { "1 - 2", "3 - 0", "2 - 4" };
            List<Line> adjLines = new List<Line>();

            DA.GetData("Reset", ref shouldInstantiateRooms);
            DA.GetData("Boundary", ref boundary);
            if (shouldInstantiateRooms || rooms.Count == 0)
            {
                rooms.Clear();
                DA.GetDataList(1, rooms);
            }

            DA.GetData("ProportionThreshold", ref proportionThreshold);
            DA.GetDataList("Adjacences", adjStrList);

            Shuffle(ref adjStrList);


            rooms = AdjacentContraction(rooms, adjStrList, boundary, out adjLines);
            rooms = CollisionDetectionMain(rooms, boundary);

            List<GH_Curve> GH_rooms = new List<GH_Curve>();
            foreach (Curve c in rooms)
                GH_rooms.Add(new GH_Curve(c));

            DA.SetDataList(0, GH_rooms);
            DA.SetDataList(1, adjLines);
        }

        private List<Curve> CollisionDetectionMain(List<Curve> roomCurves, Curve boundary)
        {
            List<int> indexes = new List<int>();
            for (int i = 0; i < roomCurves.Count; i++)
                indexes.Add(i);

            Shuffle(ref indexes);

            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];

                // Check roomCurves[i] and roomCurves[j] intersection
                // Then let's move both rooms by 1/2 of the rebounding vector
                for (int j = i + 1; j < roomCurves.Count; j++)

                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], roomCurves[j]);

                    if (intersectResult.intersect)
                    {
                        if (intersectResult.reboundingVector.X != 0)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[j].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));
                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(intersectResult.reboundingVector.X / 2, 0, 0));
                                roomCurves[j].Translate(new Vector3d(-intersectResult.reboundingVector.X / 2, 0, 0));

                            }
                        }
                        else
                        {
                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2]
                            // Else - change the position of the rooms
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(0, intersectResult.reboundingVector.Y / 2, 0));
                                roomCurves[j].Translate(new Vector3d(0, -intersectResult.reboundingVector.Y / 2, 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], roomCurves[j], Plane.WorldXY, 0.0001f) != RegionContainment.Disjoint)
                        {
                            BoundingBox aRoomBB = roomCurves[j].GetBoundingBox(false);
                            BoundingBox bRoomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).X) - (aRoomBB.Diagonal.X / 2 - bRoomBB.Diagonal.X / 2);
                            double yDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).Y) - (aRoomBB.Diagonal.Y / 2 - bRoomBB.Diagonal.Y / 2);
                            if (xDist > yDist)
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist - bRoomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist + bRoomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist - bRoomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist + bRoomBB.Diagonal.Y, 0));
                            }
                        }
                    }

                }

                // Check roomCurves[i] and boundary intersection
                // Let's do it twice to be sure that X and Y positions are both defined perfectly
                for (int t = 0; t < 1; t++)
                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], boundary);

                    if (intersectResult.intersect)
                    {
                        double boundaryProportionThreshold = 1;// proportionThreshold;

                        if (Math.Abs(intersectResult.reboundingVector.X) > 0.01f)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d((intersectResult.reboundingVector.X > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.X - Math.Abs(intersectResult.reboundingVector.X)), 0, 0));
                            }
                        }
                        else if (Math.Abs(intersectResult.reboundingVector.Y) > 0.01f)
                        { // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[i].Translate( new Vector3d(0, (intersectResult.reboundingVector.Y > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.Y - Math.Abs(intersectResult.reboundingVector.Y)), 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], boundary, Plane.WorldXY, 0.0001f) != RegionContainment.AInsideB)
                        {
                            BoundingBox boundaryBB = boundary.GetBoundingBox(false);
                            BoundingBox roomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((boundaryBB.Center - roomBB.Center).X) - boundaryBB.Diagonal.X / 2 - roomBB.Diagonal.X / 2;
                            double yDist = Math.Abs((boundaryBB.Center - roomBB.Center).Y) - boundaryBB.Diagonal.Y / 2 - roomBB.Diagonal.Y / 2;
                            if (xDist > yDist)
                            {
                                if ((boundaryBB.Center - roomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist + roomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist - roomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((boundaryBB.Center - roomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist + roomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist - roomBB.Diagonal.Y, 0));
                            }
                        }
                    }
                }
            }
            return roomCurves;
        }

        private IntersectResult Intersect2Curves(Curve a, Curve b)
        {
            IntersectResult result = new IntersectResult();
            if (Curve.PlanarCurveCollision(a, b, Plane.WorldXY, 0.01f))
            {
                Curve[] unionCurveArray = Curve.CreateBooleanIntersection(a, b);
                if (unionCurveArray.Length > 0)
                {
                    result.intersect = true;
                    result.unionCurve = unionCurveArray[0];

                    // Find the smallest dimesion of unionCurve
                    Point3d minPoint = result.unionCurve.GetBoundingBox(false).Min;
                    Point3d maxPoint = result.unionCurve.GetBoundingBox(false).Max;

                    if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                    {
                        result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                        if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                            result.reboundingVector.Y *= -1;
                    }
                    else
                    {
                        result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                        if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                            result.reboundingVector.X *= -1;
                    }


                }
            }
            else
            {
                result.intersect = false;
                result.reboundingVector = Vector2d.Unset;
                result.unionCurve = null;
            }
            return result;
        }

        private struct IntersectResult
        {
            public Vector2d reboundingVector;
            public bool intersect;
            public Curve unionCurve;
        }

        private double GetRoomXYProportion(Curve room)
        {
            return (room.GetBoundingBox(false).Diagonal.X / (double)room.GetBoundingBox(false).Diagonal.Y);
        }


        private void Shuffle(ref List<Curve> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                Curve value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<string> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private List<Curve> AdjacentContraction(List<Curve> roomCurves, List<string> adjacenceStrings, Curve boundary, out List<Line> adjLines)
        {

            List<Adjacence> adjacences = new List<Adjacence>();

            foreach (string adjString in adjacenceStrings)
            {
                adjacences.Add(new Adjacence());
                adjacences[adjacences.Count - 1].aIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjacences[adjacences.Count - 1].bIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            foreach (Adjacence adj in adjacences)
            {
                Vector3d attractVector = roomCurves[adj.aIndex].GetBoundingBox(false).Center - roomCurves[adj.bIndex].GetBoundingBox(false).Center;

                Vector3d aDim = roomCurves[adj.aIndex].GetBoundingBox(false).Diagonal;
                Vector3d bDim = roomCurves[adj.bIndex].GetBoundingBox(false).Diagonal;

                if (Math.Abs(attractVector.X) - (aDim.X + bDim.X) / 2 > 0.001f ||
                    Math.Abs(attractVector.Y) - (aDim.Y + bDim.Y) / 2 > 0.001f)
                {

                    if (Math.Abs(attractVector.X) > Math.Abs(attractVector.Y))
                    {
                        attractVector.Y = 0;
                        aDim.Y = 0;
                        bDim.Y = 0;
                    }
                    else
                    {
                        attractVector.X = 0;
                        aDim.X = 0;
                        bDim.X = 0;
                    }

                    Point3d attractCenter = roomCurves[adj.aIndex].GetBoundingBox(false).Center + attractVector / 2;
                    if (attractVector.X != 0)
                        if (attractCenter.X > roomCurves[adj.aIndex].GetBoundingBox(false).Center.X)
                            bDim *= -1;
                        else
                            aDim *= -1;
                    else
                        if (attractCenter.Y > roomCurves[adj.aIndex].GetBoundingBox(false).Center.Y)
                        bDim *= -1;
                    else
                        aDim *= -1;


                    roomCurves[adj.aIndex].Translate(-attractVector / 2 + aDim / 2);
                    roomCurves[adj.bIndex].Translate(attractVector / 2 + bDim / 2);
                }
            }

            adjLines = new List<Line>();

            foreach (Adjacence adj in adjacences)
            {
                adjLines.Add(new Line(roomCurves[adj.aIndex].GetBoundingBox(false).Center, roomCurves[adj.bIndex].GetBoundingBox(false).Center));
            }

            return roomCurves;
        }

        private class Adjacence
        {
            public int aIndex;
            public int bIndex;
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                // You can add image files to your project resources and access them like this:
                //return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{7b00cbd7-910f-47cf-9601-348f8d999506}"); }
        }
    }
}


<./studies\Study2\SpringSystem.cs>
﻿using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class SpringSystem : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public SpringSystem()
          : base("SpringSystem", "ASpi",
              "",
              "Magnetizing_FPG", "Study_1")
        {
        }

        private List<Curve> rooms = new List<Curve>();
        List<string> adjStrList;
        private Random random = new Random();
        double proportionThreshold = 0;

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacences", "Adjacences", "Adjacences as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, " - ");
            pManager.AddNumberParameter("ProportionThreshold", "ProportionThreshold", "ProportionThreshold, >= 1", GH_ParamAccess.item, 2);
            pManager.AddBooleanParameter("Reset", "Reset", "Reset", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddLineParameter("Adjacences", "Adjacences", "Adjacence lines", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            //List<Curve> rooms = new List<Curve>();
            Curve boundary = new PolylineCurve();
            bool shouldInstantiateRooms = false;
            adjStrList = new List<string>();// { "1 - 2", "3 - 0", "2 - 4" };
            List<Line> adjLines = new List<Line>();

            DA.GetData("Reset", ref shouldInstantiateRooms);
            DA.GetData("Boundary", ref boundary);
            if (shouldInstantiateRooms || rooms.Count == 0)
            {
                rooms.Clear();
                DA.GetDataList(1, rooms);
            }

            DA.GetData("ProportionThreshold", ref proportionThreshold);
            DA.GetDataList("Adjacences", adjStrList);

            Shuffle(ref adjStrList);


            rooms = AdjacentContraction(rooms, adjStrList, boundary, out adjLines);
            rooms = CollisionDetectionMain(rooms, boundary);

            List<GH_Curve> GH_rooms = new List<GH_Curve>();
            foreach (Curve c in rooms)
                GH_rooms.Add(new GH_Curve(c));

            DA.SetDataList(0, GH_rooms);
            DA.SetDataList(1, adjLines);
        }

        private List<Curve> CollisionDetectionMain(List<Curve> roomCurves, Curve boundary)
        {
            List<int> indexes = new List<int>();
            for (int i = 0; i < roomCurves.Count; i++)
                indexes.Add(i);

            Shuffle(ref indexes);

            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];

                // Check roomCurves[i] and roomCurves[j] intersection
                // Then let's move both rooms by 1/2 of the rebounding vector
                for (int j = i + 1; j < roomCurves.Count; j++)

                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], roomCurves[j]);

                    if (intersectResult.intersect)
                    {
                        if (intersectResult.reboundingVector.X != 0)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[j].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));
                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(intersectResult.reboundingVector.X / 2, 0, 0));
                                roomCurves[j].Translate(new Vector3d(-intersectResult.reboundingVector.X / 2, 0, 0));

                            }
                        }
                        else
                        {
                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2]
                            // Else - change the position of the rooms
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(0, intersectResult.reboundingVector.Y / 2, 0));
                                roomCurves[j].Translate(new Vector3d(0, -intersectResult.reboundingVector.Y / 2, 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], roomCurves[j], Plane.WorldXY, 0.0001f) != RegionContainment.Disjoint)
                        {
                            BoundingBox aRoomBB = roomCurves[j].GetBoundingBox(false);
                            BoundingBox bRoomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).X) - (aRoomBB.Diagonal.X / 2 - bRoomBB.Diagonal.X / 2);
                            double yDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).Y) - (aRoomBB.Diagonal.Y / 2 - bRoomBB.Diagonal.Y / 2);
                            if (xDist > yDist)
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist - bRoomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist + bRoomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist - bRoomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist + bRoomBB.Diagonal.Y, 0));
                            }
                        }
                    }

                }

                // Check roomCurves[i] and boundary intersection
                // Let's do it twice to be sure that X and Y positions are both defined perfectly
                for (int t = 0; t < 1; t++)
                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], boundary);

                    if (intersectResult.intersect)
                    {
                        double boundaryProportionThreshold = 1;// proportionThreshold;

                        if (Math.Abs(intersectResult.reboundingVector.X) > 0.01f)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d((intersectResult.reboundingVector.X > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.X - Math.Abs(intersectResult.reboundingVector.X)), 0, 0));
                            }
                        }
                        else if (Math.Abs(intersectResult.reboundingVector.Y) > 0.01f)
                        { // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[i].Translate( new Vector3d(0, (intersectResult.reboundingVector.Y > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.Y - Math.Abs(intersectResult.reboundingVector.Y)), 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], boundary, Plane.WorldXY, 0.0001f) != RegionContainment.AInsideB)
                        {
                            BoundingBox boundaryBB = boundary.GetBoundingBox(false);
                            BoundingBox roomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((boundaryBB.Center - roomBB.Center).X) - boundaryBB.Diagonal.X / 2 - roomBB.Diagonal.X / 2;
                            double yDist = Math.Abs((boundaryBB.Center - roomBB.Center).Y) - boundaryBB.Diagonal.Y / 2 - roomBB.Diagonal.Y / 2;
                            if (xDist > yDist)
                            {
                                if ((boundaryBB.Center - roomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist + roomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist - roomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((boundaryBB.Center - roomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist + roomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist - roomBB.Diagonal.Y, 0));
                            }
                        }
                    }
                }
            }
            return roomCurves;
        }

        private IntersectResult Intersect2Curves(Curve a, Curve b)
        {
            IntersectResult result = new IntersectResult();
            if (Curve.PlanarCurveCollision(a, b, Plane.WorldXY, 0.01f))
            {
                Curve[] unionCurveArray = Curve.CreateBooleanIntersection(a, b);
                if (unionCurveArray.Length > 0)
                {
                    result.intersect = true;
                    result.unionCurve = unionCurveArray[0];

                    // Find the smallest dimesion of unionCurve
                    Point3d minPoint = result.unionCurve.GetBoundingBox(false).Min;
                    Point3d maxPoint = result.unionCurve.GetBoundingBox(false).Max;

                    if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                    {
                        result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                        if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                            result.reboundingVector.Y *= -1;
                    }
                    else
                    {
                        result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                        if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                            result.reboundingVector.X *= -1;
                    }


                }
            }
            else
            {
                result.intersect = false;
                result.reboundingVector = Vector2d.Unset;
                result.unionCurve = null;
            }
            return result;
        }

        private struct IntersectResult
        {
            public Vector2d reboundingVector;
            public bool intersect;
            public Curve unionCurve;
        }

        private double GetRoomXYProportion(Curve room)
        {
            return (room.GetBoundingBox(false).Diagonal.X / (double)room.GetBoundingBox(false).Diagonal.Y);
        }


        private void Shuffle(ref List<Curve> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                Curve value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<string> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private List<Curve> AdjacentContraction(List<Curve> roomCurves, List<string> adjacenceStrings, Curve boundary, out List<Line> adjLines)
        {

            List<Adjacence> adjacences = new List<Adjacence>();

            foreach (string adjString in adjacenceStrings)
            {
                adjacences.Add(new Adjacence());
                adjacences[adjacences.Count - 1].aIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjacences[adjacences.Count - 1].bIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            foreach (Adjacence adj in adjacences)
            {
                Vector3d attractVector = roomCurves[adj.aIndex].GetBoundingBox(false).Center - roomCurves[adj.bIndex].GetBoundingBox(false).Center;

                Vector3d aDim = roomCurves[adj.aIndex].GetBoundingBox(false).Diagonal;
                Vector3d bDim = roomCurves[adj.bIndex].GetBoundingBox(false).Diagonal;

                if (Math.Abs(attractVector.X) - (aDim.X + bDim.X) / 2 > 0.001f ||
                    Math.Abs(attractVector.Y) - (aDim.Y + bDim.Y) / 2 > 0.001f)
                {

                    if (Math.Abs(attractVector.X) > Math.Abs(attractVector.Y))
                    {
                        attractVector.Y = 0;
                        aDim.Y = 0;
                        bDim.Y = 0;
                    }
                    else
                    {
                        attractVector.X = 0;
                        aDim.X = 0;
                        bDim.X = 0;
                    }

                    Point3d attractCenter = roomCurves[adj.aIndex].GetBoundingBox(false).Center + attractVector / 2;
                    if (attractVector.X != 0)
                        if (attractCenter.X > roomCurves[adj.aIndex].GetBoundingBox(false).Center.X)
                            bDim *= -1;
                        else
                            aDim *= -1;
                    else
                        if (attractCenter.Y > roomCurves[adj.aIndex].GetBoundingBox(false).Center.Y)
                        bDim *= -1;
                    else
                        aDim *= -1;


                    roomCurves[adj.aIndex].Translate(-attractVector / 2 + aDim / 2);
                    roomCurves[adj.bIndex].Translate(attractVector / 2 + bDim / 2);
                }
            }

            adjLines = new List<Line>();

            foreach (Adjacence adj in adjacences)
            {
                adjLines.Add(new Line(roomCurves[adj.aIndex].GetBoundingBox(false).Center, roomCurves[adj.bIndex].GetBoundingBox(false).Center));
            }

            return roomCurves;
        }

        private class Adjacence
        {
            public int aIndex;
            public int bIndex;
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                // You can add image files to your project resources and access them like this:
                //return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{7b00cbd7-910f-47cf-9601-718a8d999506}"); }
        }
    }
}


<./studies\Study4\David.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Rhino.Geometry;

namespace TestComponent
{
    public class ModifiableEventArgs : EventArgs
    {
        public ModifiableEventArgs(double value)
        {
            Value = value;
        }
        public double Value { get; set; }
    }
    public interface IModifiable
    {
        event EventHandler<ModifiableEventArgs> ModifyValue;
    }
    public class ComponentAddNumbers : GH_Component, IModifiable
    {
        public ComponentAddNumbers()
          : base("GetHouseProgram", "GetHouseProgram",
              "GetHouseProgram",
              "FloorPlanGen", "House Program Representation")
        { }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("First number", "A", "First number in addition", GH_ParamAccess.item, 2.0);
            pManager.AddNumberParameter("Second number", "B", "Second number in addition", GH_ParamAccess.item, 5.0);
        }
        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddNumberParameter("Result", "C", "Added result", GH_ParamAccess.item);
        }

        public event EventHandler<ModifiableEventArgs> ModifyValue;
        protected override void SolveInstance(IGH_DataAccess da)
        {
            double a = 0.0;
            double b = 0.0;
            if (!da.GetData(0, ref a)) return;
            if (!da.GetData(1, ref b)) return;

            double result = a + b;

            if (ModifyValue != null)
            {
                ModifiableEventArgs e = new ModifiableEventArgs(result);
                ModifyValue(this, e);
                result = e.Value;
            }

            da.SetData(0, result);
        }

        public override Guid ComponentGuid
        {
            get { return new Guid("{6E7FB9B7-38CE-48F1-BE1D-FA8C1728C984}"); }
        }
    }

    internal class AttributesNumberMultiplier : GH_Attributes<ObjectNumberMultiplier>
    {
        public AttributesNumberMultiplier(ObjectNumberMultiplier owner)
          : base(owner)
        {

        }

        public override bool AllowMessageBalloon
        {
            get { return false; }
        }
        public override bool HasInputGrip
        {
            get { return false; }
        }
        public override bool HasOutputGrip
        {
            get { return false; }
        }

        private const int InnerRadius = 30;
        private const int OuterRadius = 90;

        public override bool IsPickRegion(PointF point)
        {
            return Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, point);
        }
        protected override void Layout()
        {
            Pivot = GH_Convert.ToPoint(Pivot);
            Bounds = new RectangleF(Pivot.X - OuterRadius, Pivot.Y - OuterRadius, 2 * OuterRadius, 2 * OuterRadius);
        }

        protected RectangleF InnerBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterRadius - InnerRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {
            switch (channel)
            {
                case GH_CanvasChannel.Wires:
                    graphics.FillEllipse(Brushes.HotPink, Bounds);
                    foreach (IModifiable mod in Owner.TargetObjects())
                    {
                        if (mod == null)
                            continue;

                        IGH_DocumentObject obj = mod as IGH_DocumentObject;
                        if (obj == null)
                            continue;

                        DrawTargetArrow(graphics, obj.Attributes.Bounds);
                    }
                    break;

                case GH_CanvasChannel.Objects:
                    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerBounds, GH_Palette.Normal, InnerRadius, 0);
                    capsule.Render(graphics, Selected, Owner.Locked, true);
                    capsule.Dispose();

                    string text = string.Format("{0:0.00}", Owner.Factor);
                    Grasshopper.GUI.GH_GraphicsUtil.RenderCenteredText(graphics, text, GH_FontServer.Large, Color.Black, Pivot);
                    break;
            }
        }

        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            PointF cp = Grasshopper.GUI.GH_GraphicsUtil.BoxClosestPoint(Pivot, target);
            double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            if (distance < OuterRadius)
                return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterRadius - 2);
            PointF tp = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));

            Pen arrowPen = new Pen(Color.HotPink, OuterRadius - InnerRadius);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }

        private bool _drawing;
        private RectangleF _drawingBox;

        public override GH_ObjectResponse RespondToMouseDown(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            _drawing = false;
            _drawingBox = InnerBounds;

            if (e.Button == System.Windows.Forms.MouseButtons.Left)
            {
                // If on outer disc, but not in inner disc.. then start a wire drawing process.
                bool onOuterDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, e.CanvasLocation);
                bool onInnerDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(InnerBounds, e.CanvasLocation);
                if (onOuterDisc && !onInnerDisc)
                {
                    // Begin arrow drawing behaviour.
                    _drawing = true;
                    sender.CanvasPostPaintObjects += CanvasPostPaintObjects;
                    return GH_ObjectResponse.Capture;
                }
            }

            // Otherwise revert to default behaviour.
            return base.RespondToMouseDown(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseMove(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawingBox = new RectangleF(e.CanvasLocation, new SizeF(0, 0));

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                    {
                        if (att.DocObject is IModifiable)
                            _drawingBox = att.Bounds;
                    }
                }
                sender.Invalidate();
                return GH_ObjectResponse.Handled;
            }

            return base.RespondToMouseMove(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseUp(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawing = false;
                sender.CanvasPostPaintObjects -= CanvasPostPaintObjects;

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                        if (att.DocObject is IModifiable)
                        {
                            Owner.RecordUndoEvent("Add Modifier");
                            Owner.AddTarget(att.DocObject.InstanceGuid);
                            IGH_ActiveObject obj = att.DocObject as IGH_ActiveObject;
                            if (obj != null)
                                obj.ExpireSolution(true);
                        }
                }

                sender.Invalidate();
                return GH_ObjectResponse.Release;
            }

            return base.RespondToMouseUp(sender, e);
        }
        void CanvasPostPaintObjects(GH_Canvas sender)
        {
            if (!_drawing) return;
            DrawTargetArrow(sender.Graphics, _drawingBox);
        }
    }


    public class ObjectNumberMultiplier : GH_ActiveObject, IGH_InstanceGuidDependent
    {
        public ObjectNumberMultiplier()
          : base("RoomCircle", "RoomCircle",
              "RoomCircle",
              "FloorPlanGen", "House Program Representation")
        {
            Random random = new Random();
            Factor = Math.Round(random.NextDouble() * 5, 1);
        }
        public override void CreateAttributes()
        {
            m_attributes = new AttributesNumberMultiplier(this);
        }
        public override Guid ComponentGuid
        {
            get { return new Guid("{65268634-7FE9-405C-BA36-BD9806F410EA}"); }
        }

        private readonly List<Guid> _targetIds = new List<Guid>();
        private readonly List<IModifiable> _targetObjs = new List<IModifiable>();

        public void AddTarget(Guid target)
        {
            if (_targetIds.Contains(target))
                return;
            _targetIds.Add(target);
            _targetObjs.Clear();
        }
        public void RemoveTarget(Guid target)
        {
            _targetIds.Remove(target);
            _targetObjs.Clear();
        }

        public IEnumerable<IModifiable> TargetObjects()
        {
            if (_targetIds.Count != _targetObjs.Count)
            {
                GH_Document doc = OnPingDocument();
                if (doc == null)
                    return new IModifiable[] { };

                _targetObjs.Clear();
                foreach (Guid id in _targetIds)
                {
                    IGH_DocumentObject obj = doc.FindObject(id, true);
                    if (obj == null)
                    {
                        _targetObjs.Add(null);
                        continue;
                    }
                    _targetObjs.Add(obj as IModifiable);
                }
            }

            return _targetObjs;
        }

        public override void AddedToDocument(GH_Document document)
        {
            document.SolutionStart += DocumentSolutionStart;
        }
        public override void RemovedFromDocument(GH_Document document)
        {
            document.SolutionStart -= DocumentSolutionStart;
        }
        void DocumentSolutionStart(object sender, GH_SolutionEventArgs e)
        {
            foreach (IModifiable mod in TargetObjects())
            {
                mod.ModifyValue -= ModifyValue;
                mod.ModifyValue += ModifyValue;
            }
        }
        void ModifyValue(object sender, ModifiableEventArgs e)
        {
            // First make sure the target object is still in the same document.
            IGH_DocumentObject obj = sender as IGH_DocumentObject;
            if (obj == null) return;
            if (obj.OnPingDocument().RuntimeID != OnPingDocument().RuntimeID)
                return;

            // If everything is hunky dory, multiply the value.
            if (!Locked)
                e.Value *= Factor;
        }

        public override void ComputeData()
        {
            Factor = Math.Round((new Random(Guid.NewGuid().GetHashCode()).NextDouble() * 10), 1);

            foreach (IModifiable mod in TargetObjects())
            {
                mod.ModifyValue -= ModifyValue;
                mod.ModifyValue += ModifyValue;
            }
            base.ComputeData();
        }

        public double Factor { get; set; }
        public override bool DependsOn(IGH_ActiveObject potentialSource)
        {
            return false;
        }
        public override bool IsDataProvider
        {
            get { return false; }
        }

        public override bool Write(GH_IO.Serialization.GH_IWriter writer)
        {
            writer.SetDouble("MultiplierFactor", Factor);
            writer.SetInt32("TargetCount", _targetIds.Count);
            for (int i = 0; i < _targetIds.Count; i++)
                writer.SetGuid("TargetID", i, _targetIds[i]);

            return base.Write(writer);
        }
        public override bool Read(GH_IO.Serialization.GH_IReader reader)
        {
            Factor = reader.GetDouble("MultiplierFactor");

            _targetIds.Clear();
            _targetObjs.Clear();
            int targetCount = reader.GetInt32("TargetCount");
            for (int i = 0; i < targetCount; i++)
            {
                Guid id = Guid.Empty;
                if (reader.TryGetGuid("TargetID", i, ref id))
                    AddTarget(id);
            }

            return base.Read(reader);
        }

        void IGH_InstanceGuidDependent.InstanceGuidsChanged(SortedDictionary<Guid, Guid> map)
        {
            _targetObjs.Clear();
            for (int i = 0; i < _targetIds.Count; i++)
            {
                Guid id = _targetIds[i];
                if (map.ContainsKey(id))
                    _targetIds[i] = map[id];
            }
        }
    }
}

<./studies\Study4\MagnetizingRooms.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class MagnetizingRooms : GH_Component
    {

        Random random = new Random();

        List<RoomCells> bestRoomCellsList = new List<RoomCells>(); // The one that actually means something. It stores room's dimensions for all rooms of bestGrid
        List<RoomCells> roomCellsList = new List<RoomCells>();

        // That's needed for AppendAdditionalMenuItems functions.
        bool oneSideCorridorsChecked = true;
        bool twoSidesCorridorsChecked = false;
        bool allSidesCorridorsChecked = false;

        ToolStripMenuItem DropDown_OneSideCor;
        ToolStripMenuItem DropDown_TwoSidesCor;
        ToolStripMenuItem DropDown_AllSidesCor; 

        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public MagnetizingRooms()
          : base("MagnetizingRooms", "MagnetizingRooms",
              "MagnetizingRooms",
              "FloorPlanGen", "Study_4")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddPointParameter("Starting Points", "Starting Points", "Starting Points", GH_ParamAccess.list);
            pManager.AddTextParameter("Room Areas", "Areas", "Areas", GH_ParamAccess.item, "20, 50, 40, 30, 40");
            //pManager.AddGenericParameter("RoomList", "RoomList", "RoomList", GH_ParamAccess.list);
            pManager.AddIntegerParameter("Iterations", "Iterations", "Iteratins (n*n*n)", GH_ParamAccess.item, 3);
            pManager.AddNumberParameter("MaxAdjDistance", "MaxAdjDistance", "MaxAdjDistance", GH_ParamAccess.item, 3);
            pManager.AddTextParameter("Adjacencies", "Adjacencies", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, "0 - 0");
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddIntegerParameter("Grid", "Grid", "Grid", GH_ParamAccess.list);
            pManager.AddIntegerParameter("xGridDim", "xGridDim", "xGridDim", GH_ParamAccess.item);
            pManager.AddIntegerParameter("RoomOrder", "RoomOrder", "RoomOrder", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<Curve> rooms = new List<Curve>();
            List<int> dims = new List<int>();
            int iterations = 0;
            List<int> roomAreas = new List<int>();
            string roomsInput = "";
            List<int> gridOutput = new List<int>();
            List<string> adjStrList = new List<string>();
            double maxAdjDistance = 0;
            int entranceIndexInRoomAreas = -1;



            DA.GetData("Room Areas", ref roomsInput);

            List<GH_ObjectWrapper> roomListWrappers = new List<GH_ObjectWrapper>();
            List<RoomInstance> roomList = new List<RoomInstance>();

           /* DA.GetDataList("RoomList", roomListWrappers);
            foreach (GH_ObjectWrapper wrapper in roomListWrappers)
            {
                roomList.Add(wrapper.Value as RoomInstance);
                if (RoomInstance.entranceIds.Contains((wrapper.Value as RoomInstance).RoomId))
                    entranceIndexInRoomAreas = roomList.Count;
            }*/

            

              for (int i = 0; i < roomsInput.Split(',').Length; i++)
              {
                  roomAreas.Add(Int16.Parse(roomsInput.Split(',')[i]));
                roomList.Add(new RoomInstance() { RoomArea = Int16.Parse(roomsInput.Split(',')[i]) });
                  if (roomAreas[roomAreas.Count - 1] < 0)
                  {
                      roomAreas[roomAreas.Count - 1] *= -1;
                      entranceIndexInRoomAreas = i + 1;
                  }
              }


            int x = 0;
            int y = 0;

            DA.GetData("Iterations", ref iterations);
            DA.GetData("MaxAdjDistance", ref maxAdjDistance);
            DA.GetDataList("Adjacencies", adjStrList);

            // Let's deal with getting boundary curve
            Curve boundaryCrv = new PolylineCurve();
            DA.GetData("Boundary", ref boundaryCrv);
            x = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.X);
            y = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.Y);

            int[,] grid = new int[x, y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    if (boundaryCrv.Contains(new Point3d(boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X + i + 0.5f
                    , boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y + j + 0.5f, 0)) == PointContainment.Inside)
                        grid[i, j] = 0;
                    else
                        grid[i, j] = 200;

            List<Point3d> startingPoints = new List<Point3d>();
            DA.GetDataList("Starting Points", startingPoints);


            if (startingPoints == null)
                grid[x / 2, y / 2] = -1;
            else
                foreach (Point3d point in startingPoints)
                {
                    if (boundaryCrv.Contains(point) == PointContainment.Inside)
                    {
                        int xIndex = (int)Math.Floor(point.X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X);
                        int yIndex = (int)Math.Floor(point.Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y);
                        grid[xIndex, yIndex] = -1;
                    }
                }



            int[,] adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }


            // Actual program start


            int[,] bestGrid = grid.Clone() as int[,];
            int[,] startGrid = grid.Clone() as int[,];




            for (int i = 0; i < iterations; i++)
            {
                grid = startGrid.Clone() as int[,];

                roomCellsList.Clear();
                foreach (RoomInstance room in roomList)
                    roomCellsList.Add(new RoomCells());

                bool placedEntranceRoom = false;

                //  grid[1, 1] = -1;

                for (int j = 0; j < roomList.Count; j++)
                {
                    List<IntPair> roomOrderList = new List<IntPair>();

                    roomOrderList.Add(new IntPair(-1, -1));

                    for (int w = 1; w <= roomList.Count; w++)
                        if (!GridContains(grid, w))
                            roomOrderList.Add(new IntPair(w, 0));
                        else
                            roomOrderList.Add(new IntPair(w, -1));

                    for (int q = 0; q < adjArray.GetLength(0); q++)
                    {
                        if (GridContains(grid, roomOrderList[adjArray[q, 1]].roomNumber) && !GridContains(grid, roomOrderList[adjArray[q, 0]].roomNumber))
                            roomOrderList[adjArray[q, 0]] = new IntPair(roomOrderList[adjArray[q, 0]].roomNumber, roomOrderList[adjArray[q, 0]].AdjNum + 1 + random.NextDouble() * 0.05f);

                        if (GridContains(grid, roomOrderList[adjArray[q, 0]].roomNumber) && !GridContains(grid, roomOrderList[adjArray[q, 1]].roomNumber))
                            roomOrderList[adjArray[q, 1]] = new IntPair(roomOrderList[adjArray[q, 1]].roomNumber, roomOrderList[adjArray[q, 1]].AdjNum + 1 + random.NextDouble() * 0.05f);

                    }
                    roomOrderList = roomOrderList.OrderBy(key => -key.AdjNum).ToList();

                    int roomNum;

                    if (RoomInstance.entranceIds.Count > 0 && entranceIndexInRoomAreas >= 0 && placedEntranceRoom == false)
                    {
                        roomNum = entranceIndexInRoomAreas;
                        placedEntranceRoom = true;
                    }
                    else if (roomOrderList[0].AdjNum > 0) // If at least one unplaced room is adjacent to at least one placed room, then place it
                        roomNum = roomOrderList[0].roomNumber;
                    else // If no, then place the most adjacent room overal
                    {
                        roomOrderList = new List<IntPair>();

                        roomOrderList.Add(new IntPair(-1, -1));

                        for (int w = 1; w <= roomList.Count; w++)
                            if (!GridContains(grid, w))
                                roomOrderList.Add(new IntPair(w, 0));
                            else
                                roomOrderList.Add(new IntPair(w, -1));

                        for (int q = 0; q < adjArray.GetLength(0); q++)
                        {
                            if (!GridContains(grid, roomOrderList[adjArray[q, 0]].roomNumber))
                                roomOrderList[adjArray[q, 0]] = new IntPair(roomOrderList[adjArray[q, 0]].roomNumber, roomOrderList[adjArray[q, 0]].AdjNum + 1 + random.NextDouble() * 0.05f);

                            if (!GridContains(grid, roomOrderList[adjArray[q, 1]].roomNumber))
                                roomOrderList[adjArray[q, 1]] = new IntPair(roomOrderList[adjArray[q, 1]].roomNumber, roomOrderList[adjArray[q, 1]].AdjNum + 1 + random.NextDouble() * 0.05f);

                        }
                        roomOrderList = roomOrderList.OrderBy(key => -key.AdjNum).ToList();
                        roomNum = roomOrderList[0].roomNumber;
                    }


                    //if (!TryPlaceNewRoom(roomAreas[roomNum - 1], roomNum, ref grid, adjArray, maxAdjDistance))
                    if (!PlaceNewRoom_TEST(ref grid, roomList[roomNum - 1].RoomArea, roomNum, adjArray, maxAdjDistance, roomList[roomNum - 1].isHall))
                    { break; }

                }


                /*  // Let's find rooms on the grid that have missing connections. Let's do it for every iteration. (May take a lot of operational time)
                  List<int> missingAdj = MissingRoomAdjacences(grid, adjArray);
                  for (int k = 0; k < missingAdj.Count; k++)
                  {
                      missingAdj = MissingRoomAdjacences(grid, adjArray);

                      if (missingAdj[k] > 0 && GridContains(grid, k + 1))
                      {
                          RemoveRoomFromGrid(ref grid, roomCellsList[k]);
                          if (PlaceNewRoom_TEST(ref grid, roomList[k].RoomArea, k + 1, adjArray, maxAdjDistance, roomList[k].isHall))
                              AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "Placed ID_" + (k + 1) + ": " + missingAdj[k]);
                      }
                  }
                  */



                if (GridAIsBetterThanB(grid, bestGrid))
                {
                    bestGrid = grid.Clone() as int[,];
                    bestRoomCellsList = roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells));
                }
            }

            // At the end let's convert all needed rooms to halls
            for (int i = 0; i < bestGrid.GetLength(0); i++)
                for (int j = 0; j < bestGrid.GetLength(1); j++)
                    if (bestGrid[i, j] > 0 && bestGrid[i, j] <= roomList.Count)
                        if (roomList[bestGrid[i, j] - 1].isHall)
                            bestGrid[i, j] = -1;

            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                {
                    if (bestGrid[i, j] != 200)
                        gridOutput.Add(bestGrid[i, j]);
                    else
                        gridOutput.Add(0);
                }

            DA.SetDataList(0, gridOutput);
            DA.SetData(1, x);

        }

        public List<int> MissingRoomAdjacences(int[,] grid, int[,] adjArray)
        {
            List<int> missingAdj = new List<int>();// (adjArray.GetLength(0));
            for (int i = 0; i < adjArray.GetLength(0); i++)
                missingAdj.Add(0);

            for (int l = 0; l < adjArray.GetLength(0); l++)
            {
                bool exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 0])
                            exists = true;
                if (!exists)
                    missingAdj[adjArray[l, 1] - 1]++;


                exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 1])
                            exists = true;
                if (!exists)
                    missingAdj[adjArray[l, 0] - 1]++;
            }

            return missingAdj;
        }

        public bool PlaceNewRoom_TEST(ref int[,] grid, double area, int roomNum, int[,] adjArray, double maxAdjDistance, bool isHall = false)
        {
            int[,] availableCellsGrid = new int[grid.GetLength(0), grid.GetLength(1)];  //= grid;
            int[,] room = new int[50, 50];

            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == roomNum && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == roomNum && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);


            //  for (int i = 0; i < adjArray.GetLength(0); i++)
            //      Rhino.RhinoApp.WriteLine(adjArray[i,0].ToString() + " + "+ adjArray[i, 1].ToString());

            List<int> divisors = new List<int>();
            for (int i = 2; i <= Math.Sqrt(area); i++)
                if (area % i == 0)
                    divisors.Add(i);

            area--;
            do
            {
                divisors.Clear();
                area++;
                for (int i = 1; i <= Math.Sqrt(area); i++)
                    if (area % i == 0)
                        divisors.Add(i);

            } while (area / (double)divisors[divisors.Count - 1] / (double)divisors[divisors.Count - 1] > 1.5f);

            xDim = divisors[divisors.Count - 1];
            yDim = (int)(area / xDim);

            int temp = xDim;
            if (random.Next(2) == 0)
            {
                xDim = yDim;
                yDim = temp;
            }


            // Choose the corridor generation mode according to MenuItemDropDown selection
            if (oneSideCorridorsChecked)
            {
                if (random.Next(2) == 0)
                {
                    room = new int[xDim + 1, yDim];
                    for (int i = 0; i < xDim + 1; i++)
                        for (int j = 0; j < yDim; j++)
                            if (i == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNum;
                }
                else
                {
                    room = new int[xDim, yDim + 1];
                    for (int i = 0; i < xDim; i++)
                        for (int j = 0; j < yDim + 1; j++)
                            if (j == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNum;
                }

            }
            else if (twoSidesCorridorsChecked)
            {
                room = new int[xDim + 1, yDim + 1];
                for (int i = 0; i < xDim + 1; i++)
                    for (int j = 0; j < yDim + 1; j++)
                        if (i == 0 || j == 0)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNum;
            }
            else if (allSidesCorridorsChecked)
            {
                xDim--;
                yDim--;

                room = new int[xDim + 2, yDim + 2];
                for (int i = 0; i <= xDim + 1; i++)
                    for (int j = 0; j <= yDim + 1; j++)
                        if (i == 0 || j == 0 || i == xDim + 1 || j == yDim + 1)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNum;
            }

            // Start filling availableCellsGrid: 0 = not available, 1 = available
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    availableCellsGrid[i, j] = 0;

                    if (grid[i, j] == 0)
                        for (int l = -1; l <= 1; l++)
                            for (int k = -1; k <= 1; k++)
                                if ((l == 0 || k == 0) && l != k)
                                    if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))
                                        if (grid[i + l, j + k] == -1)
                                        {
                                            if (CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                                            {
                                                availableCellsGrid[i, j] = 1;
                                                // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "avalCell! " + roomNum + ": " + i + "_" + j);
                                            }
                                        }
                }


            List<RoomPlacementSolution> placementSolutions = new List<RoomPlacementSolution>();



            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {

                    if (availableCellsGrid[i, j] == 1)
                    {
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.BottomLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomLeft, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.BottomLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.BottomRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomRight, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.BottomRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.TopLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopLeft, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.TopLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.TopRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopRight, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.TopRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                    }
                }


            //placementSolutions = placementSolutions.OrderBy(a => new Random(Guid.NewGuid().GetHashCode()).Next(2) == 0).ToList();
            placementSolutions = placementSolutions.OrderBy(t => -t.score).ToList();

            if (placementSolutions.Count > 0)
            {
                int x = placementSolutions[0].x;
                int y = placementSolutions[0].y;
                int w = placementSolutions[0].room.GetLength(0);
                int h = placementSolutions[0].room.GetLength(1);

                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.TopLeft)
                    x -= w - 1;
                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.BottomRight)
                    y -= h - 1;

                roomCellsList[roomNum - 1] = new RoomCells(x, y, w, h);


                PlaceRoomSolution(placementSolutions[0], placementSolutions[0].room, ref grid, isHall);
                return true;
            }
            else
                return false;
        }

        private double DistanceToRoomNumber_TEST(int[,] grid, int x, int y, int targetNum, double maxDistance = 20)
        {

            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;

                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);

            double minDist = 5000;

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    for (int l = -1; l <= 1; l++)
                        for (int k = -1; k <= 1; k++)
                            if ((l == 0 || k == 0) && l != k)
                                if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))

                                    if (grid[i + l, j + k] == targetNum && distanceGrid[i, j] != -1)
                                        minDist = Math.Min(minDist, distanceGrid[i, j]);
                }

            return minDist;
        }

        private class RoomCells
        {
            public int x;
            public int y;
            public int w;
            public int h;

            public RoomCells() { }

            public RoomCells(int X, int Y, int W, int H)
            {
                x = X;
                y = Y;
                w = W;
                h = H;
            }

            public RoomCells(RoomCells roomCells)
            {
                x = roomCells.x;
                y = roomCells.y;
                w = roomCells.w;
                h = roomCells.h;
            }
        }
        // Now add method for saving RoomCells to a list and then implement removing rooms in case of them having missing adj

        private void RemoveRoomFromGrid(ref int[,] grid, RoomCells roomCells)
        {
            for (int i = roomCells.x; i < roomCells.x + roomCells.w; i++)
                for (int j = roomCells.y; j < roomCells.y + roomCells.h; j++)
                    grid[i, j] = 0;
        }

        private void PlaceRoomSolution(RoomPlacementSolution solution, int[,] room, ref int[,] grid, bool isHall = false)
        {
            switch (solution.roomPosition)
            {
                case RoomPosition.TopRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[i - solution.x, j - solution.y];
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[i - solution.x, -(j - solution.y)];
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[-(i - solution.x), -(j - solution.y)];
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[-(i - solution.x), j - solution.y];
                    }
                    break;
            }
        }

        private int GetRoomScore(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            int score = 0;

            List<int> cellsToCheck = new List<int>();



            if (roomPosition == RoomPosition.BottomLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + 1]);

                    if (x - i >= 0 && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y - j >= 0)
                        cellsToCheck.Add(grid[x + 1, y - j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.BottomRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + 1]);

                    if (x + i < grid.GetLength(0) && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - 1, y - j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y - j > 0)
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.TopLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - 1]);

                    if (x - i >= 0 && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + 1, y + j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y + j]);
                }
            }

            if (roomPosition == RoomPosition.TopRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - 1]);

                    if (x + i < grid.GetLength(0) && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - 1, y + j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y + j]);
                }
            }

            foreach (int a in cellsToCheck)
                if (a != 0 && a != 200)
                    score++;

            return score;
        }

        private class RoomPlacementSolution
        {
            public RoomPlacementSolution(int roomX, int roomY, RoomPosition position, int[,] mRoom, int mScore)
            {
                x = roomX;
                y = roomY;
                roomPosition = position;
                this.score = mScore;
                this.room = mRoom.Clone() as int[,];
            }

            public RoomPlacementSolution(RoomPlacementSolution a)
            {
                x = a.x;
                y = a.y;
                roomPosition = a.roomPosition;
                this.score = a.score;
                this.room = a.room.Clone() as int[,];
            }

            public int GetRoomNum()
            {
                int max = -1;
                for (int i = 0; i < room.GetLength(0); i++)
                    for (int j = 0; j < room.GetLength(1); j++)
                        max = Math.Max(max, room[i, j]);
                return max;
            }

            public RoomPosition roomPosition;
            public int score = 0;
            public int x;
            public int y;
            public int[,] room;
        }

        private enum RoomPosition { TopRight, BottomRight, BottomLeft, TopLeft, Undefined }


        private bool RoomIsPlaceable_TEST(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            switch (roomPosition)
            {
                case RoomPosition.TopRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (x - room.GetLength(0) >= 0 && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (x - room.GetLength(0) >= 0 && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

            }
            return false;
        }



        public struct IntPair
        {
            public IntPair(int a1, int b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }

            public IntPair(int a1, double b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }
            public int roomNumber;
            public double AdjNum;
        }

        public bool CellsAreNearerThan(int x, int y, List<int> targetCellsList, int[,] grid, double maxDistance = 2)
        {
            foreach (int targetCell in targetCellsList)
            {
                if (!CellIsNearerThan(x, y, targetCell, grid, maxDistance))
                    return false;
            }
            return true;
        }



        public bool CellIsNearerThan(int x, int y, int targetCellNumber, int[,] grid, double maxDistance = 2)
        {
            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;
                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;
            availabilityGrid[x, y] = true;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);


            int minX = -1;
            int minY = -1;
            double minTargetDist = -1;

            for (int i = 0; i < availabilityGrid.GetLength(0); i++)
                for (int j = 0; j < availabilityGrid.GetLength(1); j++)
                {
                    if (grid[i, j] == targetCellNumber)
                        if ((distanceGrid[i, j] < minTargetDist || minTargetDist == -1) && distanceGrid[i, j] > 0)
                        {
                            minTargetDist = distanceGrid[i, j];
                            minX = i;
                            minY = j;
                        }
                }

            if (minTargetDist != -1 && minTargetDist <= maxDistance)
                return true;
            else
                return false;
        }

        public void SetCellDistancesAround(int x, int y, ref double[,] distanceGrid, ref bool[,] availabilityGrid, double maxDist)
        {
            List<List<int>> recursionList = new List<List<int>>();


            for (int i = -1; i <= 1; i++)
                for (int j = -1; j <= 1; j++)
                {
                    if (x + i >= 0 && x + i < distanceGrid.GetLength(0) &&
                        y + j >= 0 && y + j < distanceGrid.GetLength(1))
                        if (!(i == 0 && j == 0))
                        {
                            double addValue;
                            if (i * j != 0) //if the cell is corner cell
                                addValue = 1.414f; //sqrt(2)
                            else
                                addValue = 1;

                            if (availabilityGrid[x, y])
                                if (distanceGrid[x + i, y + j] > distanceGrid[x, y] + addValue || distanceGrid[x + i, y + j] == -1)
                                {
                                    distanceGrid[x + i, y + j] = distanceGrid[x, y] + addValue;
                                    if (distanceGrid[x + i, y + j] <= maxDist)
                                        recursionList.Add(new List<int>() { x + i, y + j });
                                }
                        }
                }
            // doesnt really affect performance
            foreach (List<int> item in recursionList)
                SetCellDistancesAround(item[0], item[1], ref distanceGrid, ref availabilityGrid, maxDist);

            return;
        }

        bool GridAIsBetterThanB(int[,] A, int[,] B)
        {
            int aCount = 0;
            int bCount = 0;

            List<int> aRooms = new List<int>();
            List<int> bRooms = new List<int>();

            for (int i = 0; i < A.GetLength(0); i++)
                for (int j = 0; j < A.GetLength(1); j++)
                {
                    if (A[i, j] == 0)
                        aCount++;
                    if (B[i, j] == 0)
                        bCount++;

                    if (aRooms.FindIndex(a => a == A[i, j]) == -1)
                        aRooms.Add(A[i, j]);

                    if (bRooms.FindIndex(b => b == B[i, j]) == -1)
                        bRooms.Add(B[i, j]);

                }

            // return aRooms.Count > bRooms.Count;
            return aCount < bCount;
        }


        public bool GridContains(int[,] grid, int val)
        {
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                    if (grid[i, j] == val)
                        return true;
            return false;
        }

        /*
        bool TryPlaceNewRoom(int area, int num, ref int[,] grid, int[,] adjArray, double maxAdjDistance = 3f)
        {
            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == num && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == num && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);


            //  for (int i = 0; i < adjArray.GetLength(0); i++)
            //      Rhino.RhinoApp.WriteLine(adjArray[i,0].ToString() + " + "+ adjArray[i, 1].ToString());

            List<int> divisors = new List<int>();
            for (int i = 2; i <= area; i++)
                if (area % i == 0)
                    divisors.Add(i);

            while (divisors.Count < 4)
            {
                divisors.Clear();
                area++;
                for (int i = 2; i <= area; i++)
                    if (area % i == 0)
                        divisors.Add(i);

            }

            xDim = divisors[divisors.Count / 2 - random.Next(2)];
            yDim = area / xDim;


            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1) - 1; j++)
                {
                    if (grid[i, j] == -1)
                        if (grid[i, j + 1] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i, j + 1, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i, j + 1, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                        else if (grid[i, j - 1] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i, j - 1, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i, j - 1, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }

                        else if (grid[i + 1, j] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i + 1, j, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i + 1, j, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                        else if (grid[i - 1, j] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i - 1, j, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i - 1, j, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                }

            return false;
        }
        */

        private bool EnoughSpaceOnThe(int xDim, int yDim, int roomNum, int gridX, int gridY, ref int[,] grid, bool preserveGrid = false)
        {

            // roomNum++; // Yes, coz rooms should start from 1, not from 0 // No, coz this solution sucks

            int xM = 1;
            int yM = 1;


            for (int it = 0; it < 4; it++)
            {

                switch (it)
                {
                    default: break;

                    case (0):
                        xM = 1;
                        yM = 1;
                        break;

                    case (1):
                        xM = -1;
                        yM = 1;
                        break;

                    case (2):
                        xM = 1;
                        yM = -1;
                        break;
                    case (3):
                        xM = -1;
                        yM = -1;
                        break;
                }

                if (gridX + xDim * xM >= grid.GetLength(0) || gridX + xDim * xM < 0 ||
                    gridY + yDim * yM >= grid.GetLength(1) || gridY + yDim * yM < 0)
                {
                    break;
                }

                bool xDimIsLessThanYDim = false;
                bool solutionFound = false;

                if (xDim > yDim)
                {
                    xDim++;
                    xDimIsLessThanYDim = true;
                }
                else
                {
                    xDimIsLessThanYDim = false;
                    yDim++;
                }

                // if one of the cells is not free -> terminate
                solutionFound = true;
                for (int i = 0; i < xDim; i++)
                    for (int j = 0; j < yDim; j++)
                    {
                        if (grid[gridX + i * xM, gridY + j * yM] != 0)
                        {
                            // break
                            solutionFound = false;
                            i = xDim;
                            j = yDim;
                        }
                    }

                if (solutionFound)
                {
                    if (!preserveGrid)
                        for (int i = 0; i < xDim; i++)
                            for (int j = 0; j < yDim; j++)
                            {
                                if ((xDimIsLessThanYDim && i == 0) || (!xDimIsLessThanYDim && j == 0))
                                    grid[gridX + i * xM, gridY + j * yM] = -1;
                                else
                                    grid[gridX + i * xM, gridY + j * yM] = roomNum;
                            }

                    return true;
                }

                if (xDimIsLessThanYDim)
                {
                    xDim--;
                    yDim++;
                    xDimIsLessThanYDim = false;
                }
                else
                {
                    xDimIsLessThanYDim = true;
                    yDim--;
                    xDim++;
                }

                solutionFound = true;
                for (int i = 0; i < xDim; i++)
                    for (int j = 0; j < yDim; j++)
                    {
                        if (grid[gridX + i * xM, gridY + j * yM] != 0)
                        {
                            // break
                            solutionFound = false;
                            i = xDim;
                            j = yDim;
                        }
                    }


                if (solutionFound)
                {
                    if (!preserveGrid)
                        for (int i = 0; i < xDim; i++)
                            for (int j = 0; j < yDim; j++)
                            {
                                if ((xDimIsLessThanYDim && i == 0) || (!xDimIsLessThanYDim && j == 0))
                                    grid[gridX + i * xM, gridY + j * yM] = -1;
                                else
                                    grid[gridX + i * xM, gridY + j * yM] = roomNum;
                            }

                    return true;
                }
            }
            return false;
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }




        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{78fe6801-611b-453f-946a-2fda953393eb}"); }
        }


        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            DropDown_OneSideCor = Menu_AppendItem(menu, "One-side corridors", Menu_OneSideCorClick, true, oneSideCorridorsChecked);
            DropDown_TwoSidesCor = Menu_AppendItem(menu, "Two-sides corridors", Menu_TwoSidesCorClick, true, twoSidesCorridorsChecked);
            DropDown_AllSidesCor = Menu_AppendItem(menu, "All-sides corridors", Menu_AllSidesCorClick, true, allSidesCorridorsChecked);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        public void Menu_OneSideCorClick(object sender, EventArgs e)
        {
            if (!oneSideCorridorsChecked)
            {
                oneSideCorridorsChecked = !oneSideCorridorsChecked;

                twoSidesCorridorsChecked = !oneSideCorridorsChecked;
                allSidesCorridorsChecked = !oneSideCorridorsChecked;

                ExpireSolution(true);
            }
        }

        public void Menu_TwoSidesCorClick(object sender, EventArgs e)
        {
            if (!twoSidesCorridorsChecked)
            {
                twoSidesCorridorsChecked = !twoSidesCorridorsChecked;

                oneSideCorridorsChecked = !twoSidesCorridorsChecked;
                allSidesCorridorsChecked = !twoSidesCorridorsChecked;

                ExpireSolution(true);
            }
        }

        public void Menu_AllSidesCorClick(object sender, EventArgs e)
        {
            if (!allSidesCorridorsChecked)
            {
                allSidesCorridorsChecked = !allSidesCorridorsChecked;

                oneSideCorridorsChecked = !allSidesCorridorsChecked;
                twoSidesCorridorsChecked = !allSidesCorridorsChecked;

                ExpireSolution(true);
            }
        }
    }
}

<./studies\Study4\MagnetizingRooms_HeapES.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Attributes;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace Magnetizing_FPG
{
    public class MagnetizingRooms_HeapES : GH_Component
    {

        Random random = new Random();

        List<RoomCells> bestRoomCellsList = new List<RoomCells>(); // The one that actually means something. It stores room's dimensions for all rooms of bestGrid
        List<RoomCells> roomCellsList = new List<RoomCells>();
        List<GridSolution> gridSolutionsHeap;

        // That's needed for AppendAdditionalMenuItems functions.
        bool oneSideCorridorsChecked = false;
        bool twoSidesCorridorsChecked = true;
        bool allSidesCorridorsChecked = false;

        bool corridorsAsAdditionalSpacesChecked = true;

        bool shouldOnlyRecomputeDeadEnds = false;

        bool removeDeadEndsChecked = true;
        bool removeAllCorridorsChecked = false;

        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public MagnetizingRooms_HeapES()
          : base("MagnetizingRooms_HeapES", "MagnetR_HES",
              "MagnetizingRooms_HeapES",
              "FloorPlanGen", "Study_4")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            // pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            // pManager.AddPointParameter("Starting Points", "Starting Points", "Starting Points", GH_ParamAccess.list);
            // pManager.AddGenericParameter("RoomList", "RoomList", "RoomList", GH_ParamAccess.list);
            pManager.AddGenericParameter("House Instance", "HI", "House Instance", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Iterations", "I", "Iteratins (n*n*n)", GH_ParamAccess.item, 3);
            pManager.AddNumberParameter("MaxAdjDistance", "MAD", "MaxAdjDistance", GH_ParamAccess.item, 2);
            // pManager.AddTextParameter("Adjacencies", "Adjacencies", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, "0 - 0");
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddBrepParameter("Corridors", "C", "Corridors as Breps", GH_ParamAccess.item);
            pManager.AddBrepParameter("Room Breps", "Rs", "Rooms as Breps list", GH_ParamAccess.list);
            pManager.AddTextParameter("Room Names", "Ns", "Room Names", GH_ParamAccess.list);
            //pManager.AddSurfaceParameter("GridCells", "GC", "Grid cells as surfaces", GH_ParamAccess.list);
            //pManager.AddIntegerParameter("xGridDim", "G_X", "xGridDim", GH_ParamAccess.item);
            //pManager.AddCurveParameter("Boundary", "B", "Boundary", GH_ParamAccess.item);
            pManager.AddTextParameter("Adjacencies", "A", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.item);
            pManager.AddIntegerParameter("MissingAdjacences", "!A", "Missing Adjacences for every room of the list", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<Curve> rooms = new List<Curve>();
            List<int> dims = new List<int>();
            int iterations = 0;
            List<int> roomAreas = new List<int>();
            List<int> gridOutput = new List<int>();
            List<string> adjStrList = new List<string>();
            double maxAdjDistance = 0;
            int entranceIndexInRoomAreas = -1;
            HouseInstance houseInstance = new HouseInstance();

            GH_ObjectWrapper houseInstanceWrapper = new GH_ObjectWrapper();
            DA.GetData("House Instance", ref houseInstanceWrapper);
            houseInstance = houseInstanceWrapper.Value as HouseInstance;

            List<RoomInstance> roomList = houseInstance.RoomInstances;
            Curve boundaryCrv = houseInstance.boundary;
            int[,] adjArray = houseInstance.adjArray;
            adjStrList = houseInstance.adjStrList;
            List<Point3d> startingPoints = new List<Point3d>();
            startingPoints.Add(houseInstance.startingPoint);

            for (int i = 0; i < roomList.Count; i++)
                if (RoomInstance.entranceIds.Contains(roomList[i].RoomId))
                {
                    entranceIndexInRoomAreas = i + 1;
                    break;
                }

            int x = 0;
            int y = 0;

            DA.GetData("Iterations", ref iterations);
            DA.GetData("MaxAdjDistance", ref maxAdjDistance);

            // Let's deal with setting boundary curve. The curve is rotated so it fits best into rectangle. 
            // Then all cells are generated as surfaces and rotated back again
            // Moreover, we should rotate the starting point also

            double boundaryCurveRotationRad = 0;
            double minBoundaryArea = double.MaxValue;
            if (houseInstance.tryRotateBoundary)

                for (double i = 0; i <= Math.PI / 2f; i += Math.PI / 360f)
                {
                    Curve rotatedBoundaryCurve = boundaryCrv.Duplicate() as Curve;
                    rotatedBoundaryCurve.Rotate(i, Vector3d.ZAxis, rotatedBoundaryCurve.GetBoundingBox(false).Center);
                    double newArea = AreaMassProperties.Compute(new Rectangle3d(new Plane(rotatedBoundaryCurve.GetBoundingBox(false).Center, Vector3d.ZAxis)
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.X
                        , rotatedBoundaryCurve.GetBoundingBox(false).Diagonal.Y).ToNurbsCurve()).Area;

                    if (newArea < minBoundaryArea)
                    {
                        minBoundaryArea = newArea;
                        boundaryCurveRotationRad = i;
                    }
                }
            Point3d rotationCenter = boundaryCrv.GetBoundingBox(false).Center;
            Point3d tempP = startingPoints[0];
            tempP.Transform(Transform.Rotation(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter));
            startingPoints[0] = tempP;
            boundaryCrv.Rotate(boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);


            x = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.X);
            y = (int)Math.Floor(boundaryCrv.GetBoundingBox(false).Diagonal.Y);

            // So the cells are rotated back again, so we can use them

            Point3d originPoint = boundaryCrv.GetBoundingBox(false).Corner(true, true, true);
            Vector3d diagonal = boundaryCrv.GetBoundingBox(false).Diagonal;
            Surface[] gridSurfaceArray = new Surface[x * y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    gridSurfaceArray[j + y * i] = new PlaneSurface(new Plane(
                        Point3d.Origin, Vector3d.ZAxis)
                        , new Interval(originPoint.X + (i) * diagonal.X / x, originPoint.X + (i + 1) * diagonal.X / x)
                        , new Interval(originPoint.Y + (j) * diagonal.Y / y, originPoint.Y + (j + 1) * diagonal.Y / y));


            if (houseInstance.tryRotateBoundary)
                for (int i = 0; i < x; i++)
                    for (int j = 0; j < y; j++)
                        gridSurfaceArray[i + x * j].Rotate(-boundaryCurveRotationRad, Vector3d.ZAxis, rotationCenter);

            int[,] grid = new int[x, y];
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                    if (boundaryCrv.Contains(new Point3d(boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X + i + 0.5f
                    , boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y + j + 0.5f, 0)) == PointContainment.Inside)
                        grid[i, j] = 0;
                    else
                        grid[i, j] = 200;



            if (startingPoints == null)
                grid[x / 2, y / 2] = -1;
                        else
                foreach (Point3d point in startingPoints)
                {
                    if (boundaryCrv.Contains(point) == PointContainment.Inside)
                    {
                        int xIndex = (int)Math.Floor(point.X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X);
                        int yIndex = (int)Math.Floor(point.Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y);
                        grid[xIndex, yIndex] = -1;
                    }
                }


            // Actual program start

            int[,] bestGrid = grid.Clone() as int[,];
            int[,] startGrid = grid.Clone() as int[,];

            List<int> roomOrder = new List<int>();
            bool placedEntranceRoom;

            if (shouldOnlyRecomputeDeadEnds && gridSolutionsHeap != null && gridSolutionsHeap.Count > 0)
            {
                shouldOnlyRecomputeDeadEnds = false;
                iterations = 0;
            }
            else
                gridSolutionsHeap = new List<GridSolution>();

            for (int i = 0; i < iterations; i++)
            {
                for (int l = 0; l < 4; l++)
                {
                    for (int h = 0; h < 1; h++)
                    {
                        if (gridSolutionsHeap.Count > l && i != 0 && i % 3 == 0)
                        {
                            placedEntranceRoom = true;

                            for (int q = 0; q < gridSolutionsHeap[l].grid.GetLength(0); q++)
                                for (int w = 0; w < gridSolutionsHeap[l].grid.GetLength(1); w++)
                                    grid[q, w] = gridSolutionsHeap[l].grid[q, w];

                            roomOrder.Clear();
                            for (int q = 0; q < gridSolutionsHeap[l].roomOrder.Count; q++)
                                roomOrder.Add(gridSolutionsHeap[l].roomOrder[q]);

                            roomCellsList.Clear();
                            for (int q = 0; q < gridSolutionsHeap[l].roomCellsList.Count; q++)
                                roomCellsList.Add(new RoomCells(gridSolutionsHeap[l].roomCellsList[q]));

                            // grid = gridSolutionsHeap[l].grid.Clone() as int[,];
                            // roomOrder = gridSolutionsHeap[l].roomOrder.ConvertAll(p => Convert.ToInt32(p));
                            //roomCellsList = gridSolutionsHeap[l].roomCellsList.ConvertAll(p => new RoomCells(p));

                            // Let's remove last 1-5 rooms from the solution, so we can try to develope it more
                            int roomRemovalCount = 1 + random.Next(5);
                            for (int j = 0; j < roomRemovalCount; j++)
                                if (roomOrder.Count > 1)
                                {
                                    RemoveRoomFromGrid(ref grid, roomCellsList[roomOrder[roomOrder.Count - 1]]);
                                    roomOrder.RemoveAt(roomOrder.Count - 1);
                                }
                        }
                        else
                        {
                            grid = startGrid.Clone() as int[,];
                            roomOrder = new List<int>();
                            placedEntranceRoom = false;

                            roomCellsList.Clear();
                            foreach (RoomInstance room in roomList)
                                roomCellsList.Add(new RoomCells());
                        }

                        // Let's try to place each room in case it is not placed yet
                        for (int j = 0; j < roomList.Count; j++)
                        {
                            if (j == 1 && grid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                    (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] == -1 && roomOrder.Count == 1)
                            {
                                grid[(int)Math.Floor(startingPoints[0].X - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).X),
                                    (int)Math.Floor(startingPoints[0].Y - boundaryCrv.GetBoundingBox(false).Corner(true, true, true).Y)] = 0;
                            }
                            List<IntPair> roomOrderList = new List<IntPair>();
                            //roomOrderList.Add(new IntPair(-1, -1));

                            for (int w = 1; w <= roomList.Count; w++)
                                if (!GridContains(grid, w))
                                    roomOrderList.Add(new IntPair(w, 0));
                                else
                                    roomOrderList.Add(new IntPair(w, -1));

                            for (int q = 0; q < adjArray.GetLength(0); q++)
                            {
                                if (GridContains(grid, roomOrderList[adjArray[q, 1] - 1].roomNumber) && !GridContains(grid, roomOrderList[adjArray[q, 0] - 1].roomNumber))
                                    roomOrderList[adjArray[q, 0] - 1] = new IntPair(roomOrderList[adjArray[q, 0] - 1].roomNumber
                                        , roomOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                                if (GridContains(grid, roomOrderList[adjArray[q, 0] - 1].roomNumber) && !GridContains(grid, roomOrderList[adjArray[q, 1] - 1].roomNumber))
                                    roomOrderList[adjArray[q, 1] - 1] = new IntPair(roomOrderList[adjArray[q, 1] - 1].roomNumber
                                        , roomOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);
                            }
                            roomOrderList = roomOrderList.OrderBy(key => -key.AdjNum).ToList();

                            int roomNum;

                            if (RoomInstance.entranceIds.Count > 0 && entranceIndexInRoomAreas >= 0 && placedEntranceRoom == false)
                            {
                                roomNum = entranceIndexInRoomAreas;
                                placedEntranceRoom = true;
                            }
                            // If at least one unplaced room is adjacent to at least one placed room, then place it
                            else if (roomOrderList[0].AdjNum > 0)
                                roomNum = roomOrderList[0].roomNumber;
                            // If no, then place the most adjacent room overal
                            else
                            {
                                roomOrderList = new List<IntPair>();
                                // roomOrderList.Add(new IntPair(-1, -1));

                                for (int w = 1; w <= roomList.Count; w++)
                                    if (!GridContains(grid, w))
                                        roomOrderList.Add(new IntPair(w, 0));
                                    else
                                        roomOrderList.Add(new IntPair(w, -1));

                                for (int q = 0; q < adjArray.GetLength(0); q++)
                                {
                                    if (!GridContains(grid, roomOrderList[adjArray[q, 0] - 1].roomNumber))
                                        roomOrderList[adjArray[q, 0] - 1] = new IntPair(roomOrderList[adjArray[q, 0] - 1].roomNumber
                                            , roomOrderList[adjArray[q, 0] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                                    if (!GridContains(grid, roomOrderList[adjArray[q, 1] - 1].roomNumber))
                                        roomOrderList[adjArray[q, 1] - 1] = new IntPair(roomOrderList[adjArray[q, 1] - 1].roomNumber
                                            , roomOrderList[adjArray[q, 1] - 1].AdjNum + 1 + random.NextDouble() * 0.1f);

                                }
                                roomOrderList = roomOrderList.OrderBy(key => -key.AdjNum).ToList();
                                roomNum = roomOrderList[0].roomNumber;
                            }


                            if (!GridContains(grid, roomNum))
                            {
                                if (TryPlaceNewRoomToTheGrid(ref grid, (int)roomList[roomNum - 1].RoomArea, roomNum, adjArray, maxAdjDistance, roomList[roomNum - 1].isHall))
                                    roomOrder.Add(roomNum - 1);
                                else
                                    break;
                            }
                        }

                        // Add this new solution to solution heap and remove the ancestor. That's needed for diversity of variants
                        if (gridSolutionsHeap.Count > l && i % 3 == 0)
                        {
                            if (roomOrder.Count > gridSolutionsHeap[l].roomOrder.Count)
                            {
                                gridSolutionsHeap.Add(new GridSolution(grid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), roomOrder));
                                gridSolutionsHeap.RemoveAt(l);
                            }
                        }
                        else
                            gridSolutionsHeap.Add(new GridSolution(grid.Clone() as int[,], roomCellsList.ConvertAll(roomCells => new RoomCells(roomCells)), roomOrder));

                    }
                }
                gridSolutionsHeap = gridSolutionsHeap.OrderBy(solution => -solution.roomOrder.Count).ToList();
                if (gridSolutionsHeap.Count > 8)
                    gridSolutionsHeap.RemoveRange(8, Math.Max(0, gridSolutionsHeap.Count - 8));
            }

            gridSolutionsHeap = gridSolutionsHeap.OrderBy(solution => -solution.roomOrder.Count).ToList() as List<GridSolution>;

           // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, gridSolutionsHeap[0].roomOrder.Count.ToString());
           // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, gridSolutionsHeap[gridSolutionsHeap.Count - 1].roomOrder.Count.ToString());


            bestGrid = gridSolutionsHeap[0].grid.Clone() as int[,];

            if (removeDeadEndsChecked)
            {
                RemoveDeadEnds(ref bestGrid, gridSolutionsHeap[0].roomCellsList);
                //RemoveDeadEnds(ref bestGrid, gridSolutionsHeap[0].roomCellsList);
            }


                if (removeAllCorridorsChecked)
                RemoveAllCorridors(ref bestGrid, gridSolutionsHeap[0].roomCellsList);


            List<int> placedRoomsNums = new List<int>();
            // Remove all '200' cells, they stand for outside boundary of the building
            for (int i = 0; i < x; i++)
                for (int j = 0; j < y; j++)
                {
                    if (bestGrid[i, j] != 200)
                        gridOutput.Add(bestGrid[i, j]);
                    else
                        gridOutput.Add(0);

                    if (!placedRoomsNums.Contains(bestGrid[i, j]) && bestGrid[i, j] != 0 && bestGrid[i, j] != -1 && bestGrid[i, j] != 200)
                        placedRoomsNums.Add(bestGrid[i, j]);
                }
            placedRoomsNums.Sort();

            // Indicate all RoomInstances that are not placed in the grid on the graph in grasshopper window
            List<int> missingRoomAdj = MissingRoomAdjacences(bestGrid, adjArray);
            for (int i = 0; i < roomList.Count; i++)
                if (!placedRoomsNums.Contains(Convert.ToInt32(i + 1)))
                {
                    if (roomList[i].hasMissingAdj != true)
                        roomList[i].hasMissingAdj = true;
                }
                else
                {
                    if (roomList[i].hasMissingAdj != false)
                        roomList[i].hasMissingAdj = false;
                }

            // missingRoomAdj is not the list that we're looking for. It considers wrong list of rooms (all of them, instead of only placed ones)
            // So we have to fix it a bit
            List<int> missingRoomAdjSortedList = new List<int>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
                missingRoomAdjSortedList.Add(missingRoomAdj[placedRoomsNums[i] - 1]);

            List<string> roomNames = new List<string>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                if (!roomList[placedRoomsNums[i] - 1].isHall)
                    roomNames.Add(roomList[placedRoomsNums[i] - 1].RoomName);
                else
                    roomNames.Add("&&HALL&&"+ roomList[placedRoomsNums[i] - 1].RoomName);
            }



            // At the end let's convert all needed rooms to halls   
            for (int i = 0; i < bestGrid.GetLength(0); i++)
                for (int j = 0; j < bestGrid.GetLength(1); j++)
                    if (bestGrid[i, j] > 0 && bestGrid[i, j] <= roomList.Count)
                        if (roomList[bestGrid[i, j] - 1].isHall)
                            bestGrid[i, j] = -1;


            List<Brep> roomBrepsList = new List<Brep>();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < gridOutput.Count; q++)
                    if (gridOutput[q] == placedRoomsNums[i])
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    roomBrepsList.Add(Brep.JoinBreps(cellsCollection, 0.01f)[0]);

            }

            Brep corridorsBrep = new Brep();
            for (int i = 0; i < placedRoomsNums.Count; i++)
            {
                List<Brep> cellsCollection = new List<Brep>();
                for (int q = 0; q < gridOutput.Count; q++)
                    if (gridOutput[q] == -1)
                        cellsCollection.Add(gridSurfaceArray[q].ToBrep());

                if (Brep.JoinBreps(cellsCollection, 0.01f) != null)
                    corridorsBrep = Brep.JoinBreps(cellsCollection, 0.01f)[0];

            }

            string adjacenciesOutputString = "";
            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (placedRoomsNums.Contains(adjArray[i, 0]) && placedRoomsNums.Contains(adjArray[i, 1]))
                    adjacenciesOutputString += placedRoomsNums.IndexOf(adjArray[i, 0]) + "-" + placedRoomsNums.IndexOf(adjArray[i, 1]) + "\n";

            DA.SetDataList("Room Breps", roomBrepsList);
            DA.SetData("Corridors", corridorsBrep);
            // DA.SetDataList("GridCells", gridSurfaceArray);
            // DA.SetData("xGridDim", x);
            DA.SetDataList("MissingAdjacences", missingRoomAdjSortedList);
            // DA.SetData("Boundary", boundaryCrv);
            DA.SetData("Adjacencies", adjacenciesOutputString);
            DA.SetDataList("Room Names", roomNames);

            this.Message = gridSolutionsHeap[0].roomOrder.Count + " of " + roomList.Count + " placed";
        }

        private void RemoveDeadEnds(ref int[,] grid, List<RoomCells> roomCellsList)
        {
            List<int[]> toRemove = new List<int[]>();
            List<int> newValues = new List<int>();

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {
                        List<int[]> neighbours = new List<int[]>();
                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (j >= 0 && j < grid.GetLength(1))
                        {
                            if (i > 0)
                                if (grid[i - 1, j] == -1)
                                    neighbours.Add(new int[] { i - 1, j });
                            if (i < grid.GetLength(0) - 1)
                                if (grid[i + 1, j] == -1)
                                    neighbours.Add(new int[] { i + 1, j });
                        }
                        if (i >= 0 && i < grid.GetLength(0))
                        {
                            if (j > 0)
                                if (grid[i, j - 1] == -1)
                                    neighbours.Add(new int[] { i, j - 1 });
                            if (j < grid.GetLength(1) - 1)
                                if (grid[i, j + 1] == -1)
                                    neighbours.Add(new int[] { i, j + 1 });
                        }

                        if (neighbours.Count == 1)
                        {
                            //toRemove.Add(new int[] { i, j });
                            int iT = i;
                            int jT = j;

                            int iDelta = neighbours[0][0] - i;
                            int jDelta = neighbours[0][1] - j;


                            if (indexInRoomCellsList >= 0)
                                while (jT >= 0 && jT < grid.GetLength(1) && iT >= 0 && iT < grid.GetLength(0)
                                    && grid[iT, jT] == -1 && neighbours.Count <= 2
                                    && iT >= roomCellsList[indexInRoomCellsList].x && iT < roomCellsList[indexInRoomCellsList].x + roomCellsList[indexInRoomCellsList].w
                                && jT >= roomCellsList[indexInRoomCellsList].y && jT < roomCellsList[indexInRoomCellsList].y + roomCellsList[indexInRoomCellsList].h)
                                {
                                    toRemove.Add(new int[] { iT, jT });
                                    newValues.Add(indexInRoomCellsList + 1);
                                    iT += iDelta;
                                    jT += jDelta;

                                    neighbours = new List<int[]>();

                                    if (jT >= 0 && jT < grid.GetLength(1))
                                    {
                                        if (iT > 0)
                                            if (grid[iT - 1, jT] == -1)
                                                neighbours.Add(new int[] { iT - 1, jT });
                                        if (iT < grid.GetLength(0) - 1)
                                            if (grid[iT + 1, jT] == -1)
                                                neighbours.Add(new int[] { iT + 1, jT });
                                    }
                                    if (iT >= 0 && iT < grid.GetLength(0))
                                    {
                                        if (jT > 0)
                                            if (grid[iT, jT - 1] == -1)
                                                neighbours.Add(new int[] { iT, jT - 1 });
                                        if (jT < grid.GetLength(1) - 1)
                                            if (grid[iT, jT + 1] == -1)
                                                neighbours.Add(new int[] { iT, jT + 1 });
                                    }
                                }
                        }
                    }
                }

            for (int i = 0; i < toRemove.Count; i++)
                grid[toRemove[i][0], toRemove[i][1]] = newValues[i];
        }

        private void RemoveAllCorridors(ref int[,] grid, List<RoomCells> roomCellsList)
        {

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                    {

                        int indexInRoomCellsList = -1;

                        for (int q = 0; q < roomCellsList.Count; q++)
                            if (i >= roomCellsList[q].x && i < roomCellsList[q].x + roomCellsList[q].w
                                && j >= roomCellsList[q].y && j < roomCellsList[q].y + roomCellsList[q].h)
                                indexInRoomCellsList = q;

                        if (indexInRoomCellsList > -1)
                            grid[i, j] = indexInRoomCellsList + 1;
                    }
                }
        }

        private class GridSolution
        {
            public int[,] grid;
            public List<RoomCells> roomCellsList = new List<RoomCells>();
            public List<int> roomOrder = new List<int>();

            public GridSolution(int[,] Grid, List<RoomCells> RoomCellsList, List<int> RoomOrder)
            {
                grid = Grid;
                roomCellsList = RoomCellsList.ConvertAll(roomCells => new RoomCells(roomCells));
                roomOrder = RoomOrder.ConvertAll(i => i);
            }
        }

        public List<int> MissingRoomAdjacences(int[,] grid, int[,] adjArray)
        {
            List<int> missingAdj = new List<int>();// (adjArray.GetLength(0));
            int maxRoomNum = 0;
            for (int i = 0; i < adjArray.GetLength(0); i++)
                maxRoomNum = Math.Max(Math.Max(maxRoomNum, adjArray[i, 0]), adjArray[i, 1]);

            for (int i = 0; i < maxRoomNum; i++)
                missingAdj.Add(0);

            for (int l = 0; l < adjArray.GetLength(0); l++)
            {
                bool exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 0])
                            exists = true;
                if (!exists)
                    missingAdj[adjArray[l, 1] - 1]++;


                exists = false;
                for (int i = 0; i < grid.GetLength(0); i++)
                    for (int j = 0; j < grid.GetLength(1); j++)
                        if (grid[i, j] == adjArray[l, 1])
                            exists = true;
                if (!exists)
                    missingAdj[adjArray[l, 0] - 1]++;
            }

            return missingAdj;
        }

        public bool TryPlaceNewRoomToTheGrid(ref int[,] grid, int area, int roomNum, int[,] adjArray, double maxAdjDistance, bool isHall = false)
        {
            int[,] availableCellsGrid = new int[grid.GetLength(0), grid.GetLength(1)];  //= grid;
            int[,] room = new int[50, 50];

            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == roomNum && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == roomNum && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);

            // Let's try to define proportions for the room considering its area and something else I don't know what
            /*  List<int> divisors = new List<int>();
              for (int i = 2; i <= Math.Sqrt(area); i++)
                  if (area % i == 0)
                      divisors.Add(i);

              area--;
              do
              {
                  divisors.Clear();
                  area++;
                  for (int i = 1; i <= Math.Sqrt(area); i++)
                      if (area % i == 0)
                          divisors.Add(i);

              } while (area / (double)divisors[divisors.Count - 1] / (double)divisors[divisors.Count - 1] > 1.5f);
              xDim = divisors[divisors.Count - 1];
              yDim = area / xDim;
              int temp = xDim;
              if (random.Next(2) == 0)
              {
                  xDim = yDim;
                  yDim = temp;
              } */

            // New variant:
            double ratio = 1 + random.NextDouble() * 1f;
            double xDim_d = Math.Sqrt(area / ratio);
            double yDim_d = ratio * Math.Sqrt(area / ratio);

            xDim = (int)Math.Round(xDim_d);
            yDim = (int)Math.Round(yDim_d);

            if (xDim == 0)
                xDim++;
            if (yDim == 0)
                yDim++;

            if (random.Next(2) == 0)
            {
                int temp = xDim;
                xDim = yDim;
                yDim = temp;
            }


            // Choose the corridor generation mode according to MenuItemDropDown selection
            if (oneSideCorridorsChecked && !isHall)
            {

                if (random.Next(2) == 0)
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        xDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim + 1, yDim];
                    for (int i = 0; i < xDim + 1; i++)
                        for (int j = 0; j < yDim; j++)
                            if (i == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNum;
                }
                else
                {
                    if (!corridorsAsAdditionalSpacesChecked)
                        yDim--;

                    if (xDim == 0)
                        xDim++;
                    if (yDim == 0)
                        yDim++;

                    room = new int[xDim, yDim + 1];
                    for (int i = 0; i < xDim; i++)
                        for (int j = 0; j < yDim + 1; j++)
                            if (j == 0)
                                room[i, j] = -1;
                            else
                                room[i, j] = roomNum;
                }

            }
            else if (twoSidesCorridorsChecked && !isHall)
            {
                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim--;
                    yDim--;
                }

                if (xDim == 0)
                    xDim++;
                if (yDim == 0)
                    yDim++;


                room = new int[xDim + 1, yDim + 1];
                for (int i = 0; i < xDim + 1; i++)
                    for (int j = 0; j < yDim + 1; j++)
                        if (i == 0 || j == 0)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNum;
            }
            else if (allSidesCorridorsChecked || isHall)
            {
                // xDim--;
                //yDim--;

                if (!corridorsAsAdditionalSpacesChecked)
                {
                    xDim -= 2;
                    yDim -= 2;
                }

                if (xDim <= 0)
                    xDim = 1;
                if (yDim <= 0)
                    yDim = 1;


                room = new int[xDim + 2, yDim + 2];
                for (int i = 0; i <= xDim + 1; i++)
                    for (int j = 0; j <= yDim + 1; j++)
                        if (i == 0 || j == 0 || i == xDim + 1 || j == yDim + 1)
                            room[i, j] = -1;
                        else
                            room[i, j] = roomNum;
            }

            // Start filling availableCellsGrid: 0 = not available, 1 = available
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    availableCellsGrid[i, j] = 0;

                    if (grid[i, j] == 0)
                        for (int l = -1; l <= 1; l++)
                            for (int k = -1; k <= 1; k++)
                                if ((l == 0 || k == 0) && l != k)
                                    if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))
                                        if (grid[i + l, j + k] == -1)
                                        {
                                            if (CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                                            {
                                                availableCellsGrid[i, j] = 1;
                                                // AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, "avalCell! " + roomNum + ": " + i + "_" + j);
                                            }
                                        }
                }


            List<RoomPlacementSolution> placementSolutions = new List<RoomPlacementSolution>();



            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {

                    if (availableCellsGrid[i, j] == 1)
                    {
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.BottomLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomLeft, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.BottomLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.BottomRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.BottomRight, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.BottomRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.TopLeft))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopLeft, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.TopLeft));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                        if (RoomIsPlaceable_TEST(grid, room, i, j, RoomPosition.TopRight))
                        {
                            RoomPlacementSolution newSolution = new RoomPlacementSolution(i, j, RoomPosition.TopRight, room
                                , GetRoomScore(grid, room, i, j, RoomPosition.TopRight));
                            placementSolutions.Add(new RoomPlacementSolution(newSolution));
                        }
                    }
                }


            //placementSolutions = placementSolutions.OrderBy(a => new Random(Guid.NewGuid().GetHashCode()).Next(2) == 0).ToList();
            placementSolutions = placementSolutions.OrderBy(t => -t.score).ToList();

            if (placementSolutions.Count > 0)
            {
                int x = placementSolutions[0].x;
                int y = placementSolutions[0].y;
                int w = placementSolutions[0].room.GetLength(0);
                int h = placementSolutions[0].room.GetLength(1);

                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.TopLeft)
                    x -= w-1;
                if (placementSolutions[0].roomPosition == RoomPosition.BottomLeft || placementSolutions[0].roomPosition == RoomPosition.BottomRight)
                    y -= h-1;

                roomCellsList[roomNum - 1] = new RoomCells(x, y, w, h);


                PlaceRoomSolution(placementSolutions[0], placementSolutions[0].room, ref grid, isHall);
                return true;
            }
            else
                return false;
        }

        private double DistanceToRoomNumber_TEST(int[,] grid, int x, int y, int targetNum, double maxDistance = 20)
        {

            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;

                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);

            double minDist = 5000;

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    for (int l = -1; l <= 1; l++)
                        for (int k = -1; k <= 1; k++)
                            if ((l == 0 || k == 0) && l != k)
                                if (i + l >= 0 && i + l < grid.GetLength(0) && j + k >= 0 && j + k < grid.GetLength(1))

                                    if (grid[i + l, j + k] == targetNum && distanceGrid[i, j] != -1)
                                        minDist = Math.Min(minDist, distanceGrid[i, j]);
                }

            return minDist;
        }

        private class RoomCells
        {
            public int x;
            public int y;
            public int w;
            public int h;

            public RoomCells() { }

            public RoomCells(int X, int Y, int W, int H)
            {
                x = X;
                y = Y;
                w = W;
                h = H;
            }

            public RoomCells(RoomCells roomCells)
            {
                x = roomCells.x;
                y = roomCells.y;
                w = roomCells.w;
                h = roomCells.h;
            }
        }
        // Now add method for saving RoomCells to a list and then implement removing rooms in case of them having missing adj

        private void RemoveRoomFromGrid(ref int[,] grid, RoomCells roomCells)
        {
            for (int i = roomCells.x; i < roomCells.x + roomCells.w; i++)
                for (int j = roomCells.y; j < roomCells.y + roomCells.h; j++)
                    grid[i, j] = 0;
        }

        private void PlaceRoomSolution(RoomPlacementSolution solution, int[,] room, ref int[,] grid, bool isHall = false)
        {
            switch (solution.roomPosition)
            {
                case RoomPosition.TopRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[i - solution.x, j - solution.y];
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (solution.x + room.GetLength(0) < grid.GetLength(0) && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i < solution.x + room.GetLength(0); i++)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[i - solution.x, -(j - solution.y)];
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y - room.GetLength(1) >= 0)
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j > solution.y - room.GetLength(1); j--)
                                grid[i, j] = room[-(i - solution.x), -(j - solution.y)];
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (solution.x - room.GetLength(0) >= 0 && solution.y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = solution.x; i > solution.x - room.GetLength(0); i--)
                            for (int j = solution.y; j < solution.y + room.GetLength(1); j++)
                                grid[i, j] = room[-(i - solution.x), j - solution.y];
                    }
                    break;
            }
        }

        private int GetRoomScore(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            int score = 0;

            List<int> cellsToCheck = new List<int>();



            if (roomPosition == RoomPosition.BottomLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + 1]);

                    if (x - i >= 0 && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y - j >= 0)
                        cellsToCheck.Add(grid[x + 1, y - j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.BottomRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + 1]);

                    if (x + i < grid.GetLength(0) && y - room.GetLength(1) - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - room.GetLength(1) - 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y - j >= 0)
                        cellsToCheck.Add(grid[x - 1, y - j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y - j > 0)
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y - j]);
                }
            }

            if (roomPosition == RoomPosition.TopLeft)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x - i >= 0 && y - 1 >= 0)
                        cellsToCheck.Add(grid[x - i, y - 1]);

                    if (x - i >= 0 && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + 1, y + j]);

                    if (x - room.GetLength(0) - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - room.GetLength(0) - 1, y + j]);
                }
            }

            if (roomPosition == RoomPosition.TopRight)
            {
                for (int i = 0; i < grid.GetLength(0); i++)
                {
                    if (x + i < grid.GetLength(0) && y - 1 >= 0)
                        cellsToCheck.Add(grid[x + i, y - 1]);

                    if (x + i < grid.GetLength(0) && y + room.GetLength(1) + 1 < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + i, y + room.GetLength(1) + 1]);
                }

                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (x - 1 >= 0 && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x - 1, y + j]);

                    if (x + room.GetLength(0) + 1 < grid.GetLength(0) && y + j < grid.GetLength(1))
                        cellsToCheck.Add(grid[x + room.GetLength(0) + 1, y + j]);
                }
            }

            foreach (int a in cellsToCheck)
                if (a != 0 && a != 200)
                    score++;

            return score;
        }

        private class RoomPlacementSolution
        {
            public RoomPlacementSolution(int roomX, int roomY, RoomPosition position, int[,] mRoom, int mScore)
            {
                x = roomX;
                y = roomY;
                roomPosition = position;
                this.score = mScore;
                this.room = mRoom.Clone() as int[,];
            }

            public RoomPlacementSolution(RoomPlacementSolution a)
            {
                x = a.x;
                y = a.y;
                roomPosition = a.roomPosition;
                this.score = a.score;
                this.room = a.room.Clone() as int[,];
            }

            public int GetRoomNum()
            {
                int max = -1;
                for (int i = 0; i < room.GetLength(0); i++)
                    for (int j = 0; j < room.GetLength(1); j++)
                        max = Math.Max(max, room[i, j]);
                return max;
            }

            public RoomPosition roomPosition;
            public int score = 0;
            public int x;
            public int y;
            public int[,] room;
        }

        private enum RoomPosition { TopRight, BottomRight, BottomLeft, TopLeft, Undefined }


        private bool RoomIsPlaceable_TEST(int[,] grid, int[,] room, int x, int y, RoomPosition roomPosition)
        {
            switch (roomPosition)
            {
                case RoomPosition.TopRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomRight:
                    if (x + room.GetLength(0) < grid.GetLength(0) && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i < x + room.GetLength(0); i++)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.BottomLeft:
                    if (x - room.GetLength(0) >= 0 && y - room.GetLength(1) >= 0)
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j > y - room.GetLength(1); j--)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

                case RoomPosition.TopLeft:
                    if (x - room.GetLength(0) >= 0 && y + room.GetLength(1) < grid.GetLength(1))
                    {
                        for (int i = x; i > x - room.GetLength(0); i--)
                            for (int j = y; j < y + room.GetLength(1); j++)
                                if (grid[i, j] != 0)
                                    return false;
                        return true;
                    }
                    break;

            }
            return false;
        }



        public struct IntPair
        {
            public IntPair(int a1, int b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }

            public IntPair(int a1, double b1)
            {
                roomNumber = a1;
                AdjNum = b1;
            }
            public int roomNumber;
            public double AdjNum;
        }

        public bool CellsAreNearerThan(int x, int y, List<int> targetCellsList, int[,] grid, double maxDistance = 2)
        {
            foreach (int targetCell in targetCellsList)
            {
                if (!CellIsNearerThan(x, y, targetCell, grid, maxDistance))
                    return false;
            }
            return true;
        }



        public bool CellIsNearerThan(int x, int y, int targetCellNumber, int[,] grid, double maxDistance = 2)
        {
            bool[,] availabilityGrid = new bool[grid.GetLength(0), grid.GetLength(1)];
            double[,] distanceGrid = new double[grid.GetLength(0), grid.GetLength(1)];

            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    if (grid[i, j] == -1)
                        availabilityGrid[i, j] = true;
                    else
                        availabilityGrid[i, j] = false;
                    distanceGrid[i, j] = -1;
                }

            distanceGrid[x, y] = 0;
            availabilityGrid[x, y] = true;

            SetCellDistancesAround(x, y, ref distanceGrid, ref availabilityGrid, maxDistance);


            int minX = -1;
            int minY = -1;
            double minTargetDist = -1;

            for (int i = 0; i < availabilityGrid.GetLength(0); i++)
                for (int j = 0; j < availabilityGrid.GetLength(1); j++)
                {
                    if (grid[i, j] == targetCellNumber)
                        if ((distanceGrid[i, j] < minTargetDist || minTargetDist == -1) && distanceGrid[i, j] > 0)
                        {
                            minTargetDist = distanceGrid[i, j];
                            minX = i;
                            minY = j;
                        }
                }

            if (minTargetDist != -1 && minTargetDist <= maxDistance)
                return true;
            else
                return false;
        }

        public void SetCellDistancesAround(int x, int y, ref double[,] distanceGrid, ref bool[,] availabilityGrid, double maxDist)
        {
            List<List<int>> recursionList = new List<List<int>>();


            for (int i = -1; i <= 1; i++)
                for (int j = -1; j <= 1; j++)
                {
                    if (x + i >= 0 && x + i < distanceGrid.GetLength(0) &&
                        y + j >= 0 && y + j < distanceGrid.GetLength(1))
                        if (!(i == 0 && j == 0))
                        {
                            double addValue;
                            if (i * j != 0) //if the cell is corner cell
                                addValue = 1.414f; //sqrt(2)
                            else
                                addValue = 1;

                            if (availabilityGrid[x, y])
                                if (distanceGrid[x + i, y + j] > distanceGrid[x, y] + addValue || distanceGrid[x + i, y + j] == -1)
                                {
                                    distanceGrid[x + i, y + j] = distanceGrid[x, y] + addValue;
                                    if (distanceGrid[x + i, y + j] <= maxDist)
                                        recursionList.Add(new List<int>() { x + i, y + j });
                                }
                        }
                }
            // doesnt really affect performance
            foreach (List<int> item in recursionList)
                SetCellDistancesAround(item[0], item[1], ref distanceGrid, ref availabilityGrid, maxDist);

            return;
        }

        bool GridAIsBetterThanB(int[,] A, int[,] B)
        {
            int aCount = 0;
            int bCount = 0;

            List<int> aRooms = new List<int>();
            List<int> bRooms = new List<int>();

            for (int i = 0; i < A.GetLength(0); i++)
                for (int j = 0; j < A.GetLength(1); j++)
                {
                    if (A[i, j] == 0)
                        aCount++;
                    if (B[i, j] == 0)
                        bCount++;

                    if (aRooms.FindIndex(a => a == A[i, j]) == -1)
                        aRooms.Add(A[i, j]);

                    if (bRooms.FindIndex(b => b == B[i, j]) == -1)
                        bRooms.Add(B[i, j]);

                }

            // return aRooms.Count > bRooms.Count;
            return aCount < bCount;
        }


        public bool GridContains(int[,] grid, int val)
        {
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                    if (grid[i, j] == val)
                        return true;
            return false;
        }

        /*
        bool TryPlaceNewRoom(int area, int num, ref int[,] grid, int[,] adjArray, double maxAdjDistance = 3f)
        {
            int xDim;
            int yDim;

            List<int> adjacentRooms = new List<int>();

            for (int i = 0; i < adjArray.GetLength(0); i++)
                if (adjArray[i, 0] == num && GridContains(grid, adjArray[i, 1]))
                    adjacentRooms.Add(adjArray[i, 1]);
                else if (adjArray[i, 1] == num && GridContains(grid, adjArray[i, 0]))
                    adjacentRooms.Add(adjArray[i, 0]);


            //  for (int i = 0; i < adjArray.GetLength(0); i++)
            //      Rhino.RhinoApp.WriteLine(adjArray[i,0].ToString() + " + "+ adjArray[i, 1].ToString());

            List<int> divisors = new List<int>();
            for (int i = 2; i <= area; i++)
                if (area % i == 0)
                    divisors.Add(i);

            while (divisors.Count < 4)
            {
                divisors.Clear();
                area++;
                for (int i = 2; i <= area; i++)
                    if (area % i == 0)
                        divisors.Add(i);

            }

            xDim = divisors[divisors.Count / 2 - random.Next(2)];
            yDim = area / xDim;


            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1) - 1; j++)
                {
                    if (grid[i, j] == -1)
                        if (grid[i, j + 1] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i, j + 1, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i, j + 1, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                        else if (grid[i, j - 1] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i, j - 1, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i, j - 1, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }

                        else if (grid[i + 1, j] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i + 1, j, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i + 1, j, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                        else if (grid[i - 1, j] == 0 && EnoughSpaceOnThe(xDim, yDim, num, i - 1, j, ref grid, true)
                            && CellsAreNearerThan(i, j, adjacentRooms, grid, maxAdjDistance))
                        {
                            EnoughSpaceOnThe(xDim, yDim, num, i - 1, j, ref grid, false);
                            i = grid.GetLength(0);
                            j = grid.GetLength(1);
                            return true;
                        }
                }

            return false;
        }
        */

        private bool EnoughSpaceOnThe(int xDim, int yDim, int roomNum, int gridX, int gridY, ref int[,] grid, bool preserveGrid = false)
        {

            // roomNum++; // Yes, coz rooms should start from 1, not from 0 // No, coz this solution sucks

            int xM = 1;
            int yM = 1;


            for (int it = 0; it < 4; it++)
            {

                switch (it)
                {
                    default: break;

                    case (0):
                        xM = 1;
                        yM = 1;
                        break;

                    case (1):
                        xM = -1;
                        yM = 1;
                        break;

                    case (2):
                        xM = 1;
                        yM = -1;
                        break;
                    case (3):
                        xM = -1;
                        yM = -1;
                        break;
                }

                if (gridX + xDim * xM >= grid.GetLength(0) || gridX + xDim * xM < 0 ||
                    gridY + yDim * yM >= grid.GetLength(1) || gridY + yDim * yM < 0)
                {
                    break;
                }

                bool xDimIsLessThanYDim = false;
                bool solutionFound = false;

                if (xDim > yDim)
                {
                    xDim++;
                    xDimIsLessThanYDim = true;
                }
                else
                {
                    xDimIsLessThanYDim = false;
                    yDim++;
                }

                // if one of the cells is not free -> terminate
                solutionFound = true;
                for (int i = 0; i < xDim; i++)
                    for (int j = 0; j < yDim; j++)
                    {
                        if (grid[gridX + i * xM, gridY + j * yM] != 0)
                        {
                            // break
                            solutionFound = false;
                            i = xDim;
                            j = yDim;
                        }
                    }

                if (solutionFound)
                {
                    if (!preserveGrid)
                        for (int i = 0; i < xDim; i++)
                            for (int j = 0; j < yDim; j++)
                            {
                                if ((xDimIsLessThanYDim && i == 0) || (!xDimIsLessThanYDim && j == 0))
                                    grid[gridX + i * xM, gridY + j * yM] = -1;
                                else
                                    grid[gridX + i * xM, gridY + j * yM] = roomNum;
                            }

                    return true;
                }

                if (xDimIsLessThanYDim)
                {
                    xDim--;
                    yDim++;
                    xDimIsLessThanYDim = false;
                }
                else
                {
                    xDimIsLessThanYDim = true;
                    yDim--;
                    xDim++;
                }

                solutionFound = true;
                for (int i = 0; i < xDim; i++)
                    for (int j = 0; j < yDim; j++)
                    {
                        if (grid[gridX + i * xM, gridY + j * yM] != 0)
                        {
                            // break
                            solutionFound = false;
                            i = xDim;
                            j = yDim;
                        }
                    }


                if (solutionFound)
                {
                    if (!preserveGrid)
                        for (int i = 0; i < xDim; i++)
                            for (int j = 0; j < yDim; j++)
                            {
                                if ((xDimIsLessThanYDim && i == 0) || (!xDimIsLessThanYDim && j == 0))
                                    grid[gridX + i * xM, gridY + j * yM] = -1;
                                else
                                    grid[gridX + i * xM, gridY + j * yM] = roomNum;
                            }

                    return true;
                }
            }
            return false;
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }




        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                return Properties.Resources.MagnetizingRoomsIcon;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{74fe1801-611b-423f-946a-2fda9514a3eb}"); }
        }


        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "One-side corridors", Menu_OneSideCorClick, true, oneSideCorridorsChecked);
            Menu_AppendItem(menu, "Two-sides corridors", Menu_TwoSidesCorClick, true, twoSidesCorridorsChecked);
            Menu_AppendItem(menu, "All-sides corridors", Menu_AllSidesCorClick, true, allSidesCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Remove Dead Ends", Menu_RemoveDeadEndsClick, true, removeDeadEndsChecked);
            Menu_AppendItem(menu, "Remove All Corridors", Menu_RemoveAllCorridorsClick, true, removeAllCorridorsChecked);

            Menu_AppendSeparator(menu);

            Menu_AppendItem(menu, "Corridors as additional spaces", Menu_CorridorsAsAdditionalSpacesChecked, true, corridorsAsAdditionalSpacesChecked);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        public void Menu_CorridorsAsAdditionalSpacesChecked(object sender, EventArgs e)
        {
            corridorsAsAdditionalSpacesChecked = !corridorsAsAdditionalSpacesChecked;
            this.ExpireSolution(true);
        }

        public void Menu_RemoveDeadEndsClick(object sender, EventArgs e)
        {
            removeDeadEndsChecked = !removeDeadEndsChecked;

            if (removeDeadEndsChecked)
                removeAllCorridorsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(true);
        }

        public void Menu_RemoveAllCorridorsClick(object sender, EventArgs e)
        {
            removeAllCorridorsChecked = !removeAllCorridorsChecked;
            if (removeAllCorridorsChecked)
                removeDeadEndsChecked = false;

            shouldOnlyRecomputeDeadEnds = true;
            this.ExpireSolution(true);
        }

        public void Menu_OneSideCorClick(object sender, EventArgs e)
        {
            if (!oneSideCorridorsChecked)
            {
                oneSideCorridorsChecked = !oneSideCorridorsChecked;

                twoSidesCorridorsChecked = !oneSideCorridorsChecked;
                allSidesCorridorsChecked = !oneSideCorridorsChecked;

                ExpireSolution(true);
            }
        }

        public void Menu_TwoSidesCorClick(object sender, EventArgs e)
        {
            if (!twoSidesCorridorsChecked)
            {
                twoSidesCorridorsChecked = !twoSidesCorridorsChecked;

                oneSideCorridorsChecked = !twoSidesCorridorsChecked;
                allSidesCorridorsChecked = !twoSidesCorridorsChecked;

                ExpireSolution(true);
            }
        }

        public void Menu_AllSidesCorClick(object sender, EventArgs e)
        {
            if (!allSidesCorridorsChecked)
            {
                allSidesCorridorsChecked = !allSidesCorridorsChecked;

                oneSideCorridorsChecked = !allSidesCorridorsChecked;
                twoSidesCorridorsChecked = !allSidesCorridorsChecked;

                ExpireSolution(true);
            }
        }
    }
}

<./studies\Study4\RoomInstance_00.cs>
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.GUI;
using Grasshopper.GUI.Canvas;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Parameters;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace FloorPlan_Generator.Study4
{
    public class ModifiableEventArgs : EventArgs
    {
        public ModifiableEventArgs(double value)
        {
            Value = value;
        }
        public double Value { get; set; }
    }
    public interface IModifiable
    {
        event EventHandler<ModifiableEventArgs> ModifyValue;
    }

    internal class AttributesNumberMultiplier : GH_Attributes<RoomInstance_00>
    {
        public AttributesNumberMultiplier(RoomInstance_00 owner)
          : base(owner)
        {

        }

        public override bool AllowMessageBalloon
        {
            get { return true; }
        }
        public override bool HasInputGrip
        {
            get { return false; }
        }
        public override bool HasOutputGrip
        {
            get { return false; }
        }

        private const int InnerRadius = 30;
        private const int OuterRadius = 60;

        public override bool IsPickRegion(PointF point)
        {
            return Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, point);
        }
        protected override void Layout()
        {
            Pivot = GH_Convert.ToPoint(Pivot);
            Bounds = new RectangleF(Pivot.X - OuterRadius, Pivot.Y - OuterRadius, 2 * OuterRadius, 2 * OuterRadius);
        }

        protected RectangleF InnerBounds
        {
            get
            {
                RectangleF inner = Bounds;
                int inflation = OuterRadius - InnerRadius;
                inner.Inflate(-inflation, -inflation);
                return inner;
            }
        }

        protected override void Render(GH_Canvas canvas, Graphics graphics, GH_CanvasChannel channel)
        {
            switch (channel)
            {
                case GH_CanvasChannel.Wires:
                    graphics.FillEllipse(Brushes.Bisque, Bounds);
                    foreach (IModifiable mod in Owner.TargetObjects())
                    {
                        if (mod == null)
                            continue;

                        IGH_DocumentObject obj = mod as IGH_DocumentObject;
                        if (obj == null)
                            continue;

                        DrawTargetArrow(graphics, obj.Attributes.Bounds);
                    }
                    break;

                case GH_CanvasChannel.Objects:
                    GH_Capsule capsule = GH_Capsule.CreateCapsule(InnerBounds, GH_Palette.Normal, InnerRadius, 0);
                    capsule.Render(graphics, Selected, Owner.Locked, true);
                    capsule.Dispose();

                    string text = string.Format("{0:0.00}", "TEST");
                    Grasshopper.GUI.GH_GraphicsUtil.RenderCenteredText(graphics, text, GH_FontServer.Large, Color.Black, Pivot);
                    //Grasshopper.GUI.GH_GraphicsUtil.RenderObjectOverlay(graphics, , Bounds);
                    //GH_Capsule.CreateTextCapsule
                    RectangleF capsuleRect = new RectangleF( 
                        new PointF(InnerBounds.Location.X + 50, InnerBounds.Location.Y + 50), new SizeF(30, 30));
                    GH_Capsule capsuleBlue = GH_Capsule.CreateCapsule(capsuleRect, GH_Palette.Blue);
                    capsuleBlue.Render(graphics, Selected, Owner.Locked, true);
                    capsuleBlue.Dispose();

               /*     var field = new NumberInputTextField(new Param_Number())
                    {
                        Bounds = GH_Convert.ToRectangle(Bounds)
                    };
                    var matrix = sender.Viewport.XFormMatrix(GH_Viewport.GH_DisplayMatrix.CanvasToControl);

                    field.ShowTextInputBox(sender, initial, true, true, matrix);
                    */

                    break;
            }
        }

        public override GH_ObjectResponse RespondToMouseDoubleClick(GH_Canvas sender, GH_CanvasMouseEvent e)
        {
          

            return base.RespondToMouseDoubleClick(sender, e);
        }

        internal class NumberInputTextField : Grasshopper.GUI.Base.GH_TextBoxInputBase
        {
            private readonly Param_Number _input;

            public NumberInputTextField(Param_Number input)
            {
                _input = input ?? throw new ArgumentNullException(nameof(input));
            }

            protected override void HandleTextInputAccepted(string text)
            {
                if (GH_Convert.ToDouble(text, out var number, GH_Conversion.Both))
                {
                    _input.PersistentData.Clear();
                    _input.PersistentData.Append(new GH_Number(number), new GH_Path(0));
                    _input.ExpireSolution(true);
                }
            }
        }


        private void DrawTargetArrow(Graphics graphics, RectangleF target)
        {
            PointF cp = Grasshopper.GUI.GH_GraphicsUtil.BoxClosestPoint(Pivot, target);
            double distance = Grasshopper.GUI.GH_GraphicsUtil.Distance(Pivot, cp);
            if (distance < OuterRadius)
                return;

            Circle circle = new Circle(new Point3d(Pivot.X, Pivot.Y, 0.0), OuterRadius - 2);
            PointF tp = GH_Convert.ToPointF(circle.ClosestPoint(new Point3d(cp.X, cp.Y, 0.0)));

            Pen arrowPen = new Pen(Color.HotPink, OuterRadius - InnerRadius);
            arrowPen.EndCap = System.Drawing.Drawing2D.LineCap.RoundAnchor;
            graphics.DrawLine(arrowPen, tp, cp);
            arrowPen.Dispose();
        }

        private bool _drawing;
        private RectangleF _drawingBox;

        public override GH_ObjectResponse RespondToMouseDown(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            _drawing = false;
            _drawingBox = InnerBounds;

            if (e.Button == System.Windows.Forms.MouseButtons.Left)
            {
                // If on outer disc, but not in inner disc.. then start a wire drawing process.
                bool onOuterDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(Bounds, e.CanvasLocation);
                bool onInnerDisc = Grasshopper.GUI.GH_GraphicsUtil.IsPointInEllipse(InnerBounds, e.CanvasLocation);
                if (onOuterDisc && !onInnerDisc)
                {
                    // Begin arrow drawing behaviour.
                    _drawing = true;
                    sender.CanvasPostPaintObjects += CanvasPostPaintObjects;
                    return GH_ObjectResponse.Capture;
                }
            }

            // Otherwise revert to default behaviour.
            return base.RespondToMouseDown(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseMove(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawingBox = new RectangleF(e.CanvasLocation, new SizeF(0, 0));

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                    {
                        if (att.DocObject is IModifiable)
                            _drawingBox = att.Bounds;
                    }
                }
                sender.Invalidate();
                return GH_ObjectResponse.Handled;
            }

            return base.RespondToMouseMove(sender, e);
        }
        public override GH_ObjectResponse RespondToMouseUp(GH_Canvas sender, Grasshopper.GUI.GH_CanvasMouseEvent e)
        {
            if (_drawing)
            {
                _drawing = false;
                sender.CanvasPostPaintObjects -= CanvasPostPaintObjects;

                GH_Document doc = sender.Document;
                if (doc != null)
                {
                    IGH_Attributes att = doc.FindAttribute(e.CanvasLocation, true);
                    if (att != null)
                        if (att.DocObject is IModifiable)
                        {
                            Owner.RecordUndoEvent("Add Modifier");
                            Owner.AddTarget(att.DocObject.InstanceGuid);
                            IGH_ActiveObject obj = att.DocObject as IGH_ActiveObject;
                            if (obj != null)
                                obj.ExpireSolution(true);
                        }
                }

                sender.Invalidate();
                return GH_ObjectResponse.Release;
            }

            return base.RespondToMouseUp(sender, e);
        }
        void CanvasPostPaintObjects(GH_Canvas sender)
        {
            if (!_drawing) return;
            DrawTargetArrow(sender.Graphics, _drawingBox);
        }
    }


    public class RoomInstance_00 : GH_Component, IModifiable
    {
        /// <summary>
        /// Initializes a new instance of the RoomInstance class.
        /// </summary>
        public RoomInstance_00()
          : base("RoomInstance", "RoomCircle",
              "RoomCircle",
              "FloorPlanGen", "House Program Representation")
        {
        }

        public override void CreateAttributes()
        {
            m_attributes = new AttributesNumberMultiplier(this);
        }

        private readonly List<Guid> _targetIds = new List<Guid>();
        private readonly List<IModifiable> _targetObjs = new List<IModifiable>();

        public event EventHandler<ModifiableEventArgs> ModifyValue;


        public void AddTarget(Guid target)
        {
            if (_targetIds.Contains(target))
                return;
            _targetIds.Add(target);
            _targetObjs.Clear();
        }
        public void RemoveTarget(Guid target)
        {
            _targetIds.Remove(target);
            _targetObjs.Clear();
        }

        public IEnumerable<IModifiable> TargetObjects()
        {
            if (_targetIds.Count != _targetObjs.Count)
            {
                GH_Document doc = OnPingDocument();
                if (doc == null)
                    return new IModifiable[] { };

                _targetObjs.Clear();
                foreach (Guid id in _targetIds)
                {
                    IGH_DocumentObject obj = doc.FindObject(id, true);
                    if (obj == null)
                    {
                        _targetObjs.Add(null);
                        continue;
                    }
                    _targetObjs.Add(obj as IModifiable);
                }
            }

            return _targetObjs;
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            AddRuntimeMessage(GH_RuntimeMessageLevel.Remark, _targetObjs.Count.ToString());
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{2af1028d-fb80-4940-9d97-72dfea7ec789}"); }
        }
    }
}

<./studies\Study5\GenerateCorridorsInBetween.cs>
﻿using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Rhino.Geometry;

namespace FloorPlan_Generator
{
    public class GenerateCorridorsInBetween : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the GenerateCorridorsInBetween class.
        /// </summary>
        public GenerateCorridorsInBetween()
          : base("GenerateCorridorsInBetween", "GenerateCorridorsInBetween",
              "GenerateCorridorsInBetween",
              "FloorPlanGen", "Study_5")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddNumberParameter("CellSize", "CellSize", "CellSize", GH_ParamAccess.item, 1);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddLineParameter("Corridors", "Corridors", "Corridors", GH_ParamAccess.list);
            pManager.AddIntegerParameter("XGridDim", "XGridDim", "", GH_ParamAccess.item);
            pManager.AddIntegerParameter("NumberGrid", "NumberGrid", "NumberGrid", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            Curve boundary = null;
            List<Curve> rooms = new List<Curve>();
            List<Line> corridors = new List<Line>();
            double cellSize = 1;

            DA.GetData("Boundary", ref boundary);
            DA.GetDataList("Rooms", rooms);
            DA.GetData("CellSize", ref cellSize);

            int gridXCapacity = (int)((boundary.GetBoundingBox(false).Diagonal.X) / cellSize);
            int gridYCapacity = (int)((boundary.GetBoundingBox(false).Diagonal.Y) / cellSize);

            int[,] grid = new int[gridXCapacity, gridYCapacity];
            int[,] corridorsGrid = new int[gridXCapacity, gridYCapacity];

            InitializeGrid(ref grid, boundary.GetBoundingBox(false).Corner(true, true, true), cellSize, rooms);

            List<int> numberGrid = new List<int>();
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                    numberGrid.Add(grid[i, j]);


            // DO IT FOR HORIZONTALS
            for (int i = 0; i < corridorsGrid.GetLength(0) ; i++)
                for (int j = 0; j < corridorsGrid.GetLength(1) - 1; j++)
                {
                    if (grid[i, j] != grid[i, j + 1])
                        corridorsGrid[i, j] = 1;
                    else
                        corridorsGrid[i, j] = 0;
                }

            corridors.AddRange(GatherCorridorList(corridorsGrid, boundary, Direction.Horizontal));

            // DO IT FOR VERTICALS
            for (int i = 0; i < corridorsGrid.GetLength(0) - 1; i++)
                for (int j = 0; j < corridorsGrid.GetLength(1) ; j++)
                {
                    if (grid[i, j] != grid[i + 1, j])
                        corridorsGrid[i, j] = 1;
                    else
                        corridorsGrid[i, j] = 0;
                }

            corridors.AddRange(GatherCorridorList(corridorsGrid, boundary, Direction.Vertical));



            DA.SetDataList("Corridors", corridors);
            DA.SetData("XGridDim", gridXCapacity);
            DA.SetDataList("NumberGrid", numberGrid);
        }

        

        void InitializeGrid(ref int[,] grid, Point3d origin, double cellSize, List<Curve> rooms)
        {
            for (int i = 0; i < grid.GetLength(0); i++)
                for (int j = 0; j < grid.GetLength(1); j++)
                {
                    grid[i, j] = 0;
                    for (int l = 0; l < rooms.Count; l++)
                        if (rooms[l].Contains(origin + new Vector3d(cellSize * i + cellSize / 2, cellSize * j + cellSize / 2, 0)) == PointContainment.Inside)
                        {
                            grid[i, j] = l + 1;
                            break;
                        }
                }
        }

        enum Direction { Horizontal, Vertical };

        List<Line> GatherCorridorList(int[,] grid, Curve boundary, Direction direction)
        {
            List<Point3d> coordGrid = new List<Point3d>();
            double cellSizeX = boundary.GetBoundingBox(false).Diagonal.X / (grid.GetLength(0));
            double cellSizeY = boundary.GetBoundingBox(false).Diagonal.Y / (grid.GetLength(1));

            List<Line> corridors = new List<Line>();

            for (int i = 0; i < grid.GetLength(0) - 1; i++)
                for (int j = 0; j < grid.GetLength(1) - 1; j++)
                    if (grid[i, j] == 1)
                    {
                        if (direction == Direction.Horizontal)
                        {
                            if (i == 0 || grid[i - 1, j] != 1)
                            {
                                int enumer = 0;
                                while (i + enumer + 1 < grid.GetLength(0) && grid[i + enumer + 1, j] == 1)
                                    enumer++;

                                Point3d pointA = new Point3d(boundary.GetBoundingBox(false).Corner(true, true, true).X + cellSizeX * (i)
                                    , boundary.GetBoundingBox(false).Corner(true, true, true).Y + cellSizeY * (j + 1), 0);
                                Point3d pointB = new Point3d(boundary.GetBoundingBox(false).Corner(true, true, true).X + cellSizeX * (i + enumer + 1)
                                    , boundary.GetBoundingBox(false).Corner(true, true, true).Y + cellSizeY * (j + 1), 0);

                                corridors.Add(new Line(pointA, pointB));
                            }
                        }
                        else
                        {
                            if (j == 0 || grid[i, j - 1] != 1)
                            {
                                int enumer = 0;
                                while (j + enumer + 1 < grid.GetLength(1) && grid[i, enumer + 1 + j] == 1)
                                    enumer++;

                                Point3d pointA = new Point3d(boundary.GetBoundingBox(false).Corner(true, true, true).X + cellSizeX * (i + 1)
                                    , boundary.GetBoundingBox(false).Corner(true, true, true).Y + cellSizeY * (j), 0);
                                Point3d pointB = new Point3d(boundary.GetBoundingBox(false).Corner(true, true, true).X + cellSizeX * (i + 1)
                                    , boundary.GetBoundingBox(false).Corner(true, true, true).Y + cellSizeY * (j + enumer + 1), 0);

                                corridors.Add(new Line(pointA, pointB));
                            }
                        }
                    }

            return corridors;
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{a6d3f654-052a-48b7-8970-497425706aaf}"); }
        }
    }
}

<./studies\Study6\TensorFields 3.cs>
﻿using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Rhino.Geometry;
using Rhino.Collections;

namespace RAYONCHIK.GORODOK.TransportNetwork.TensorFields
{

    public class GHcTensorFields_2 : GH_Component
    {
        public Point3d GridFirstPoint;
        public Point3d GridLastPoint;
        public int gridRes;
        public List<Vector3d> GridVectors;
        public double step;
        public double roadDensity;
        public double angle;
        public Point3dList pointCloud;
        Curve boundary;

        /// <summary>
        /// Initializes a new instance of the TensorFieldsGHc class.
        /// </summary>
        public GHcTensorFields_2()
          : base("Tensor Fields 3", "Tensor Fields 3",
              "Tensor Fields 3",
              "FloorPlanGen", "Study_6")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddPointParameter("Points", "Points", "Points", GH_ParamAccess.list);
            pManager.AddVectorParameter("GridVectors", "GridVectors", "GridVectors", GH_ParamAccess.list);
            pManager.AddPointParameter("FirstPt", "FirstPt", "First point of GridVectors", GH_ParamAccess.item);
            pManager.AddPointParameter("LastPt", "LastPt", "Last point of GridVectors", GH_ParamAccess.item);
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
                //pManager.AddNumberParameter("RoadDensity", "RoadDensity", "RoadDensity", GH_ParamAccess.item);
            pManager.AddNumberParameter("RoadDensity", "RoadDensity", "RoadDensity", GH_ParamAccess.item, 50);
            pManager.AddNumberParameter("Angle", "Angle", "Angle", GH_ParamAccess.item, 0.0);
            pManager.AddIntegerParameter("Iterations", "Iterations", "Iterations, usually it should be equal 3", GH_ParamAccess.item, 3);
              pManager.AddNumberParameter("Step", "Step", "Step", GH_ParamAccess.item, 10);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("RoadNetwork", "RoadNetwork", "RoadNetwork", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            int iterations = 3;
            List<Point3d> iPoints = new List<Point3d>();
            GridVectors = new List<Vector3d>();
            roadDensity = 0;
            double blockWidth = 0;
            List<Curve> outputCurves = new List<Curve>();

            DA.GetDataList(0, iPoints);
            DA.GetDataList(1, GridVectors);
            DA.GetData(2, ref GridFirstPoint);
            DA.GetData(3, ref GridLastPoint);
            DA.GetData(4, ref boundary);
            DA.GetData(5, ref roadDensity);
            DA.GetData(6, ref angle);
            DA.GetData(7, ref iterations);
              DA.GetData(8, ref step);

           // step = blockWidth;
           // roadDensity = step - 10;

            gridRes = (int)Math.Sqrt(GridVectors.Count) - 1;
            pointCloud = new Point3dList();

            int sign = 1;
            Vector3d prevTensor = new Vector3d(0, 1, 0);
            Point3d nextPt = new Point3d();
            Vector3d nextTensor = new Vector3d();
            List<Point3d> currPointList = new List<Point3d>();
            List<Point3d> prevPointList = new List<Point3d>();

            for (int i = 0; i < iterations; i++)
            {
                List<Curve> currCurves = new List<Curve>();

                for (int j = 0; j < iPoints.Count; j++) // J ======= iPoints
                {
                    sign = 1;
                    currPointList.Clear();
                    prevPointList.Clear();

                    for (int k = 0; k < 2; k++)
                    {
                        prevPointList = new List<Point3d>(currPointList);
                        currPointList.Clear();
                        //  prevTensor = new Vector3d((i + 1) % 2, (i) % 2, 0);
                        prevTensor = new Vector3d(0, 0, 0);

                        if (GetTensor(iPoints[j], prevTensor) != Vector3d.Unset)
                        {
                            nextPt = iPoints[j] + sign * GetTensor(iPoints[j], prevTensor);

                            currPointList.Add(iPoints[j]);
                            prevTensor = GetTensor(iPoints[j], prevTensor);
                        }

                        int f = 0;
                        while (CheckPt(nextPt) && f < 100)
                        {
                            currPointList.Add(nextPt);
                            nextTensor = GetTensor(currPointList[currPointList.Count - 1], prevTensor);
                            nextPt = currPointList[currPointList.Count - 1] + sign * nextTensor;
                            f++;
                            prevTensor = nextTensor;
                        }

                        double t = 0;
                        boundary.ClosestPoint((currPointList[currPointList.Count - 1]), out t, step + 5);

                        if (boundary.Contains(nextPt) == PointContainment.Outside && CheckPt(currPointList[currPointList.Count - 1]))
                            currPointList.Add(boundary.PointAt(t));
                        else
                        {
                            if (pointCloud.Count > 0)
                            {
                                Point3d pt = pointCloud[pointCloud.ClosestIndex(nextPt)];
                                // if ((pt.DistanceTo(nextPt) <= roadDensity) && f > 0)
                                currPointList.Add(pt);
                            }
                        }

                        outputCurves.Add(new PolylineCurve(currPointList));
                        currCurves.Add(new PolylineCurve(currPointList));
                        sign = -1;
                    }

                    pointCloud.AddRange(currPointList);
                    pointCloud.AddRange(prevPointList);
                }
                iPoints.Clear();

                foreach (PolylineCurve curve in currCurves)
                {
                    if (curve != null && curve.GetLength() > 0.1)
                    {
                        // if (curve.DivideEquidistant(blockWidth) != null)
                        //   iPoints.AddRange(new List<Point3d>(curve.DivideEquidistant(blockWidth)));
                        List<Point3d> points = new List<Point3d>();
                        for (int q = 0; q < curve.PointCount; q++)
                            points.Add(curve.Point(q));
                        iPoints.AddRange(points);
                    }
                }

                angle += 90;
            }

            DA.SetDataList(0, outputCurves);
        }


        public Vector3d GetTensor(Point3d point, Vector3d prevTensor)
        {
            Vector3d tensor = GetTensorInPoint(point);
            tensor.Rotate(Rhino.RhinoMath.ToRadians(angle), Vector3d.ZAxis);
            tensor.Unitize();
            prevTensor.Unitize();
            if (tensor != Vector3d.Unset)
            {
                if (Math.Abs(Vector3d.VectorAngle(tensor, prevTensor)) < Rhino.RhinoMath.ToRadians(90))
                    return (tensor * step);
                else
                    return (tensor * -step);
            }

            return Vector3d.Unset;
        }

        public Vector3d GetTensorInPoint(Point3d point)
        {
            return GridVectors[GetGridPointIndex(point)];
        }

        public int GetGridPointIndex(Point3d point)
        {
            int xI = (int)((point.X - GridFirstPoint.X) / (GridLastPoint.X - GridFirstPoint.X) * gridRes + 0.5);
            int yI = (int)((point.Y - GridFirstPoint.Y) / (GridLastPoint.Y - GridFirstPoint.Y) * gridRes + 0.5);
            int index = xI * (gridRes + 1) + yI;

            return Rhino.RhinoMath.Clamp(index, 0, (gridRes + 1) * (gridRes + 1) - 1);
        }

        public bool CheckPt(Point3d point)
        {
            if (pointCloud.Count > 0)
            {
                double t = pointCloud[pointCloud.ClosestIndex(point)].DistanceTo(point);
                if (t <= roadDensity && t > 0)
                {
                    return false;

                }
            }

            if (boundary.Contains(point) != PointContainment.Inside)
                return false;


            return true;
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        /// 
        /// 
        /// 
        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{b02654b4-ffbc-41eb-a64a-13a6f7a7b8ed}"); }
        }
    }
}

<./studies\Study6\TensorFields Quad.cs>
﻿using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Rhino.Geometry;
using Rhino.Collections;

namespace FloorPlan_Generator
{

    public class PointCloudStructure
    {
        public PointCloudStructure()
        {
        }
        public PointCloudStructure(Point3d p, int n)
        {
            point = p;
            num = n;
        }
        Point3d point;
        int num = 0;
    }

    public class GHcTensorFields_Quad : GH_Component
    {
        public Point3d GridFirstPoint;
        public Point3d GridLastPoint;
        public int gridRes;
        public List<Vector3d> GridVectors;
        public double step;
        public double roadDensity;
        public double angle;
        public Point3dList pointCloud;
        public List<PointCloudStructure> pointCloudStructureList;
        Curve boundary;

        /// <summary>
        /// Initializes a new instance of the TensorFieldsGHc class.
        /// </summary>
        public GHcTensorFields_Quad()
          : base("Tensor Fields QUad", "Tensor Fields QUad",
              "Tensor Fields QUad",
              "FloorPlanGen", "Study_6")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddPointParameter("Points", "Points", "Points", GH_ParamAccess.list);
            pManager.AddVectorParameter("GridVectors", "GridVectors", "GridVectors", GH_ParamAccess.list);
            pManager.AddPointParameter("FirstPt", "FirstPt", "First point of GridVectors", GH_ParamAccess.item);
            pManager.AddPointParameter("LastPt", "LastPt", "Last point of GridVectors", GH_ParamAccess.item);
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            //pManager.AddNumberParameter("RoadDensity", "RoadDensity", "RoadDensity", GH_ParamAccess.item);
            pManager.AddNumberParameter("RoadDensity", "RoadDensity", "RoadDensity", GH_ParamAccess.item, 50);
            pManager.AddNumberParameter("Angle", "Angle", "Angle", GH_ParamAccess.item, 0.0);
            pManager.AddIntegerParameter("Iterations", "Iterations", "Iterations, usually it should be equal 3", GH_ParamAccess.item, 3);
            pManager.AddNumberParameter("Step", "Step", "Step", GH_ParamAccess.item, 10);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("RoadNetwork", "RoadNetwork", "RoadNetwork", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            int iterations = 3;
            List<Point3d> iPoints = new List<Point3d>();
            GridVectors = new List<Vector3d>();
            roadDensity = 0;
            double blockWidth = 0;
            List<Curve> outputCurves = new List<Curve>();
            pointCloudStructureList = new List<PointCloudStructure>();

            DA.GetDataList(0, iPoints);
            DA.GetDataList(1, GridVectors);
            DA.GetData(2, ref GridFirstPoint);
            DA.GetData(3, ref GridLastPoint);
            DA.GetData(4, ref boundary);
            DA.GetData(5, ref roadDensity);
            DA.GetData(6, ref angle);
            DA.GetData(7, ref iterations);
            DA.GetData(8, ref step);

            // step = blockWidth;
            // roadDensity = step - 10;

            gridRes = (int)Math.Sqrt(GridVectors.Count) - 1;
            pointCloud = new Point3dList();

            int sign = 1;
            Vector3d prevTensor = new Vector3d(0, 1, 0);
            Point3d nextPt = new Point3d();
            Vector3d nextTensor = new Vector3d();
            List<Point3d> currPointList = new List<Point3d>();
            List<Point3d> prevPointList = new List<Point3d>();











            for (int i = 0; i < 1; i++)
            {/////////////////////////////////////////////////////
                List<Curve> currCurves = new List<Curve>();

                for (int j = 0; j < iPoints.Count; j++) // J ======= iPoints
                {
                    sign = 1;
                    currPointList.Clear();
                    prevPointList.Clear();

                    for (int k = 0; k < 2; k++)
                    {
                        prevPointList = new List<Point3d>(currPointList);
                        currPointList.Clear();
                        //  prevTensor = new Vector3d((i + 1) % 2, (i) % 2, 0);
                        prevTensor = new Vector3d(0, 0, 0);

                        if (GetTensor(iPoints[j], prevTensor) != Vector3d.Unset)
                        {
                            nextPt = iPoints[j] + sign * GetTensor(iPoints[j], prevTensor);

                            currPointList.Add(iPoints[j]);
                            prevTensor = GetTensor(iPoints[j], prevTensor);
                        }

                        int f = 0;
                        while (CheckPt(nextPt) && f < 40)
                        {
                            currPointList.Add(nextPt);
                            pointCloudStructureList.Add(new PointCloudStructure(nextPt, currPointList.Count - 1));
                            nextTensor = GetTensor(currPointList[currPointList.Count - 1], prevTensor);
                            nextPt = currPointList[currPointList.Count - 1] + sign * nextTensor;
                            f++;
                            prevTensor = nextTensor;
                        }


                        if (pointCloud.Count > 0)
                        {
                            Point3d pt = pointCloud[pointCloud.ClosestIndex(nextPt)];
                            // if ((pt.DistanceTo(nextPt) <= roadDensity) && f > 0)
                            currPointList.Add(pt);
                        }

                        outputCurves.Add(new PolylineCurve(currPointList));
                        currCurves.Add(new PolylineCurve(currPointList));
                        sign = -1;
                    }

                    pointCloud.AddRange(currPointList);
                    pointCloud.AddRange(prevPointList);
                }
              /*  iPoints.Clear();

                foreach (PolylineCurve curve in currCurves)
                {
                    if (curve != null && curve.GetLength() > 0.1)
                    {
                        // if (curve.DivideEquidistant(blockWidth) != null)
                        //   iPoints.AddRange(new List<Point3d>(curve.DivideEquidistant(blockWidth)));
                        List<Point3d> points = new List<Point3d>();
                        for (int q = 0; q < curve.PointCount; q++)
                            points.Add(curve.Point(q));
                        iPoints.AddRange(points);
                    }
                }
                */

                angle += 90;
            }//////////////////////////////////////////////

            Point3dList tempList1 = pointCloud;
            pointCloud.Clear();

            for (int i = 0; i < 1; i++)
            {/////////////////////////////////////////////////////
                List<Curve> currCurves = new List<Curve>();

                for (int j = 0; j < iPoints.Count; j++) // J ======= iPoints
                {
                    sign = 1;
                    currPointList.Clear();
                    prevPointList.Clear();

                    for (int k = 0; k < 2; k++)
                    {
                        prevPointList = new List<Point3d>(currPointList);
                        currPointList.Clear();
                        //  prevTensor = new Vector3d((i + 1) % 2, (i) % 2, 0);
                        prevTensor = new Vector3d(0, 0, 0);

                        if (GetTensor(iPoints[j], prevTensor) != Vector3d.Unset)
                        {
                            nextPt = iPoints[j] + sign * GetTensor(iPoints[j], prevTensor);

                            currPointList.Add(iPoints[j]);
                            prevTensor = GetTensor(iPoints[j], prevTensor);
                        }

                        int f = 0;
                        while (CheckPt(nextPt) && f < 40)
                        {
                            currPointList.Add(nextPt);
                            pointCloudStructureList.Add(new PointCloudStructure(nextPt, currPointList.Count - 1));
                            nextTensor = GetTensor(currPointList[currPointList.Count - 1], prevTensor);
                            nextPt = currPointList[currPointList.Count - 1] + sign * nextTensor;
                            f++;
                            prevTensor = nextTensor;
                        }


                        if (pointCloud.Count > 0)
                        {
                            Point3d pt = pointCloud[pointCloud.ClosestIndex(nextPt)];
                            // if ((pt.DistanceTo(nextPt) <= roadDensity) && f > 0)
                            currPointList.Add(pt);
                        }

                        outputCurves.Add(new PolylineCurve(currPointList));
                        currCurves.Add(new PolylineCurve(currPointList));
                        sign = -1;
                    }

                    pointCloud.AddRange(currPointList);
                    pointCloud.AddRange(prevPointList);
                }
                iPoints.Clear();

                foreach (PolylineCurve curve in currCurves)
                {
                    if (curve != null && curve.GetLength() > 0.1)
                    {
                        // if (curve.DivideEquidistant(blockWidth) != null)
                        //   iPoints.AddRange(new List<Point3d>(curve.DivideEquidistant(blockWidth)));
                        List<Point3d> points = new List<Point3d>();
                        for (int q = 0; q < curve.PointCount; q++)
                            points.Add(curve.Point(q));
                        iPoints.AddRange(points);
                    }
                }

                angle += 90;
            }//////////////////////////////////////////////


            Point3dList tempList2 = pointCloud;
            pointCloud.Clear();


            pointCloud.AddRange(tempList1);
            pointCloud.AddRange(tempList2);




            for (int i = 0; i < 2; i++)
            {/////////////////////////////////////////////////////
                List<Curve> currCurves = new List<Curve>();

                for (int j = 0; j < iPoints.Count; j++) // J ======= iPoints
                {
                    sign = 1;
                    currPointList.Clear();
                    prevPointList.Clear();

                    for (int k = 0; k < 2; k++)
                    {
                        prevPointList = new List<Point3d>(currPointList);
                        currPointList.Clear();
                        //  prevTensor = new Vector3d((i + 1) % 2, (i) % 2, 0);
                        prevTensor = new Vector3d(0, 0, 0);

                        if (GetTensor(iPoints[j], prevTensor) != Vector3d.Unset)
                        {
                            nextPt = iPoints[j] + sign * GetTensor(iPoints[j], prevTensor);

                            currPointList.Add(iPoints[j]);
                            prevTensor = GetTensor(iPoints[j], prevTensor);
                        }

                        int f = 0;
                        while (CheckPt(nextPt) && f < 40)
                        {
                            currPointList.Add(nextPt);
                            pointCloudStructureList.Add(new PointCloudStructure(nextPt, currPointList.Count - 1));
                            nextTensor = GetTensor(currPointList[currPointList.Count - 1], prevTensor);
                            nextPt = currPointList[currPointList.Count - 1] + sign * nextTensor;
                            f++;
                            prevTensor = nextTensor;
                        }


                        if (pointCloud.Count > 0)
                        {
                            Point3d pt = pointCloud[pointCloud.ClosestIndex(nextPt)];
                            // if ((pt.DistanceTo(nextPt) <= roadDensity) && f > 0)
                            currPointList.Add(pt);
                        }

                        outputCurves.Add(new PolylineCurve(currPointList));
                        currCurves.Add(new PolylineCurve(currPointList));
                        sign = -1;
                    }

                   // pointCloud.AddRange(currPointList);
                    //pointCloud.AddRange(prevPointList);
                }
                iPoints.Clear();

                PolylineCurve curve = currCurves[0] as PolylineCurve;
                //foreach (PolylineCurve curve in currCurves)
               // {
                    if (curve != null && curve.GetLength() > 0.1)
                    {
                        // if (curve.DivideEquidistant(blockWidth) != null)
                        //   iPoints.AddRange(new List<Point3d>(curve.DivideEquidistant(blockWidth)));
                        List<Point3d> points = new List<Point3d>();
                        for (int q = 0; q < curve.PointCount; q++)
                            points.Add(curve.Point(q));
                        iPoints.AddRange(points);
                    }
             //   }

                angle += 90;
            }//////////////////////////////////////////////

            


            DA.SetDataList(0, outputCurves);
        }


        public Vector3d GetTensor(Point3d point, Vector3d prevTensor)
        {
            Vector3d tensor = GetTensorInPoint(point);
            tensor.Rotate(Rhino.RhinoMath.ToRadians(angle), Vector3d.ZAxis);
            tensor.Unitize();
            prevTensor.Unitize();
            if (tensor != Vector3d.Unset)
            {
                if (Math.Abs(Vector3d.VectorAngle(tensor, prevTensor)) < Rhino.RhinoMath.ToRadians(90))
                    return (tensor * step);
                else
                    return (tensor * -step);
            }

            return Vector3d.Unset;
        }

        public Vector3d GetTensorInPoint(Point3d point)
        {
            return GridVectors[GetGridPointIndex(point)];
        }

        public int GetGridPointIndex(Point3d point)
        {
            int xI = (int)((point.X - GridFirstPoint.X) / (GridLastPoint.X - GridFirstPoint.X) * gridRes + 0.5);
            int yI = (int)((point.Y - GridFirstPoint.Y) / (GridLastPoint.Y - GridFirstPoint.Y) * gridRes + 0.5);
            int index = xI * (gridRes + 1) + yI;

            return Rhino.RhinoMath.Clamp(index, 0, (gridRes + 1) * (gridRes + 1) - 1);
        }

        public bool CheckPt(Point3d point)
        {
            if (pointCloud.Count > 0)
            {
                double t = pointCloud[pointCloud.ClosestIndex(point)].DistanceTo(point);
                if (t <= roadDensity && t > 0)
                    return false;
            }

           // if (boundary.Contains(point) != PointContainment.Inside)
            //    return false;


            return true;
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        /// 
        /// 
        /// 
        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{b02654b4-ffbc-41eb-a64a-13a6f2a7b8ed}"); }
        }
    }
}

<./studies\Study7\EvoStrat.cs>
﻿using System;
using System.Collections.Generic;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System.Linq;
using Rhino;
using ClipperLib;

using Path = System.Collections.Generic.List<ClipperLib.IntPoint>;
using Paths = System.Collections.Generic.List<System.Collections.Generic.List<ClipperLib.IntPoint>>;
using System.Windows.Forms;

namespace FloorPlan_Generator
{
    public class EvoStrat : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public EvoStrat()
          : base("Evolutionary Strategy", "Evolutionary Strategy",
              "Evolutionary Strategy + Spring System",
              "FloorPlanGen", "Study_7")
        {
        }

        private List<Curve> rooms = new List<Curve>();
        private List<Curve> originalInputRooms = new List<Curve>();
        private List<Curve> currentInputRooms = new List<Curve>();
        List<string> adjStrList;
        private Random random = new Random();
        double proportionThreshold = 0;
        GeneCollection geneCollection;
        double boundaryArea = 0;
        bool Menu_ShuffleRoomsAtFirst = false;


        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddCurveParameter("Boundary", "Boundary", "Boundary", GH_ParamAccess.item);
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddTextParameter("Adjacencies", "Adjacencies", "Adjacencies as list of string \"1 - 3, 2 - 4,..\"", GH_ParamAccess.list, " - ");
            pManager.AddNumberParameter("ProportionThreshold", "ProportionThreshold", "ProportionThreshold, >= 1", GH_ParamAccess.item, 2);
            //pManager.AddIntegerParameter("SpringIterations", "SpringIterations", "SpringIterations", GH_ParamAccess.item, 0);
            pManager.AddNumberParameter("FF Balance", "FF Balance", "FF Balance\n[0,1]", GH_ParamAccess.item, 0);
            pManager.AddBooleanParameter("SpringCollAllGenes", "SpringCollAllGenes", "SpringCollAllGenes", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("AdaptArea", "AdaptArea", "AdaptArea", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Reset", "Reset", "Reset", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Rooms", "Rooms", "Rooms", GH_ParamAccess.list);
            pManager.AddLineParameter("Adjacencies", "Adjacences", "Adjacence lines", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {

            //List<Curve> rooms = new List<Curve>();
            Curve boundary = new PolylineCurve();
            bool shouldInstantiateRooms = false;
            adjStrList = new List<string>();
            List<Line> adjLines = new List<Line>();
            //int springIterations = 0;
            bool shouldClearGenes = false;
            bool springCollAllGenes = false;
            bool adaptArea = false;

            // DA.GetData("SpringIterations", ref springIterations);
            DA.GetData("Reset", ref shouldInstantiateRooms);
            DA.GetData("Boundary", ref boundary);

            currentInputRooms.Clear();
            DA.GetDataList(1, currentInputRooms);

            if (shouldInstantiateRooms || rooms.Count == 0 || boundaryArea != AreaMassProperties.Compute(boundary).Area 
                || originalInputRooms == null || !RoomListsAreEqual(originalInputRooms, currentInputRooms))
            {
                shouldClearGenes = true;
                boundaryArea = AreaMassProperties.Compute(boundary).Area;
                rooms.Clear();
                originalInputRooms.Clear();
                DA.GetDataList(1, rooms);
                DA.GetDataList(1, originalInputRooms);
                //originalInputRooms = CopyCurveList(rooms);
            }

            DA.GetData("ProportionThreshold", ref proportionThreshold);
            DA.GetData("FF Balance", ref Gene.fitnessFunctionBalance);
            DA.GetDataList("Adjacencies", adjStrList);
            DA.GetData("SpringCollAllGenes", ref springCollAllGenes);
            DA.GetData("AdaptArea", ref adaptArea);

            //Shuffle(ref adjStrList);

            int[,] adjArray = new int[adjStrList.Count, 2];

            for (int i = 0; i < adjStrList.Count; i++)
            {
                adjArray[i, 0] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjArray[i, 1] = Int32.Parse((adjStrList[i].Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            Gene.proportionThreshold = proportionThreshold;
            Gene.adjacencyList = adjArray;

            if (shouldClearGenes)
            {
                // Adapt room sum area to the boundary area
                if (adaptArea)
                {
                    double roomSumArea = 0;
                    foreach (Curve room in rooms)
                        roomSumArea += AreaMassProperties.Compute(room).Area;

                    foreach (Curve room in rooms)
                        room.Transform(Transform.Scale(room.GetBoundingBox(false).Center, Math.Sqrt(boundaryArea / roomSumArea)));// AreaMassProperties.Compute(room).Area;

                }

                shouldClearGenes = false;
                geneCollection = new GeneCollection(15, boundary);
                foreach (Gene gene in geneCollection.genes)
                    if (Menu_ShuffleRoomsAtFirst)
                        gene.InstantiateRandomly(rooms);
                    else
                        gene.Instantiate(rooms);
            }


            geneCollection.Iterate();

            // rooms = AdjacentContraction(rooms, adjStrList, boundary, out adjLines);

            if (springCollAllGenes)
                for (int l = 0; l < geneCollection.genes.Count; l++)
                {
                    Gene gene = geneCollection.genes[l];
                    rooms = gene.GetCurves();

                    rooms = CollisionDetectionMain(rooms, boundary);

                    gene.collection.Clear();
                    gene.Instantiate(rooms);
                }


            rooms = geneCollection.GetBest();
            AdjacentContraction(rooms, adjStrList, boundary, out adjLines);

            // for (int i = 0; i < springIterations; i++)
            //     rooms = CollisionDetectionMain(rooms, boundary);

            List<GH_Curve> GH_rooms = new List<GH_Curve>();
            foreach (Curve c in rooms)
                GH_rooms.Add(new GH_Curve(c));

            DA.SetDataList(0, GH_rooms);
            DA.SetDataList(1, adjLines);
        }

        protected bool RoomListsAreEqual(List<Curve> a, List<Curve> b)
        {
            if (a == null || b == null)
                return false;
            if (a.Count != b.Count)
                return false;
            for (int i = 0; i < a.Count; i++)
            {
                Vector3d differenceV = a[i].GetBoundingBox(false).Center - b[i].GetBoundingBox(false).Center;
                if (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y) > 0.001f)
                {
                    //AddRuntimeMessage(GH_RuntimeMessageLevel.Error, (Math.Abs(differenceV.X) + Math.Abs(differenceV.Y).ToString()));
                    return false;
                }
            }
         /*   for (int i = 0; i < a.Count; i++)
                if (AreaMassProperties.Compute(a[i]).Area != AreaMassProperties.Compute(b[i]).Area)
                    return false;
                    */

            return true;
        }

        protected List<Curve> CopyCurveList (List<Curve> a)
        {
            List<Curve> output = new List<Curve>();
            foreach (Curve curve in a)
                output.Add(curve.DuplicateCurve());

            return output;
                    }

        private List<Curve> CollisionDetectionMain(List<Curve> roomCurves, Curve boundary)
        {
            List<int> indexes = new List<int>();
            for (int i = 0; i < roomCurves.Count; i++)
                indexes.Add(i);


            // Check roomCurves[i] and roomCurves[j] intersection
            // Then let's move both rooms by 1/2 of the rebounding vector
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];

                for (int j = i + 1; j < roomCurves.Count; j++)

                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], roomCurves[j]);

                    if (intersectResult.intersect)
                    {
                        if (intersectResult.reboundingVector.X != 0)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.X / roomCurves[j].GetBoundingBox(false).Diagonal.X / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));
                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                            GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(intersectResult.reboundingVector.X / 2, 0, 0));
                                roomCurves[j].Translate(new Vector3d(-intersectResult.reboundingVector.X / 2, 0, 0));

                            }
                        }
                        else
                        {
                            // Change the proportions of rooms
                            double iScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);


                            double jScaleFactor = 1 - Math.Abs(intersectResult.reboundingVector.Y / roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2);
                            Point3d jScaleAnchor = roomCurves[j].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[j].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                            roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), 1 / jScaleFactor, jScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2]
                            // Else - change the position of the rooms
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[i]) < proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) > 1 / proportionThreshold &&
                              GetRoomXYProportion(roomCurves[j]) < proportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[j].Transform(Transform.Scale(new Plane(jScaleAnchor, Vector3d.ZAxis), jScaleFactor, 1 / jScaleFactor, 1));

                                roomCurves[i].Translate(new Vector3d(0, intersectResult.reboundingVector.Y / 2, 0));
                                roomCurves[j].Translate(new Vector3d(0, -intersectResult.reboundingVector.Y / 2, 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], roomCurves[j], Plane.WorldXY, 0.0001f) != RegionContainment.Disjoint)
                        {
                            BoundingBox aRoomBB = roomCurves[j].GetBoundingBox(false);
                            BoundingBox bRoomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).X) - (aRoomBB.Diagonal.X / 2 - bRoomBB.Diagonal.X / 2);
                            double yDist = Math.Abs((aRoomBB.Center - bRoomBB.Center).Y) - (aRoomBB.Diagonal.Y / 2 - bRoomBB.Diagonal.Y / 2);
                            if (xDist > yDist)
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist - bRoomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist + bRoomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((aRoomBB.Center - bRoomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist - bRoomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist + bRoomBB.Diagonal.Y, 0));
                            }
                        }
                    }

                }
            }


            // Check roomCurves[i] and boundary intersection
            // Let's do it twice to be sure that X and Y positions are both defined perfectly
            for (int l = 0; l < roomCurves.Count; l++)
            {
                int i = indexes[l];
                for (int t = 0; t < 1; t++)
                {
                    IntersectResult intersectResult = new IntersectResult();
                    intersectResult = Intersect2Curves(roomCurves[i], boundary);

                    if (intersectResult.intersect)
                    {
                        double boundaryProportionThreshold = 1;// proportionThreshold;

                        if (Math.Abs(intersectResult.reboundingVector.X) > 0.01f)
                        {

                            // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.X / roomCurves[i].GetBoundingBox(false).Diagonal.X);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(intersectResult.reboundingVector.X > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.X / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.X / 2, 0, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d((intersectResult.reboundingVector.X > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.X - Math.Abs(intersectResult.reboundingVector.X)), 0, 0));
                            }
                        }
                        else if (Math.Abs(intersectResult.reboundingVector.Y) > 0.01f)
                        { // Change the proportions of rooms
                            double iScaleFactor = Math.Abs(intersectResult.reboundingVector.Y / roomCurves[i].GetBoundingBox(false).Diagonal.Y);
                            Point3d iScaleAnchor = roomCurves[i].GetBoundingBox(false).Center + new Vector3d(0, intersectResult.reboundingVector.Y > 0 ?
                                -roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2 : roomCurves[i].GetBoundingBox(false).Diagonal.Y / 2, 0);

                            roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), 1 / iScaleFactor, iScaleFactor, 1));


                            // If the proportions of both rooms are in [0.5; 2] -> ok
                            // Else - change the position of the rooms and return previous scale
                            if (!(GetRoomXYProportion(roomCurves[i]) > 1 / boundaryProportionThreshold &&
                            GetRoomXYProportion(roomCurves[i]) < boundaryProportionThreshold))
                            {
                                roomCurves[i].Transform(Transform.Scale(new Plane(iScaleAnchor, Vector3d.ZAxis), iScaleFactor, 1 / iScaleFactor, 1));
                                roomCurves[i].Translate(new Vector3d(0, (intersectResult.reboundingVector.Y > 0 ? -1 : 1) * (roomCurves[i].GetBoundingBox(false).Diagonal.Y - Math.Abs(intersectResult.reboundingVector.Y)), 0));
                            }
                        }
                    }
                    else
                    {
                        if (Curve.PlanarClosedCurveRelationship(roomCurves[i], boundary, Plane.WorldXY, 0.0001f) != RegionContainment.AInsideB)
                        {
                            BoundingBox boundaryBB = boundary.GetBoundingBox(false);
                            BoundingBox roomBB = roomCurves[i].GetBoundingBox(false);
                            double xDist = Math.Abs((boundaryBB.Center - roomBB.Center).X) - boundaryBB.Diagonal.X / 2 - roomBB.Diagonal.X / 2;
                            double yDist = Math.Abs((boundaryBB.Center - roomBB.Center).Y) - boundaryBB.Diagonal.Y / 2 - roomBB.Diagonal.Y / 2;
                            if (xDist > yDist)
                            {
                                if ((boundaryBB.Center - roomBB.Center).X > 0)
                                    roomCurves[i].Translate(new Vector3d(xDist + roomBB.Diagonal.X, 0, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(-xDist - roomBB.Diagonal.X, 0, 0));
                            }
                            else
                            {
                                if ((boundaryBB.Center - roomBB.Center).Y > 0)
                                    roomCurves[i].Translate(new Vector3d(0, yDist + roomBB.Diagonal.Y, 0));
                                else
                                    roomCurves[i].Translate(new Vector3d(0, -yDist - roomBB.Diagonal.Y, 0));
                            }
                        }
                    }
                }
            }
            return roomCurves;
        }

        public PolylineCurve PathToPolyline(Path path, int clipperPrecision = 100)
        {
            List<Point3d> points = new List<Point3d>();
            foreach (IntPoint intPoint in path)
                points.Add(new Point3d(intPoint.X / (double)clipperPrecision, intPoint.Y / (double)clipperPrecision, 0));
            PolylineCurve polyline = new PolylineCurve(points);

            return polyline;
        }

        public Path CurveToPath(Curve curve, int clipperPrecision = 100)
        {
            Path points = new Path();

            for (int i = 0; i < 4; i++)
                points.Add(new IntPoint((int)(curve.GetBoundingBox(false).GetCorners()[i].X * clipperPrecision),
                    (int)(curve.GetBoundingBox(false).GetCorners()[i].Y * clipperPrecision)));

            return points;
        }

        private IntersectResult Intersect2Curves(Curve a, Curve b)
        {
            int clipperPrecision = 100;
            IntersectResult result = new IntersectResult();
            if (Curve.PlanarCurveCollision(a, b, Plane.WorldXY, 0.001f))
            {
                Clipper clipper = new Clipper();
                Path subjectA = CurveToPath(a, clipperPrecision);
                Path subjectB = CurveToPath(b, clipperPrecision);
                Paths solution = new Paths();

                clipper.AddPath(subjectA, PolyType.ptClip, true);
                clipper.AddPath(subjectB, PolyType.ptSubject, true);

                clipper.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                if (solution.Count > 0)
                {
                    result.intersect = true;
                    PolylineCurve pl = PathToPolyline(solution[0], clipperPrecision);
                    result.unionCurve = pl;

                    Point3d minPoint = pl.GetBoundingBox(false).Min;
                    Point3d maxPoint = pl.GetBoundingBox(false).Max;

                    if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                    {
                        result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                        if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                            result.reboundingVector.Y *= -1;
                    }
                    else
                    {
                        result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                        if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                            result.reboundingVector.X *= -1;
                    }

                }
            }



            /*  Curve[] unionCurveArray = Curve.CreateBooleanIntersection(a, b);
              if (unionCurveArray.Length > 0)
              {
                  result.intersect = true;
                  result.unionCurve = unionCurveArray[0];

                  // Find the smallest dimesion of unionCurve
                  Point3d minPoint = result.unionCurve.GetBoundingBox(false).Min;
                  Point3d maxPoint = result.unionCurve.GetBoundingBox(false).Max;

                  if (maxPoint.X - minPoint.X > maxPoint.Y - minPoint.Y)
                  {
                      result.reboundingVector = new Vector2d(0, -(maxPoint.Y - minPoint.Y));
                      if (AreaMassProperties.Compute(a).Centroid.Y > AreaMassProperties.Compute(b).Centroid.Y)
                          result.reboundingVector.Y *= -1;
                  }
                  else
                  {
                      result.reboundingVector = new Vector2d(-(maxPoint.X - minPoint.X), 0);
                      if (AreaMassProperties.Compute(a).Centroid.X > AreaMassProperties.Compute(b).Centroid.X)
                          result.reboundingVector.X *= -1;
                  }


              }
          }*/
            else
            {
                result.intersect = false;
                result.reboundingVector = Vector2d.Unset;
                result.unionCurve = null;
            }
            return result;
        }

        private struct IntersectResult
        {
            public Vector2d reboundingVector;
            public bool intersect;
            public Curve unionCurve;
        }

        private double GetRoomXYProportion(Curve room)
        {
            return (room.GetBoundingBox(false).Diagonal.X / (double)room.GetBoundingBox(false).Diagonal.Y);
        }


        private void Shuffle(ref List<Curve> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                Curve value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<string> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void Shuffle(ref List<int> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                int value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private List<Curve> AdjacentContraction(List<Curve> roomCurves, List<string> adjacenceStrings, Curve boundary, out List<Line> adjLines)
        {

            List<Adjacence> adjacences = new List<Adjacence>();

            foreach (string adjString in adjacenceStrings)
            {
                adjacences.Add(new Adjacence());
                adjacences[adjacences.Count - 1].aIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[0]));
                adjacences[adjacences.Count - 1].bIndex = Int32.Parse((adjString.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries)[1]));

            }

            foreach (Adjacence adj in adjacences)
            {
                Vector3d attractVector = roomCurves[adj.aIndex].GetBoundingBox(false).Center - roomCurves[adj.bIndex].GetBoundingBox(false).Center;

                Vector3d aDim = roomCurves[adj.aIndex].GetBoundingBox(false).Diagonal;
                Vector3d bDim = roomCurves[adj.bIndex].GetBoundingBox(false).Diagonal;

                if (Math.Abs(attractVector.X) - (aDim.X + bDim.X) / 2 > 0.001f ||
                    Math.Abs(attractVector.Y) - (aDim.Y + bDim.Y) / 2 > 0.001f)
                {

                    if (Math.Abs(attractVector.X) > Math.Abs(attractVector.Y))
                    {
                        attractVector.Y = 0;
                        aDim.Y = 0;
                        bDim.Y = 0;
                    }
                    else
                    {
                        attractVector.X = 0;
                        aDim.X = 0;
                        bDim.X = 0;
                    }

                    Point3d attractCenter = roomCurves[adj.aIndex].GetBoundingBox(false).Center + attractVector / 2;
                    if (attractVector.X != 0)
                        if (attractCenter.X > roomCurves[adj.aIndex].GetBoundingBox(false).Center.X)
                            bDim *= -1;
                        else
                            aDim *= -1;
                    else
                        if (attractCenter.Y > roomCurves[adj.aIndex].GetBoundingBox(false).Center.Y)
                        bDim *= -1;
                    else
                        aDim *= -1;


                    // roomCurves[adj.aIndex].Translate(-attractVector / 2 + aDim / 2);
                    // roomCurves[adj.bIndex].Translate(attractVector / 2 + bDim / 2);
                }
            }

            adjLines = new List<Line>();

            foreach (Adjacence adj in adjacences)
            {
                adjLines.Add(new Line(roomCurves[adj.aIndex].GetBoundingBox(false).Center, roomCurves[adj.bIndex].GetBoundingBox(false).Center));
            }

            return roomCurves;
        }

        private class Adjacence
        {
            public int aIndex;
            public int bIndex;
        }

        public class Room
        {
            public double CenterX = 0;
            public double CenterY = 0;

            public double width = 0;
            // double height is used as a getter/setter function, so this variable doesn't exist actually

            public double area = 0;

            public Room(double CenterX, double CenterY, double width, double height)
            {
                this.CenterX = CenterX;
                this.CenterY = CenterY;
                this.width = width;
                this.area = width * height;
            }

            public Room()
            {
            }

            public Room(Point3d centerPoint, double width, double height)
            {
                this.CenterX = centerPoint.X;
                this.CenterY = centerPoint.Y;
                this.width = width;
                this.area = width * height;
            }

            public Room(Curve roomCurve)
            {
                this.CenterX = roomCurve.GetBoundingBox(false).Center.X;
                this.CenterY = roomCurve.GetBoundingBox(false).Center.Y;
                this.width = roomCurve.GetBoundingBox(false).Diagonal.X;
                this.area = roomCurve.GetBoundingBox(false).Diagonal.X * roomCurve.GetBoundingBox(false).Diagonal.Y;
            }

            // IMPORTANT: think about what precision means
            public Path GetClipperLibPath(int precision = 100)
            {

                IntPoint a = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY - height / 2) * precision));
                IntPoint b = new IntPoint((int)((CenterX - width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint c = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY + height / 2) * precision));
                IntPoint d = new IntPoint((int)((CenterX + width / 2) * precision), (int)((CenterY - height / 2) * precision));

                Path output = new Path(new List<IntPoint>() { a, b, c, d });
                return output;
            }

            public Room Clone()
            {
                Room r = new Room(CenterX, CenterY, width, this.height);
                return r;
            }

            public double height
            {
                get
                {
                    return area / width;
                }
                set
                {
                    width = area / value;
                }
            }

        }

        public class Gene
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Room> collection = new List<Room>();
            public static int[,] adjacencyList;// = new int[0, 2];
            public static Curve boundary;
            public static double proportionThreshold = 2f;
            public static double fitnessFunctionBalance = 0.5f;


            public Gene(int[,] adjacences)
            {
                adjacencyList = adjacences;
            }

            public Gene()
            {
            }

            public double FitnessFunctionG()
            {
                // return 3;
                double fitnessFunctionVar = 0;
                int precision = 100;

                Clipper cc = new ClipperLib.Clipper();

                Paths solution = new Paths();
                Paths subjects = new Paths();
                Paths clips = new Paths();



                foreach (Room room in collection)
                    subjects.Add(new Path(room.GetClipperLibPath(precision)));

                IntPoint boundaryA = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryB = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X - boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryC = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y + boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));

                IntPoint boundaryD = new IntPoint(
                    (int)((boundary.GetBoundingBox(false).Center.X + boundary.GetBoundingBox(false).Diagonal.X / 2) * precision)
                    , (int)((boundary.GetBoundingBox(false).Center.Y - boundary.GetBoundingBox(false).Diagonal.Y / 2) * precision));


                clips.Add(new Path(new List<IntPoint>() { boundaryA, boundaryB, boundaryC, boundaryD }));

                cc.AddPaths(subjects, PolyType.ptSubject, true);
                cc.AddPaths(clips, PolyType.ptClip, true);


                cc.Execute(ClipType.ctIntersection, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);

                foreach (Path path in solution)
                {
                    fitnessFunctionVar += Clipper.Area(path);
                }


                return fitnessFunctionVar;
            }

            public double FitnessFunctionT()
            {
                double distanceSum = 0;
                for (int i = 0; i < adjacencyList.GetLength(0); i++)
                {
                    Room a = collection[adjacencyList[i, 0]].Clone();
                    Room b = collection[adjacencyList[i, 1]].Clone();

                    double distX = Math.Abs(a.CenterX - b.CenterX) - a.width / 2f - b.width / 2f;
                    double distY = Math.Abs(a.CenterY - b.CenterY) - a.height / 2f - b.height / 2f;

                    distanceSum += Math.Max(Math.Abs(distX), Math.Abs(distY));
                }
                return distanceSum;
            }

            public double FitnessFunction()
            {
                return (FitnessFunctionG() * fitnessFunctionBalance + 1 / (FitnessFunctionT()) * (1 - fitnessFunctionBalance));
            }

            public Gene Clone()
            {
                List<Room> newColl = new List<Room>(collection);
                Gene t = new Gene();
                // t.collection = newColl;
                foreach (Room r in collection)
                    t.collection.Add(r.Clone());

                return t;
            }

            public void InstantiateRandomly(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));

                    // set width
                    collection[collection.Count - 1].width = Math.Sqrt(collection[collection.Count - 1].area
                        / proportionThreshold) + random.NextDouble()
                        * (Math.Sqrt(collection[collection.Count - 1].area * proportionThreshold)
                        - Math.Sqrt(collection[collection.Count - 1].area / proportionThreshold));

                    // set X and Y
                    collection[collection.Count - 1].CenterX = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.X - collection[collection.Count - 1].width)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).X
                     + collection[collection.Count - 1].width / 2;

                    collection[collection.Count - 1].CenterY = random.NextDouble()
                        * (boundary.GetBoundingBox(false).Diagonal.Y - collection[collection.Count - 1].height)
                        + boundary.GetBoundingBox(false).Corner(true, true, true).Y
                        + collection[collection.Count - 1].height / 2;
                }
            }

            public Gene Instantiate(List<Curve> inputCollection)
            {
                for (int i = 0; i < inputCollection.Count; i++)
                {
                    collection.Add(new Room(inputCollection[i]));
                }
                return this;
            }

            public List<Curve> GetCurves()
            {
                List<Curve> curvesList = new List<Curve>();
                foreach (Room room in collection)
                {
                    curvesList.Add(new Rectangle3d(new Plane(new Point3d(room.CenterX - room.width / 2, room.CenterY - room.height / 2, 0), Vector3d.ZAxis), room.width, room.height).ToNurbsCurve());
                }
                return curvesList;
            }

            public void MutateSomehow()
            {
                double mutationProb = 0.3f;
                double mutationChangeK = 0.2f; // (boundary.width or .height or ... ) * mutationChangeK = max change
                foreach (Room room in collection)
                {
                    if (random.NextDouble() < mutationProb)
                    {
                        if (random.NextDouble() < mutationProb)
                            room.CenterX += boundary.GetBoundingBox(false).Diagonal.X * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.CenterY += boundary.GetBoundingBox(false).Diagonal.Y * mutationChangeK * (random.NextDouble() - 0.5f);

                        if (random.NextDouble() < mutationProb)
                            room.width = Math.Sqrt(room.area / proportionThreshold) + random.NextDouble()
                                * (Math.Sqrt(room.area * proportionThreshold) - Math.Sqrt(room.area / proportionThreshold));

                        // Check whether the room is outside the boundary

                        if (room.CenterX - room.width / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(true, true, true).X + room.width / 2;

                        if (room.CenterX + room.width / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).X)
                            room.CenterX = boundary.GetBoundingBox(false).Corner(false, false, false).X - room.width / 2;

                        if (room.CenterY - room.height / 2 < boundary.GetBoundingBox(false).Corner(true, true, true).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(true, true, true).Y + room.height / 2;

                        if (room.CenterY + room.height / 2 > boundary.GetBoundingBox(false).Corner(false, false, false).Y)
                            room.CenterY = boundary.GetBoundingBox(false).Corner(false, false, false).Y - room.height / 2;
                    }
                }
            }

        }

        public class GeneCollection
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            public List<Gene> genes;
            int number;

            public GeneCollection(int geneNumber, Curve boundary)
            {
                Gene.boundary = boundary;
                number = geneNumber;
                genes = new List<Gene>();
                for (int i = 0; i < number; i++)
                    genes.Add(new Gene());
            }

            public void SortGenes()
            {
                genes = genes.OrderBy(i => -i.FitnessFunction()).ToList();

            }

            public void Iterate()
            {
                double newGenesNumK = 4;
                // mutations + cross-over + newbies

                #region CROSS-OVER
                int[,] mutationIndexes = new int[(int)(number * newGenesNumK), 2];
                for (int i = 0; i < number * newGenesNumK; i++)
                {
                    mutationIndexes[i, 0] = random.Next(number);
                    mutationIndexes[i, 1] = random.Next(number);
                }

                for (int i = 0; i < number * newGenesNumK; i++)
                {
                    genes.Add(CrossOverGenes(genes[mutationIndexes[i, 0]], genes[mutationIndexes[i, 1]]));
                }

                #endregion

                #region MUTATION
                for (int i = 0; i < number * newGenesNumK; i++)
                {
                    Gene mutGene = genes[random.Next(0, genes.Count)].Clone();

                    mutGene.MutateSomehow();
                    genes.Add(mutGene);
                }
                #endregion

                #region NEWBIES
                for (int i = 0; i < number * newGenesNumK; i++)
                {
                    Gene newGene = new Gene();
                    newGene.InstantiateRandomly(genes[0].GetCurves());
                    genes.Add(newGene);
                }
                #endregion

                SortGenes();
                genes.RemoveRange(number, genes.Count - 1 - number);

            }

            private Gene CrossOverGenes(Gene a, Gene b)
            {
                double mutationProb = 0.5f;
                Gene c = a.Clone();

                for (int i = 0; i < a.collection.Count; i++)
                    if (random.NextDouble() > mutationProb)
                        c.collection[i] = b.collection[i].Clone();

                return c;
            }

            public List<Curve> GetBest()
            {
                SortGenes();
                return genes[0].GetCurves();
            }
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                // You can add image files to your project resources and access them like this:
                //return Resources.IconForThisComponent;
                return null;
            }
        }


        protected override void AppendAdditionalComponentMenuItems(ToolStripDropDown menu)
        {
            Menu_AppendItem(menu, "Shuffle rooms at first", Menu_ShuffleRoomsAtFirstChecked, true, Menu_ShuffleRoomsAtFirst);

            base.AppendAdditionalComponentMenuItems(menu);
        }

        public void Menu_ShuffleRoomsAtFirstChecked(object sender, EventArgs e)
        {
            Menu_ShuffleRoomsAtFirst = !Menu_ShuffleRoomsAtFirst;
            this.ExpireSolution(true);
        }

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{7b02cbd7-910f-47cf-9601-128a8d999506}"); }
        }
    }
}


